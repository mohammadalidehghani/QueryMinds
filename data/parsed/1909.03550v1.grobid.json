{
  "title": "",
  "abstract": "We use the following mathematical notation in this writeup: • Vectors are denoted by boldface lower-case letters such as x ∈ R d . Coordinates of vectors are denoted by underscore notation x i or regular brackets x(i). • Matrices are denoted by boldface upper-case letters such as X ∈ R m×n . Their coordinates by X(i, j), or X ij . • Functions are denoted by lower case letters f : R d → R. • The k-th differential of function f is denoted by The gradient is denoted without the superscript, as ∇f . • We use the mathcal macro for sets, such as K ⊆ R d . • We denote the gradient at point x t as ∇ xt , or simply ∇ t . • We denote the global or local optima of functions by x . • We denote distance to optimality for iterative algorithms by h t = f (x t ) -f (x ). • Euclidean distance to optimality is denoted d t = x t -x .",
  "introduction": "Introduction The topic of this lecture series is the mathematical optimization approach to machine learning. In standard algorithmic theory, the burden of designing an efficient algorithm for solving a problem at hand is on the algorithm designer. In the decades since in the introduction of computer science, elegant algorithms have been designed for tasks ranging from finding the shortest path in a graph, computing the optimal flow in a network, compressing a computer file containing an image captured by digital camera, and replacing a string in a text document. The design approach, while useful to many tasks, falls short of more complicated problems, such as identifying a particular person in an image in bitmap format, or translating text from English to Hebrew. There may very well be an elegant algorithm for the above tasks, but the algorithmic design scheme does not scale. As Turing promotes in his paper [83] , it is potentially easier to teach a computer to learn how to solve a task, rather than teaching it the solution for the particular tasks. In effect, that's what we do at school, or in this lecture series... The machine learning approach to solving problems is to have an automated mechanism for learning an algorithm. Consider the problem of classifying images into two categories: those containing cars and those containing chairs (assuming there are only two types of images in the world). In ML we train (teach) a machine to achieve the desired functionality. The same machine can potentially solve any algorithmic task, and differs from task to task only by a set of parameters that determine the functionality of the machine. This is much like the wires in a computer chip determine its functionality. Indeed, one of the most popular machines are artificial neural networks. The mathematical optimization approach to machine learning is to view the process of machine training as an optimization problem. If we let w ∈ R d be the parameters of our machine (a.k.a. model), that are constrained to be in some set K ⊆ R d , and f the function measuring success in mapping examples to their correct label, then the problem we are interested in is described by the mathematical optimization problem of min w∈K f (w) (1.1) This is the problem that the lecture series focuses on, with particular emphasis on functions that arise in machine learning and have special structure that allows for efficient algorithms.",
  "body": "Preface This text was written to accompany a series of lectures given at the Machine Learning Summer School Buenos Aires, following a lecture series at the Simons Center for Theoretical Computer Science, Berkeley. It was extended for the course COS 598D -Optimization for Machine Learning, Princeton University, Spring 2019. I am grateful to Paula Gradu for proofreading parts of this manuscript. I'm also thankful for the help of the following students and colleagues for corrections and suggestions to this text: Udaya Ghai, John Hallman, Noé Pion, Xinyi Chen. Chapter 1 iii Preface Introduction The topic of this lecture series is the mathematical optimization approach to machine learning. In standard algorithmic theory, the burden of designing an efficient algorithm for solving a problem at hand is on the algorithm designer. In the decades since in the introduction of computer science, elegant algorithms have been designed for tasks ranging from finding the shortest path in a graph, computing the optimal flow in a network, compressing a computer file containing an image captured by digital camera, and replacing a string in a text document. The design approach, while useful to many tasks, falls short of more complicated problems, such as identifying a particular person in an image in bitmap format, or translating text from English to Hebrew. There may very well be an elegant algorithm for the above tasks, but the algorithmic design scheme does not scale. As Turing promotes in his paper [83] , it is potentially easier to teach a computer to learn how to solve a task, rather than teaching it the solution for the particular tasks. In effect, that's what we do at school, or in this lecture series... The machine learning approach to solving problems is to have an automated mechanism for learning an algorithm. Consider the problem of classifying images into two categories: those containing cars and those containing chairs (assuming there are only two types of images in the world). In ML we train (teach) a machine to achieve the desired functionality. The same machine can potentially solve any algorithmic task, and differs from task to task only by a set of parameters that determine the functionality of the machine. This is much like the wires in a computer chip determine its functionality. Indeed, one of the most popular machines are artificial neural networks. The mathematical optimization approach to machine learning is to view the process of machine training as an optimization problem. If we let w ∈ R d be the parameters of our machine (a.k.a. model), that are constrained to be in some set K ⊆ R d , and f the function measuring success in mapping examples to their correct label, then the problem we are interested in is described by the mathematical optimization problem of min w∈K f (w) (1.1) This is the problem that the lecture series focuses on, with particular emphasis on functions that arise in machine learning and have special structure that allows for efficient algorithms. Examples of optimization problems in machine learning 1.Empirical Risk Minimization Machine learning problems exhibit special structure. For example, one of the most basic optimization problems in supervised learning is that of fitting a model to data, or examples, also known as the optimization problem of Empirical Risk Minimization (ERM). The special structure of the problems arising in such formulations is separability across different examples into individual losses. An example of such formulation is the supervised learning paradigm of linear classification. In this model, the learner is presented with positive and negative examples of a concept. Each example, denoted by a i , is represented in Euclidean space by a d dimensional feature vector. For example, a common representation for emails in the spam-classification problem are binary vectors in Euclidean space, where the dimension of the space is the number of words in the language. The i'th email is a vector a i whose entries are given as ones for coordinates corresponding to words that appear in the email, and zero otherwise 1 . In addition, each example has a label b i ∈ {-1, +1}, corresponding to whether the email has been labeled spam/not spam. The 1 Such a representation may seem naïve at first as it completely ignores the words' order of appearance and their context. Extensions to capture these features are indeed studied in the Natural Language Processing literature. goal is to find a hyperplane separating the two classes of vectors: those with positive labels and those with negative labels. If such a hyperplane, which completely separates the training set according to the labels, does not exist, then the goal is to find a hyperplane that achieves a separation of the training set with the smallest number of mistakes. Mathematically speaking, given a set of m examples to train on, we seek x ∈ R d that minimizes the number of incorrectly classified examples, i.e. min x∈R d 1 m i∈[m] δ(sign(x a i ) = b i ) (1.2) where sign(x) ∈ {-1, +1} is the sign function, and δ(z) ∈ {0, 1} is the indicator function that takes the value 1 if the condition z is satisfied and zero otherwise. The mathematical formulation of the linear classification above is a special case of mathematical programming (1.1) , in which f (x) = 1 m i∈[m] δ(sign(x a i ) = b i ) = E i∼[m] [ℓ i (x)], where we make use of the expectation operator for simplicity, and denote ℓ i (x) = δ(sign(x a i ) = b i ) for brevity. Since the program above is nonconvex and non-smooth, it is common to take a convex relaxation and replace ℓ i with convex loss functions. Typical choices include the means square error function and the hinge loss, given by ℓ a i ,b i (x) = max{0, 1 -b i • x a i }. This latter loss function in the context of binary classification gives rise to the popular soft-margin SVM problem. Another important optimization problem is that of training a deep neural network for binary classification. For example, consider a dataset of images, represented in bitmap format and denoted by {a i ∈ R d |i ∈ [m]}, i.e. m images over n pixels. We would like to find a mapping from images to the two categories, {b i ∈ {0, 1}} of cars and chairs. The mapping is given by a set of parameters of a machine class, such as weights in a neural network, or values of a support vector machine. We thus try to find the optimal parameters that match a i to b, i..e min w∈R d f (w) = E a i ,b i [ℓ(f w (a i ), b i )] . Matrix completion and recommender systems Media recommendations have changed significantly with the advent of the Internet and rise of online media stores. The large amounts of data collected allow for efficient clustering and accurate prediction of users' preferences for a variety of media. A well-known example is the so called \"Netflix challenge\"-a competition of automated tools for recommendation from a large dataset of users' motion picture preferences. One of the most successful approaches for automated recommendation systems, as proven in the Netflix competition, is matrix completion. Perhaps the simplest version of the problem can be described as follows. The entire dataset of user-media preference pairs is thought of as a partially-observed matrix. Thus, every person is represented by a row in the matrix, and every column represents a media item (movie). For simplicity, let us think of the observations as binary-a person either likes or dislikes a particular movie. Thus, we have a matrix M ∈ {0, 1, * } n×m where n is the number of persons considered, m is the number of movies at our library, and 0/1 and * signify \"dislike\", \"like\" and \"unknown\" respectively: M ij =            0, person i dislikes movie j 1, person i likes movie j * , preference unknown . The natural goal is to complete the matrix, i.e. correctly assign 0 or 1 to the unknown entries. As defined so far, the problem is ill-posed, since any completion would be equally good (or bad), and no restrictions have been placed on the completions. The common restriction on completions is that the \"true\" matrix has low rank. Recall that if a matrix X ∈ R n×m has rank k ≤ ρ = min{n, m} then it can be written as X = U V , U ∈ R n×k , V ∈ R k×m . The intuitive interpretation of this property is that each entry in M can be explained by only k numbers. In matrix completion this means, intuitively, that there are only k factors that determine a persons preference over movies, such as genre, director, actors and so on. Now the simplistic matrix completion problem can be well-formulated as in the following mathematical program. Denote by • OB the Euclidean EXAMPLES OF OPTIMIZATION PROBLEMS IN MACHINE LEARNING7 norm only on the observed (non starred) entries of M , i.e., X 2 OB = M ij = * X 2 ij . The mathematical program for matrix completion is given by min X∈R n×m 1 2 X -M 2 OB s.t. rank(X) ≤ k. Learning in Linear Dynamical Systems Many learning problems require memory, or the notion of state. This is captured by the paradigm of reinforcement learning, as well of the special case of control in Linear Dynamical Systems (LDS). LDS model a variety of control and robotics problems in continuous variables. The setting is that of a time series, with following parameters: 1. Inputs to the system, also called controls, denoted by u 1 , ..., u T ∈ R n . 2. Outputs from the system, also called observations, denoted y 1 , ..., y T ∈ R m . 3. The state of the system, which may either be observed or hidden, denoted x t , ..., x T ∈ R d . 4. The system parameters, which are transformations matrices A, B, C, D in appropriate dimensions. In the online learning problem of LDS, the learner iteratively observes u t , y t , and has to predict ŷt+1 . The actual y t is generated according to the following dynamical equations: x t+1 = Ax t + Bu t + ε t y t+1 = Cx t+1 + Du t + ζ t , where ε t , ζ t are noise which is distributed as a Normal random variable. Consider an online sequence in which the states are visible. At time t, all system states, inputs and outputs are visible up to this time step. The learner has to predict y t+1 , and only afterwards observes u t+1 .x t+1 , y t+1 . CHAPTER 1. INTRODUCTION One reasonable way to predict y t+1 based upon past observations is to compute the system, and use the computed transformations to predict. This amounts to solving the following mathematical program: min A,B, Ĉ, D τ <t (x τ +1 -Ax τ + Bu τ ) 2 + (y τ +1 -Ĉx τ + Du τ ) 2 , and then predicting ŷt+1 = Ĉ Â(x t + Bu t ) + Du t . Why is mathematical programming hard? The general formulation (1.1) is NP hard. To be more precise, we have to define the computational model we are working in as well as and the access model to the function. Before we give a formal proof, the intuition to what makes mathematical optimization hard is simple to state. In one line: it is the fact that global optimality cannot be verified on the basis of local properties. Most, if not all, efficient optimization algorithms are iterative and based on a local improvement step. By this nature, any optimization algorithm will terminate when the local improvement is no longer possible, giving rise to a proposed solution. However, the quality of this proposed solution may differ significantly, in general, from that of the global optimum. This intuition explains the need for a property of objectives for which global optimality is locally verifiable. Indeed, this is exactly the notion of convexity, and the reasoning above explains its utmost importance in mathematical optimization. We now to prove that mathematical programming is NP-hard. This requires discussion of the computational model as well as access model to the input. The computational model The computational model we shall adopt throughout this manuscript is that of a RAM machine equipped with oracle access to the objective function f : R d → R and constraints set K ⊆ R d . The oracle model for the objective function can be one of the following, depending on the specific scenario: 1. Value oracle: given a point x ∈ R d , oracle returns f (x) ∈ R. 2. Gradient (first-order) oracle: given a point x ∈ R d , oracle returns the gradient ∇f (x) ∈ R d . 3. k-th order differential oracle: given a point x ∈ R d , oracle returns the tensor ∇ k f (x) ∈ R d k . The oracle model for the constraints set is a bit more subtle. We distinguish between the following oracles: 1. Membership oracle: given a point x ∈ R d , oracle returns one if x ∈ K and zero otherwise. 2. Separating hyperplane oracle: given a point x ∈ R d , oracle either returns \"Yes\" if x ∈ K, or otherwise returns a hyperplane h ∈ R d such that h x > 0 and ∀y ∈ K , h y ≤ 0. 3. Explicit sets: the most common scenario in machine learning is one in which K is \"natural\", such as the Euclidean ball or hypercube, or the entire Euclidean space. Hardness of constrained mathematical programming Under this computational model, we can show: Lemma 1.1. Mathematical programming is NP-hard, even for a convex continuous constraint set K and quadratic objective functions. Informal sketch. Consider the MAX-CUT problem: given a graph G = (V, E), find a subset of the vertices that maximizes the number of edges cut. Let A be the negative adjacency matrix of the graph, i.e. A ij =    -1, (i, j) ∈ E 0, o/w Also suppose that A ii = 0. Next, consider the mathematical program: min f A (x) = 1 4 (x Ax -2|E|) (1.3) x ∞ = 1 . Consider the cut defined by the solution of this program, namely S x = {i ∈ V |x i = 1}, for x = x . Let C(S) denote the size of the cut specified by the subset of edges S ⊆ E. Observe that the expression 1 2 x Ax, is exactly equal to the number of edges that are cut by S x minus the number of edges that are uncut. Thus, we have 1 2 xAx = C(S x ) -(E -C(S x )) = 2C(S x ) -E, and hence f (x) = C(S x ). Therefore, maximizing f (x) is equivalent to the MAX-CUT problem, and is thus NP-hard. We proceed to make the constraint set convex and continuous. Consider the mathematical program min {f A (x)} (1.4) x ∞ ≤ 1 . This is very similar to the previous program, but we relaxed the equality to be an inequality, consequently the constraint set is now the hypercube. We now claim that the solution is w.l.o.g. a vertex. To see that, consider y(x) ∈ {±1} d a rounding of x to the corners defined by: y i = y(x) i =    1, w.p. 1+x i 2 -1, w.p. 1-x i 2 Notice that E[y] = x , ∀i = j . E[y i y j ] = x i x j , and therefore E[y(x) Ay(x)] = x Ax. We conclude that the optimum of mathematical program 1.4 is the same as that for 1.3, and both are NPhard. Chapter 2 Basic concepts in optimization and analysis Basic definitions and the notion of convexity We consider minimization of a continuous function over a convex subset of Euclidean space. We mostly consider objective functions that are convex. In later chapters we relax this requirement and consider non-convex functions as well. Henceforth, let K ⊆ R d be a bounded convex and compact set in Euclidean space. We denote by D an upper bound on the diameter of K: ∀x, y ∈ K, xy ≤ D. A set K is convex if for any x, y ∈ K, all the points on the line segment connecting x and y also belong to K, i.e., ∀α ∈ [0, 1], αx + (1 -α)y ∈ K. A function f : K → R is convex if for any x, y ∈ K ∀α ∈ [0, 1], f (αx + (1 -α)y) ≤ αf (x) + (1 -α)f (y). Gradients and subgradients. The set of all subgradients of a function f at x, denoted ∂f (x), is the set of all vectors u such that f (y) ≥ f (x) + u (y -x). It can be shown that the set of subgradients of a convex function is always non-empty. Suppose f is differentiable, let ∇f (x)[i] = ∂ ∂x i f (x) be the vector of partial derivatives according to the variables, called the gradient. If the gradient ∇f (x) exists, then ∇f (x) ∈ ∂f (x) and ∀y ∈ K f (y) ≥ f (x) + ∇f (x) (y -x). Henceforth we shall denote by ∇f (x) the gradient, if it exists, or any member of ∂f (x) otherwise. We denote by G > 0 an upper bound on the norm of the subgradients of f over K, i.e., ∇f (x) ≤ G for all x ∈ K. The existence of Such an upper bound implies that the function f is Lipschitz continuous with parameter G, that is, for all x, y ∈ K |f (x) -f (y)| ≤ G x -y . Smoothness and strong convexity. The optimization and machine learning literature studies special types of convex functions that admit useful properties, which in turn allow for more efficient optimization. Notably, we say that a function is α-strongly convex if f (y) ≥ f (x) + ∇f (x) (y -x) + α 2 y -x 2 . A function is β-smooth if f (y) ≤ f (x) + ∇f (x) (y -x) + β 2 y -x 2 . The latter condition is implied by a slightly stronger Lipschitz condition over the gradients, which is sometimes used to defined smoothness, i.e., ∇f (x) -∇f (y) ≤ β xy . If the function is twice differentiable and admits a second derivative, known as a Hessian for a function of several variables, the above conditions are equivalent to the following condition on the Hessian, denoted ∇ 2 f (x): Smoothness: -βI ∇ 2 f (x) βI Strong-convexity: αI ∇ 2 f (x), where A B if the matrix B -A is positive semidefinite. When the function f is both α-strongly convex and β-smooth, we say that it is γ-well-conditioned where γ is the ratio between strong convexity and smoothness, also called the condition number of f γ = α β ≤ 1 2.1. BASICS Projections onto convex sets In the following algorithms we shall make use of a projection operation onto a convex set, which is defined as the closest point inside the convex set to a given point. Formally, Π K (y) arg min x∈K x -y . When clear from the context, we shall remove the K subscript. It is left as an exercise to the reader to prove that the projection of a given point over a closed non-empty convex set exists and is unique. The computational complexity of projections is a subtle issue that depends much on the characterization of K itself. Most generally, K can be represented by a membership oracle-an efficient procedure that is capable of deciding whether a given x belongs to K or not. In this case, projections can be computed in polynomial time. In certain special cases, projections can be computed very efficiently in near-linear time. A crucial property of projections that we shall make extensive use of is the Pythagorean theorem, which we state here for completeness:  We note that there exists a more general version of the Pythagorean theorem. The above theorem and the definition of projections are true and valid not only for Euclidean norms, but for projections according to other distances that are not norms. In particular, an analogue of the Pythagorean theorem remains valid with respect to Bregman divergences. Introduction to optimality conditions The standard curriculum of high school mathematics contains the basic facts concerning when a function (usually in one dimension) attains a local optimum or saddle point. The KKT (Karush-Kuhn-Tucker) conditions generalize these facts to more than one dimension, and the reader is referred to the bibliographic material at the end of this chapter for an in-depth rigorous discussion of optimality conditions in general mathematical programming. For our purposes, we describe only briefly and intuitively the main facts that we will require henceforth. We separate the discussion into convex and non-convex programming. Optimality for convex optimization A local minimum of a convex function is also a global minimum (see exercises at the end of this chapter). We say that x is an ε-approximate optimum if the following holds: ∀x ∈ K . f (x ) ≤ f (x) + ε. The generalization of the fact that a minimum of a convex differentiable function on R is a point in which its derivative is equal to zero, is given by the multi-dimensional analogue that its gradient is zero: ∇f (x) = 0 ⇐⇒ x ∈ arg min x∈R n f (x). We will require a slightly more general, but equally intuitive, fact for constrained optimization: at a minimum point of a constrained convex function, the inner product between the negative gradient and direction towards the interior of K is non-positive. This is depicted in Figure 2 .2, which shows that -∇f (x ) defines a supporting hyperplane to K. The intuition is that if the inner product were positive, one could improve the objective by moving in the direction of the projected negative gradient. This fact is stated formally in the following theorem. Solution concepts for non-convex optimization We have seen in the previous chapter that mathematical optimization is NPhard. This implies that finding global solutions for non-convex optimization is NP-hard, even for smooth functions over very simple convex domains. We thus consider other trackable concepts of solutions. The most common solution concept is that of first-order optimality, a.k.a. saddle-points or stationary points. These are points that satisfy ∇f (x ) = 0. Unfortunately, even finding such stationary points is NP-hard. We thus settle for approximate stationary points, which satisify ∇f (x ) ≤ ε. A more stringent notion of optimality we may consider is obtained by looking at the second derivatives. We can require they behave as for global minimum, see figure 2.3. Formally, we say that a point x is a second-order local minimum if it satisfies the two conditions: ∇f (x ) ≤ ε , ∇ 2 f (x ) - √ εI. The differences in approximation criteria for first and second derivatives is natural, as we shall explore in non-convex approximation algorithms henceforth. We note that it is possible to further define optimality conditions for higher order derivatives, although this is less useful in the context of machine learning. Potentials for distance to optimality When analyzing convergence of gradient methods, it is useful to use potential functions in lieu of function distance to optimality, such as gradient norm and/or Euclidean distance to optimality. The following relationships hold between these quantities. Lemma 2.3. The following properties hold for α-strongly-convex functions and/or β-smooth functions over Euclidean space R d . 1. α 2 d 2 t ≤ h t 2. h t ≤ β 2 d 2 t 3. 1 2β ∇ t 2 ≤ h t 4. h t ≤ 1 2α ∇ t 2 Proof. 1. h t ≥ α 2 d 2 t : By strong convexity, we have h t = f (x t ) -f (x ) ≥ ∇f (x ) (x t -x ) + α 2 x t -x 2 = α 2 x t -x 2 where the last inequality follows since the gradient at the global optimum is zero. 2. h t ≤ β 2 d 2 t : By smoothness, h t = f (x t ) -f (x ) ≤ ∇f (x ) (x t -x ) + β 2 x t -x 2 = β 2 x t -x 2 where the last inequality follows since the gradient at the global optimum is zero. 3. h t ≥ 1 2β ∇ t 2 : Using smoothness, and let x t+1 = x t -η∇ t for η = 1 β , h t = f (x t ) -f (x ) ≥ f (x t ) -f (x t+1 ) ≥ ∇f (x t ) (x t -x t+1 ) -β 2 x t -x t+1 2 = η ∇ t 2 -β 2 η 2 ∇ t 2 = 1 2β ∇ t 2 . 4. h t ≤ 1 2α ∇ t 2 : We have for any pair x, y ∈ R d : f (y) ≥ f (x) + ∇f (x) (y -x) + α 2 x -y 2 ≥ min z∈R d f (x) + ∇f (x) (z -x) + α 2 x -z 2 = f (x) - 1 2α ∇f (x) 2 . by taking z = x - 1 α ∇f (x) In particular, taking x = x t , y = x , we get h t = f (x t ) -f (x ) ≤ 1 2α ∇ t 2 . (2.1) Gradient descent and the Polyak stepsize The simplest iterative optimization algorithm is gradient descent, as given in Algorithm 1. We analyze GD with the Polyak stepsize, which has the advantage of not depending on the strong convexity and/or smoothness parameters of the objective function. Algorithm 1 GD with the Polyak stepsize 1: Input: time horizon T , x 0 2: for t = 0, . . . , T -1 do 3: Set η t = ht ∇t 2 4: x t+1 = x t -η t ∇ t 5: end for 6: Return x = arg min xt {f (x t )} To prove convergence bounds, assume ∇ t ≤ G, and define: B T = min Gd 0 √ T , 2βd 2 0 T , 3G 2 αT , βd 2 0 1 -α 4β T Theorem 2.4. (GD with the Polyak Step Size) Algorithm 1 attains the following regret bound after T steps: h(x) = min 0≤t≤T {h t } ≤ B T Theorem 2.4 directly follows from the following lemma. Let 0 ≤ γ ≤ 1, define R T,γ as follows: R T,γ = min Gd 0 √ γT , 2βd 2 0 γT , 3G 2 γαT , βd 2 0 1 -γ α 4β T . Lemma 2.5. For 0 ≤ γ ≤ 1, suppose that a sequence x 0 , . . . x t satisfies: d 2 t+1 ≤ d 2 t -γ h 2 t ∇ t 2 (2.2) then for x as defined in the algorithm, we have: h(x) ≤ R T,γ . Proof. The proof analyzes different cases: 1. For convex functions with gradient bounded by G, d 2 t+1 -d 2 t ≤ - γh 2 t ∇t 2 ≤ - γh 2 t G 2 Summing up over T iterations, and using Cauchy-Schwartz, we have 1 T t h t ≤ 1 √ T t h 2 t ≤ G √ γT t (d 2 t -d 2 t+1 ) ≤ Gd 0 √ γT . 2. For smooth functions whose gradient is bounded by G, Lemma 2.3 implies: d 2 t+1 -d 2 t ≤ - γh 2 t ∇ t 2 ≤ - γh t 2β . This implies 1 T t h t ≤ 2βd 2 0 γT . 3. For strongly convex functions, Lemma 2.3 implies: d 2 t+1 -d 2 t ≤ -γ h 2 t ∇ t 2 ≤ -γ h 2 t G 2 ≤ -γ α 2 d 4 t 4G 2 . In other words, d 2 t+1 ≤ d 2 t (1 -γ α 2 d 2 t 4G 2 ) . Defining a t := γ α 2 d 2 t 4G 2 , we have: a t+1 ≤ a t (1 -a t ) . This implies that a t ≤ 1 t+1 , which can be seen by induction 1 . The proof is completed as follows 2 : 1 T /2 T t=T /2 h 2 t ≤ 2G 2 γT T t=T /2 (d 2 t -d 2 t+1 ) = 2G 2 γT (d 2 T /2 -d 2 T ) = 8G 4 γ 2 α 2 T (a T /2 -a T ) ≤ 9G 4 γ 2 α 2 T 2 . Thus, there exists a t for which h 2 t ≤ 9G 4 γ 2 α 2 T 2 . Taking the square root completes the claim. 4. For both strongly convex and smooth functions: d 2 t+1 -d 2 t ≤ -γ h 2 t ∇ t 2 ≤ - γh t 2β ≤ -γ α 4β d 2 t Thus, h T ≤ βd 2 T ≤ βd 2 0 1 -γ α 4β T . This completes the proof of all cases. 1 That a0 ≤ 1 follows from Lemma 2.3. For t = 1, a1 ≤ 1 2 since a1 ≤ a0(1 -a0) and 0 ≤ a0 ≤ 1. For the induction step, at ≤ at-1(1 -at-1) ≤ 1 t (1 -1 t ) = t-1 t 2 = 1 t+1 ( t 2 -1 t 2 ) ≤ 1 t+1 . 2 This assumes T is even. T odd leads to the same constants. Exercises 1. Write an explicit expression for the gradient and projection operation (if needed) for each of the example optimization problems in the first chapter. 2. Prove that a differentiable function f (x) : R → R is convex if and only if for any x, y ∈ R it holds that f (x) -f (y) ≤ (x -y)f (x). 3. Recall that we say that a function f : R n → R has a condition number γ = α/β over K ⊆ R d if the following two inequalities hold for all x, y ∈ K: (a) f (y) ≥ f (x) + (y -x) ∇f (x) + α 2 x -y 2 (b) f (y) ≤ f (x) + (y -x) ∇f (x) + β 2 x -y 2 For matrices A, B ∈ R n×n we denote A B if A -B is positive semidefinite. Prove that if f is twice differentiable and it holds that βI ∇ 2 f (x) αI for any x ∈ K, then the condition number of f over K is α/β. Prove: (a) The sum of convex functions is convex. (b) Let f be α 1 -strongly convex and g be α 2 -strongly convex. Then f + g is (α 1 + α 2 )-strongly convex. (c) Let f be β 1 -smooth and g be β 2 -smooth. Then f + g is (β 1 + β 2 )smooth. 5. Let K ⊆ R d be closed, compact, non-empty and bounded. Prove that a necessary and sufficient condition for ΠK(x) to be a singleton, that is for | ΠK(x)| = 1, is for K to be convex. 6. Prove that for convex functions, ∇f (x) ∈ ∂f (x), that is, the gradient belongs to the subgradient set. 7. Let f (x) : R n → R be a convex differentiable function and K ⊆ R n be a convex set. Prove that x ∈ K is a minimizer of f over K if and only if for any y ∈ K it holds that (y -x ) ∇f (x ) ≥ 0. 8. Consider the n-dimensional simplex ∆ n = {x ∈ R n | n i=1 x i = 1, x i ≥ 0 , ∀i ∈ [n]}. Give an algorithm for computing the projection of a point x ∈ R n onto the set ∆ n (a near-linear time algorithm exists). Bibliographic remarks The reader is referred to dedicated books on convex optimization for much more in-depth treatment of the topics surveyed in this background chapter. For background in convex analysis see the texts [11, 68] . The classic textbook [12] gives a broad introduction to convex optimization with numerous applications. For an adaptive analysis of gradient descent with the Polyak stepsize see [33] . Chapter 3 Stochastic Gradient Descent The most important optimization algorithm in the context of machine learning is stochastic gradient descent (SGD), especially for non-convex optimization and in the context of deep neural networks. In this chapter we spell out the algorithm and analyze it up to tight finite-time convergence rates. Training feedforward neural networks Perhaps the most common optimization problem in machine learning is that of training feedforward neural networks. In this problem, we are given a set of labelled data points, such as labelled images or text. Let {x i , y i } be the set of labelled data points, also called the training data. The goal is to fit the weights of an artificial neural network in order to minimize the loss over the data. Mathematically, the feedforward network is a given weighted a-cyclic graph G = (V, E, W ). Each node v is assigned an activation function, which we assume is the same function for all nodes, denoted σ : R d → R. Using a biological analogy, an activation function σ is a function that determines how strongly a neuron (i.e. a node) 'fires' for a given input by mapping the result into the desired range, usually [0, 1] or [-1, 1] . Some popular examples include: • Sigmoid: σ(x) = 1 1+e -x • Hyperbolic tangent: tanh(x) = e x -e -x e x +e -x • Rectified linear unit: ReLU (x) = max{0, x} (currently the most widely used of the three) CHAPTER 3. STOCHASTIC GRADIENT DESCENT The inputs to the input layer nodes is a given data point, while the inputs to to all other nodes are the output of the nodes connected to it. We denote by ρ(v) the set of input neighbors to node v. The top node output is the input to the loss function, which takes its \"prediction\" and the true label to form a loss. For an input node v, its output as a function of the graph weights and input example x (of dimension d), which we denote as v(W, x) = σ i∈d W v,i x i The output of an internal node v is a function of its inputs u ∈ ρ(v) and a given example x, which we denote as v(W, x) = σ   u∈ρ(v) W uv u(W, x)   If we denote the top node as v 1 , then the loss of the network over data point (x i , y i ) is given by ℓ(v 1 (W, x i ), y i ). The objective function becomes f (W ) = E x i ,y i ℓ(v 1 (W, x i ), y i ) For most commonly-used activation and loss functions, the above function is non-convex. However, it admits important computational properties. The most significant property is given in the following lemma. The proof of this lemma is left as an exercise, but we sketch the main ideas. For every variable W uv , we have by linearity of expectation that ∂ ∂W uv f (W ) = E x i ,y i ∂ ∂W uv ℓ(v 1 (W, x i ), y i ) . Next, using the chain rule, we claim that it suffices to know the partial derivatives of each node w.r.t. its immediate daughters. To see this, let us write the derivative w.r.t. W uv using the chain rule: ∂ ∂W uv ℓ(v 1 (W, x i ), y i ) = ∂ℓ ∂v 1 • ∂v 1 ∂W uv = ∂ℓ ∂v 1 • v 2 ∈ρ(v 1 ) ∂v 1 ∂v 2 • ∂v j ∂W uv = ... = ∂ℓ ∂v 1 • v 2 ∈ρ(v 1 ) ∂v 1 ∂v 2 • ... • v k j ∈ρ(v k-1 ) • ∂v k ∂W uv We conclude that we only need to obtain the E partial derivatives along the edges in order to compute all partial derivatives of the function. The actual product at each node can be computed by a dynamic program in linear time. Gradient descent for smooth optimization Before moving to stochastic gradient descent, we consider its deterministic counterpart: gradient descent, in the context of smooth non-convex optimization. Our notion of solution is a point with small gradient, i.e. ∇f (x) ≤ ε. As we prove below, this requires O( 1 ε 2 ) iterations, each requiring one gradient computation. Recall that gradients can be computed efficiently, linear in the number of edges, in feed forward neural networks. Thus, the time to obtain a ε-approximate solution becomes O( |E|m ε 2 ) for neural networks with E edges and over m examples. Algorithm 2 Gradient descent 1: Input: f , T , initial point x 1 ∈ K, sequence of step sizes {η t } 2: for t = 1 to T do 3: Let y t+1 = x t -η t ∇f (x t ), x t+1 = ΠK (y t+1 ) 4: end for 5: return x T +1 Although the choice of η t can make a difference in practice, in theory the convergence of the vanilla GD algorithm is well understood and given in the following theorem. Below we assume that the function is bounded such that |f (x)| ≤ M . Theorem 3.2. For unconstrained minimization of β-smooth functions and η t = 1 β , GD Algorithm 2 converges as 1 T t ∇ t 2 ≤ 4M β T . Proof. Denote by ∇ t the shorthand for ∇f (x t ), and h t = f (x t ) -f (x * ). The Descent Lemma is given in the following simple equation, h t+1 -h t = f (x t+1 ) -f (x t ) ≤ ∇ t (x t+1 -x t ) + β 2 x t+1 -x t 2 β-smoothness = -η t ∇ t 2 + β 2 η 2 t ∇ t 2 algorithm defn. = - 1 2β ∇ t 2 choice of η t = 1 β Thus, summing up over T iterations, we have 1 2β T t=1 ∇ t 2 ≤ t (h t -h t+1 ) = h 1 -h T +1 ≤ 2M For convex functions, the above theorem implies convergence in function value due to the following lemma, Lemma 3.3. A convex function satisfies h t ≤ D ∇ t , and an α-strongly convex function satisfies h t ≤ 1 2α ∇ t 2 . Proof. The gradient upper bound for convex functions gives h t ≤ ∇ t (x * -x t ) ≤ D ∇ t The strongly convex case appears in Lemma 2.3. Stochastic gradient descent In the context of training feed forward neural networks, the key idea of Stochastic Gradient Descent is to modify the updates to be: W t+1 = W t -η ∇ t (3.1) where ∇ t is a random variable with E[ ∇ t ] = ∇ f (W t ) and bounded second moment E[ ∇ t 2 2 ] ≤ σ 2 . Luckily, getting the desired ∇ t random variable is easy in the posed problem since the objective function is already in expectation form so: ∇f(W ) = ∇ E x i ,y i [ℓ(v 1 (W, x i ), y i )] = E x i ,y i [∇ℓ(v 1 (W, x i ), y i )]. Therefore, at iteration t we can take ∇ t = ∇ℓ(v 1 (W, x i ), y i ) where i ∈ {1, ..., m} is picked uniformly at random. Based on the observation above, choosing ∇ t this way preserves the desired expectation. So, for each iteration we only compute the gradient w.r.t. to one random example instead of the entire dataset, thereby drastically improving performance for every step. It remains to analyze how this impacts convergence. Algorithm 3 Stochastic gradient descent 1: Input: f , T , initial point x 1 ∈ K, sequence of step sizes {η t } 2: for t = 1 to T do 3: Let y t+1 = x t -η t ∇f (x t ), x t+1 = ΠK (y t+1 ) 4: end for 5: return x T +1 Theorem 3.4. For unconstrained minimization of β-smooth functions and η t = η = M βσ 2 T , SGD Algorithm 3 converges as E 1 T t ∇ t 2 ≤ 2 M βσ 2 T . Proof. Denote by ∇ t the shorthand for ∇f (x t ), and h t = f (x t ) -f (x * ). The stochastic descent lemma is given in the following equation, E[h t+1 -h t ] = E[f (x t+1 ) -f (x t )] ≤ E[∇ t (x t+1 -x t ) + β 2 x t+1 -x t 2 ] β-smoothness = -E[η∇ t ∇t ] + β 2 η 2 E ∇t 2 algorithm defn. = -η ∇ t 2 + β 2 η 2 σ 2 variance bound. Thus, summing up over T iterations, we have for η = M βσ 2 T , E 1 T T t=1 ∇ t 2 ≤ 1 T η t E [h t -h t+1 ] + η β 2 σ 2 ≤ M T η + η β 2 σ 2 = M βσ 2 T + 1 2 M βσ 2 T ≤ 2 M βσ 2 T . We thus conclude that O( 1 ε 4 ) iterations are needed to find a point with ∇f (x) ≤ ε, as opposed to O( 1 ε 2 ). However, each iteration takes O(|E|) time, instead of O(|E|m) time for gradient descent. This is why SGD is one of the most useful algorithms in machine learning. Bibliographic remarks For in depth treatment of backpropagation and the role of deep neural networks in machine learning the reader is referred to [25] . For detailed rigorous convergence proofs of first order methods, see lecture notes by Nesterov [57] and Nemirovskii [53, 54] , as well as the recent text [13] . Chapter 4 Generalization and Non-Smooth Optimization In previous chapter we have introduced the framework of mathematical optimization within the context of machine learning. We have described the mathematical formulation of several machine learning problems, notably training neural networks, as optimization problems. We then described as well as analyzed the most useful optimization method to solve such formulations: stochastic gradient descent. However, several important questions arise: 1. SGD was analyzed for smooth functions. Can we minimize non-smooth objectives? In this chapter we address the first two, and devote the rest of this manuscript/course to the last question. How many examples are needed to learn a certain concept? This is a fundamental question of statistical/computational learning theory that has been studied for decades (see end of chapter for bibliographic references). The classical setting of learning from examples is statistical. It assumes examples are drawn i.i.d from a fixed, arbitrary and unknown distribution. The mathematical optimization formulations that we have derived for the ERM problem assume that we have sufficiently many examples, such that optimizing a certain predictor/neural-network/machine on them will result in a solution that is capable of generalizing to unseen examples. The number of examples needed to generalize is called the sample complexity of the problem, and it depends on the concept we are learning as well as the hypothesis class over which we are trying to optimize. There are dimensionality notions in the literature, notably the VCdimension and related notions, that give precise bounds on the sample complexity for various hypothesis classes. In this text we take an algorithmic approach, which is also deterministic. Instead of studying sample complexity, which is non-algorithmic, we study algorithms for regret minimization. We will show that they imply generalization for a broad class of machines. A note on non-smooth optimization Minimization of a function that is both non-convex and non-smooth is in general hopeless, from an information theoretic perspective. The following image explains why. The depicted function on the interval [0, 1] has a single local/global minimum, and if the crevasse is narrow enough, it cannot be found by any method other than extensive brute-force search, which can take arbitrarily long. Since non-convex and non-smooth optimization is hopeless, in the context of non-smooth functions we only consider convex optimization. Minimizing Regret The setting we consider for the rest of this chapter is that of online (convex) optimization. In this setting a learner iteratively predicts a point x t ∈ K in a convex set K ⊆ R d , and then receives a cost according to an adversarially chosen convex function f t ∈ F from family F. The goal of the algorithms introduced in this chapter is to minimize worst-case regret, or difference between total cost and that of best point in hindsight: regret = sup f 1 ,...,f T ∈F T t=1 f t (x t ) -min x∈K T t=1 f t (x) . In order to compare regret to optimization error it is useful to consider the average regret, or regret/T . Let xT = 1 T T t=1 x t be the average decision. If the functions f t are all equal to a single function f : K → R, then Jensen's inequality implies that f (x T ) converges to f (x ) if the average regret is vanishing, since f (x T ) -f (x ) ≤ 1 T T t=1 [f (x t ) -f (x )] = regret T Regret implies generalization Statistical learning theory for learning from examples postulates that examples from a certain concept are sampled i.i.d. from a fixed and unknown distribution. The learners' goal is to choose a hypothesis from a certain hypothesis class that can generalize to unseen examples. More formally, let D be a distribution over labelled examples {a i ∈ R d , b i ∈ R} ∼ D. Let H = {x} , x : R d → R be a hypothsis class over which we are trying to learn (such as linear separators, deep neural networks, etc.). The generalization error of a hypothesis is the expected error of a hypothesis over randomly chosen examples according to a given loss function ℓ : R × R → R, which is applied to the prediction of the hypothesis and the true label, ℓ(x(a i ), b i ). Thus, error(x) = E a i ,b i ∼D [ℓ(x(a i ), b i )]. An algorithm that attains sublinear regret over the hypothesis class H, w.r.t. loss functions given by f t (x) = f a,b (x) = ℓ(x(a), b), gives rise to a generalizing hypothesis as follows. Lemma 4.1. Let x = x t for t ∈ [T ] be chose uniformly at random from {x 1 , ..., x T }.Then, with expectation taken over random choice of x as well as choices of f t ∼ D, E[error(x)] ≤ E[error(x * )] + regret T Proof. By random choice of x, we have E[f (x)] = E 1 T t f (x t ) Using the fact that f t ∼ D, we have E[error(x)] = E f ∼D [f (x)] = E ft [ 1 T t f t (x t )] ≤ E ft [ 1 T t f t (x )] + regret T = E f [f (x )] + regret T = E f [error(x )] + regret T Online gradient descent Perhaps the simplest algorithm that applies to the most general setting of online convex optimization is online gradient descent. This algorithm is an online version of standard gradient descent for offline optimization we have seen in the previous chapter. Pseudo-code for the algorithm is given in Algorithm 4, and a conceptual illustration is given in Figure 4 .2. In each iteration, the algorithm takes a step from the previous point in the direction of the gradient of the previous cost. This step may result in a point outside of the underlying convex set. In such cases, the algorithm projects the point back to the convex set, i.e. finds its closest point in the convex set. Despite the fact that the next cost function may be completely different than the costs observed thus far, the regret attained by the algorithm is sublinear. This is formalized in the following theorem (recall the definition of G and D from the previous chapter).  Play x t and observe cost f t (x t ). regret T = T t=1 f t (x t ) -min x ∈K T t=1 f t (x ) ≤ 3GD √ T 4: Update and project: y t+1 = x t -η t ∇f t (x t ) x t+1 = Π K (y t+1 ) 5: end for Proof. Let x ∈ arg min x∈K T t=1 f t (x). Define ∇ t ∇f t (x t ). By convexity f t (x t ) -f t (x ) ≤ ∇ t (x t -x ) (4.1) We first upper-bound ∇ t (x t -x ) using the update rule for x t+1 and Theorem 2.1 (the Pythagorean theorem): x t+1 -x 2 = Π K (x t -η t ∇ t ) -x 2 ≤ x t -η t ∇ t -x 2 (4.2) Hence, x t+1 -x 2 ≤ x t -x 2 + η 2 t ∇ t 2 -2η t ∇ t (x t -x ) 2∇ t (x t -x ) ≤ x t -x 2 -x t+1 -x 2 η t + η t G 2 (4.3) Summing (4.1) and ( 4 .3) from t = 1 to T , and setting η t = D G √ t (with 1 η 0 0): 2 T t=1 f t (x t ) -f t (x ) ≤ 2 T t=1 ∇ t (x t -x ) ≤ T t=1 x t -x 2 -x t+1 -x 2 η t + G 2 T t=1 η t ≤ T t=1 x t -x 2 1 η t - 1 η t-1 + G 2 T t=1 η t 1 η 0 0, x T +1 -x * 2 ≥ 0 ≤ D 2 T t=1 1 η t - 1 η t-1 + G 2 T t=1 η t ≤ D 2 1 η T + G 2 T t=1 η t telescoping series ≤ 3DG √ T . The last inequality follows since η t = D G √ t and T t=1 1 √ t ≤ 2 √ T . The online gradient descent algorithm is straightforward to implement, and updates take linear time given the gradient. However, there is a projection step which may take significantly longer. Lower bounds Theorem 4.3. Any algorithm for online convex optimization incurs Ω(DG √ T ) regret in the worst case. This is true even if the cost functions are generated from a fixed stationary distribution. We give a sketch of the proof; filling in all details is left as an exercise at the end of this chapter. Consider an instance of OCO where the convex set K is the n-dimensional hypercube, i.e. K = {x ∈ R n , x ∞ ≤ 1}. There are 2 n linear cost functions, one for each vertex v ∈ {±1} n , defined as ∀v ∈ {±1} n , f v (x) = v x. Notice that both the diameter of K and the bound on the norm of the cost function gradients, denoted G, are bounded by D ≤ n i=1 2 2 = 2 √ n, G = n i=1 (±1) 2 = √ n The cost functions in each iteration are chosen at random, with uniform probability, from the set {f v , v ∈ {±1} n }. Denote by v t ∈ {±1} n the vertex chosen in iteration t, and denote f t = f vt . By uniformity and independence, for any t and x t chosen online, E vt [f t (x t )] = E vt [v t x t ] = 0. However, E v 1 ,...,v T min x∈K T t=1 f t (x) = E   min x∈K i∈[n] T t=1 v t (i) • x i   = n E - T t=1 v t (1) i.i.d. coordinates = -Ω(n √ T ). The last equality is left as exercise 3. The facts above nearly complete the proof of Theorem 4.3; see the exercises at the end of this chapter. Online gradient descent for strongly convex functions The first algorithm that achieves regret logarithmic in the number of iterations is a twist on the online gradient descent algorithm, changing only the step size. The following theorem establishes logarithmic bounds on the regret if the cost functions are strongly convex. Theorem 4.4. For α-strongly convex loss functions, online gradient descent with step sizes η t = 1 αt achieves the following guarantee for all T ≥ 1 regret T ≤ T t=1 1 αt ∇ t 2 ≤ G 2 2α (1 + log T ). Proof. Let x ∈ arg min x∈K T t=1 f t (x). Recall the definition of regret regret T = T t=1 f t (x t ) - T t=1 f t (x ). Define ∇ t ∇f t (x t ). Applying the definition of α-strong convexity to the pair of points x t ,x * , we have 2(f t (x t ) -f t (x )) ≤ 2∇ t (x t -x ) -α x -x t 2 . (4.4) We proceed to upper-bound ∇ t (x t -x ). Using the update rule for x t+1 and the Pythagorean theorem 2.1, we get x t+1 -x 2 = Π K (x t -η t ∇ t ) -x 2 ≤ x t -η t ∇ t -x 2 . Hence, x t+1 -x 2 ≤ x t -x 2 + η 2 t ∇ t 2 -2η t ∇ t (x t -x ) and 2∇ t (x t -x ) ≤ x t -x 2 -x t+1 -x 2 η t + η t ∇ t 2 . (4.5) Summing (4.5) from t = 1 to T , setting η t = 1 αt (define 1 η 0 0), and combining with (4.4), we have: 2 T t=1 (f t (x t ) -f t (x )) ≤ T t=1 x t -x 2 1 η t - 1 η t-1 -α + T t=1 η t ∇ t 2 since 1 η 0 0, x T +1 -x * 2 ≥ 0 = 0 + T t=1 1 αt ∇ t 2 ≤ G 2 α (1 + log T ) Online Gradient Descent implies SGD In this section we notice that OGD and its regret bounds imply the SGD bounds we have studied in the previous chapter. The main advantage are the guarantees for non-smooth stochastic optimization, and constrained optimization. Recall that in stochastic optimization, the optimizer attempts to minimize a convex function over a convex domain as given by the mathematical program: min x∈K f (x). However, unlike standard offline optimization, the optimizer is given access to a noisy gradient oracle, defined by O(x) ∇x s.t. E[ ∇x ] = ∇f (x) , E[ ∇x 2 ] ≤ G 2 That is, given a point in the decision set, a noisy gradient oracle returns a random vector whose expectation is the gradient at the point and whose second moment is bounded by G 2 . We will show that regret bounds for OCO translate to convergence rates for stochastic optimization. As a special case, consider the online gradient descent algorithm whose regret is bounded by regret T = O(DG √ T ) Applying the OGD algorithm over a sequence of linear functions that are defined by the noisy gradient oracle at consecutive points, and finally returning the average of all points along the way, we obtain the stochastic gradient descent algorithm, presented in Algorithm 5. Algorithm 5 stochastic gradient descent 1: Input: f , K, T , x 1 ∈ K, step sizes {η t } 2: for t = 1 to T do 3: Let ∇t = O(x t ) and define: f t (x) ∇t , x 4: Update and project: y t+1 = x t -η t ∇t x t+1 = Π K (y t+1 ) 5: end for 6: return xT 1 T T t=1 x t Theorem 4.5. Algorithm 5 with step sizes η t = D G √ t guarantees E[f (x T )] ≤ min x ∈K f (x ) + 3GD √ T Proof. By the regret guarantee of OGD, we have E[f (x T )] -f (x ) ≤ E[ 1 T t f (x t )] -f (x ) convexity of f (Jensen) ≤ 1 T E[ t ∇f (x t ), x t -x ] convexity again = 1 T E[ t ∇t , x t -x ] noisy gradient estimator = 1 T E[ t f t (x t ) -f t (x )] Algorithm 5, line (3) ≤ regret T T definition ≤ 3GD √ T theorem 4.2 It is important to note that in the proof above, we have used the fact that the regret bounds of online gradient descent hold against an adaptive adversary. This need arises since the cost functions f t defined in Algorithm 5 depend on the choice of decision x t ∈ K. In addition, the careful reader may notice that by plugging in different step sizes (also called learning rates) and applying SGD to strongly convex functions, one can attain Õ(1/T ) convergence rates. Details of this derivation are left as exercise 1. Exercises 1. Prove that SGD for a strongly convex function can, with appropriate parameters η t , converge as Õ( 1 T ). You may assume that the gradient estimators have Euclidean norms bounded by the constant G. Design an OCO algorithm that attains the same asymptotic regret bound as OGD, up to factors logarithmic in G and D, without knowing the parameters G and D ahead of time. 3. In this exercise we prove a tight lower bound on the regret of any algorithm for online convex optimization. (a) For any sequence of T fair coin tosses, let N h be the number of head outcomes and N t be the number of tails. Give an asymptotically tight upper and lower bound on E[|N h -N t |] (i.e. , order of growth of this random variable as a function of T , up to multiplicative and additive constants). (b) Consider a 2-expert problem, in which the losses are inversely correlated: either expert one incurs a loss of one and the second expert zero, or vice versa. Use the fact above to design a setting in which any experts algorithm incurs regret asymptotically matching the upper bound. (c) Consider the general OCO setting over a convex set K. Design a setting in which the cost functions have gradients whose norm is bounded by G, and obtain a lower bound on the regret as a function of G, the diameter of K, and the number of game iterations. Bibliographic remarks The OCO framework was introduced by Zinkevich in [87] , where the OGD algorithm was introduced and analyzed. Precursors to this algorithm, albeit for less general settings, were introduced and analyzed in [47] . Logarithmic regret algorithms for Online Convex Optimization were introduced and analyzed in [32] . For more detailed exposition on this prediction framework and its applications see [31] . The SGD algorithm dates back to Robbins and Monro [67] . Application of SGD to soft-margin SVM training was explored in [74] . Tight convergence rates of SGD for strongly convex and non-smooth functions were only recently obtained in [35] , [62] , [76] . Chapter 5 Regularization In this chapter we consider a generalization of the gradient descent called by different names in different communities (such as mirrored-descent, or regularized-follow-the-leader). The common theme of this generalization is called Regularization, a concept that is founded in generalization theory. Since this course focuses on optimization rather than generalization, we shall refer the reader to the generalization aspect of regularization, and focus hereby on optimization algorithms. We start by motivating this general family of methods using the fundamental problem of decision theory. Motivation: prediction from expert advice Consider the following fundamental iterative decision making problem: At each time step t = 1, 2, . . . , T , the decision maker faces a choice between two actions A or B (i.e., buy or sell a certain stock). The decision maker has assistance in the form of N \"experts\" that offer their advice. After a choice between the two actions has been made, the decision maker receives feedback in the form of a loss associated with each decision. For simplicity one of the actions receives a loss of zero (i.e., the \"correct\" decision) and the other a loss of one. We make the following elementary observations: 1. A decision maker that chooses an action uniformly at random each iteration, trivially attains a loss of T 2 and is \"correct\" 50% of the time. 2. In terms of the number of mistakes, no algorithm can do better in the worst case! In a later exercise, we will devise a randomized setting in which the expected number of mistakes of any algorithm is at least T 2 . We are thus motivated to consider a relative performance metric: can the decision maker make as few mistakes as the best expert in hindsight? The next theorem shows that the answer in the worst case is negative for a deterministic decision maker. Theorem 5.1. Let L ≤ T 2 denote the number of mistakes made by the best expert in hindsight. Then there does not exist a deterministic algorithm that can guarantee less than 2L mistakes. Proof. Assume that there are only two experts and one always chooses option A while the other always chooses option B. Consider the setting in which an adversary always chooses the opposite of our prediction (she can do so, since our algorithm is deterministic). Then, the total number of mistakes the algorithm makes is T . However, the best expert makes no more than T  2 mistakes (at every iteration exactly one of the two experts is mistaken). Therefore, there is no algorithm that can always guarantee less than 2L mistakes. This observation motivates the design of random decision making algorithms, and indeed, the OCO framework gracefully models decisions on a continuous probability space. Henceforth we prove Lemmas 5.3 and 5.4 that show the following: Theorem 5.2. Let ε ∈ (0, 1  2 ). Suppose the best expert makes L mistakes. Then: 1. There is an efficient deterministic algorithm that can guarantee less than 2(1 + ε)L + 2 log N ε mistakes; 2. There is an efficient randomized algorithm for which the expected number of mistakes is at most (1 + ε)L + log N ε . The weighted majority algorithm The weighted majority (WM) algorithm is intuitive to describe: each expert i is assigned a weight W t (i) at every iteration t. Initially, we set W 1 (i) = 1 for all experts i ∈ [N ]. For all t ∈ [T ] let S t (A), S t (B) ⊆ [N ] be the set of experts that choose A (and respectively B) at time t. Define, W t (A) = i∈St(A) W t (i) W t (B) = i∈St(B) W t (i) and predict according to a t = A if W t (A) ≥ W t (B) B otherwise. Next, update the weights W t (i) as follows: W t+1 (i) = W t (i) if expert i was correct W t (i)(1 -ε) if expert i was wrong , where ε is a parameter of the algorithm that will affect its performance. This concludes the description of the WM algorithm. We proceed to bound the number of mistakes it makes. Lemma 5.3. Denote by M t the number of mistakes the algorithm makes until time t, and by M t (i) the number of mistakes made by expert i until time t. Then, for any expert i ∈ [N ] we have M T ≤ 2(1 + ε)M T (i) + 2 log N ε . We can optimize ε to minimize the above bound. The expression on the right hand side is of the form f (x) = ax + b/x, that reaches its minimum at x = b/a. Therefore the bound is minimized at ε = log N/M T (i). Using this optimal value of ε, we get that for the best expert i M T ≤ 2M T (i ) + O M T (i ) log N . Of course, this value of ε cannot be used in advance since we do not know which expert is the best one ahead of time (and therefore we do not know the value of M T (i )). However, we shall see later on that the same asymptotic bound can be obtained even without this prior knowledge. Let us now prove Lemma 5.3. Proof. Let Φ t = N i=1 W t (i) for all t ∈ [T ], and note that Φ 1 = N . Notice that Φ t+1 ≤ Φ t . However, on iterations in which the WM algorithm erred, we have Φ t+1 ≤ Φ t (1 - ε 2 ), the reason being that experts with at least half of total weight were wrong (else WM would not have erred), and therefore Φ t+1 ≤ 1 2 Φ t (1 -ε) + 1 2 Φ t = Φ t (1 - ε 2 ). From both observations, Φ t ≤ Φ 1 (1 - ε 2 ) Mt = N (1 - ε 2 ) Mt . On the other hand, by definition we have for any expert i that W T (i) = (1 -ε) M T (i) . Since the value of W T (i) is always less than the sum of all weights Φ T , we conclude that (1 -ε) M T (i) = W T (i) ≤ Φ T ≤ N (1 - ε 2 ) M T . Taking the logarithm of both sides we get M T (i) log(1 -ε) ≤ log N + M T log (1 - ε 2 ). Next, we use the approximations -x -x 2 ≤ log (1 -x) ≤ -x 0 < x < 1 2 , which follow from the Taylor series of the logarithm function, to obtain that -M T (i)(ε + ε 2 ) ≤ log N -M T ε 2 , and the lemma follows. Randomized weighted majority In the randomized version of the WM algorithm, denoted RWM, we choose expert i w.p. p t (i) = W t (i)/ N j=1 W t (j) at time t. Lemma 5.4. Let M t denote the number of mistakes made by RWM until iteration t. Then, for any expert i ∈ [N ] we have E[M T ] ≤ (1 + ε)M T (i) + log N ε . The proof of this lemma is very similar to the previous one, where the factor of two is saved by the use of randomness: Proof. As before, let Φ t = N i=1 W t (i) for all t ∈ [T ], and note that Φ 1 = N . Let mt = M t -M t-1 be the indicator variable that equals one if the RWM algorithm makes a mistake on iteration t. Let m t (i) equal one if the i'th expert makes a mistake on iteration t and zero otherwise. Inspecting the sum of the weights: Φ t+1 = i W t (i)(1 -εm t (i)) = Φ t (1 -ε i p t (i)m t (i)) p t (i) = Wt(i) j Wt(j) = Φ t (1 -ε E[ mt ]) ≤ Φ t e -ε E[ mt] . 1 + x ≤ e x On the other hand, by definition we have for any expert i that W T (i) = (1 -ε) M T (i) Since the value of W T (i) is always less than the sum of all weights Φ T , we conclude that (1 -ε) M T (i) = W T (i) ≤ Φ T ≤ N e -ε E[M T ] . Taking the logarithm of both sides we get M T (i) log(1 -ε) ≤ log N -ε E[M T ] Next, we use the approximation -x -x 2 ≤ log (1 -x) ≤ -x , 0 < x < 1 2 to obtain -M T (i)(ε + ε 2 ) ≤ log N -ε E[M T ], and the lemma follows. Hedge The RWM algorithm is in fact more general: instead of considering a discrete number of mistakes, we can consider measuring the performance of an expert by a non-negative real number ℓ t (i), which we refer to as the loss of the expert i at iteration t. The randomized weighted majority algorithm guarantees that a decision maker following its advice will incur an average expected loss approaching that of the best expert in hindsight. Historically, this was observed by a different and closely related algorithm called Hedge. Algorithm 6 Hedge 1: Initialize: ∀i ∈ [N ], W 1 (i) = 1 2: for t = 1 to T do 3: Pick i t ∼ R W t , i.e., i t = i with probability x t (i) = Wt(i) j Wt(j) 4: Incur loss ℓ t (i t ). 5: Update weights W t+1 (i) = W t (i)e -εℓt(i) 6: end for Henceforth, denote in vector notation the expected loss of the algorithm by E[ℓ t (i t )] = N i=1 x t (i)ℓ t (i) = x t ℓ t Theorem 5.5. Let ℓ 2 t denote the N -dimensional vector of square losses, i.e., ℓ 2 t (i) = ℓ t (i) 2 , let ε > 0, and assume all losses to be non-negative. The Hedge algorithm satisfies for any expert i ∈ [N ]: T t=1 x t ℓ t ≤ T t=1 ℓ t (i ) + ε T t=1 x t ℓ 2 t + log N ε Proof. As before, let Φ t = N i=1 W t (i) for all t ∈ [T ], and note that Φ 1 = N . Inspecting the sum of weights: Φ t+1 = i W t (i)e -εℓt(i) = Φ t i x t (i)e -εℓt(i) x t (i) = Wt(i) j Wt(j) ≤ Φ t i x t (i)(1 -εℓ t (i) + ε 2 ℓ t (i) 2 )) for x ≥ 0, e -x ≤ 1 -x + x 2 = Φ t (1 -εx t ℓ t + ε 2 x t ℓ 2 t ) ≤ Φ t e -εx t ℓt+ε 2 x t ℓ 2 t . 1 + x ≤ e x On the other hand, by definition, for expert i we have that W T (i ) = e -ε T t=1 ℓt(i ) Since the value of W T (i ) is always less than the sum of all weights Φ t , we conclude that W T (i ) ≤ Φ T ≤ N e -ε t x t ℓt+ε 2 t x t ℓ 2 t . Taking the logarithm of both sides we get -ε T t=1 ℓ t (i ) ≤ log N -ε T t=1 x t ℓ t + ε 2 T t=1 x t ℓ 2 t and the theorem follows by simplifying. The Regularization framework In the previous section we studied the multiplicative weights update method for decision making. A natural question is: couldn't we have used online gradient descent for the same exact purpose? Indeed, the setting of prediction from expert advice naturally follows into the framework of online convex optimization. To see this, consider the loss functions given by f t (x) = ℓ t x = E i∼x [ℓ t (i)], which capture the expected loss of choosing an expert from distribution x ∈ ∆ n as a linear function. The regret guarantees we have studied for OGD imply a regret of O(GD √ T ) = O( √ nT ). Here we have used the fact that the Eucliean diameter of the simplex is two, and that the losses are bounded by one, hence the Euclidean norm of the gradient vector ℓ t is bounded by √ n. In contrast, the Hedge algorithm attains regret of O( √ T log n) for the same problem. How can we explain this discrepancy?! The RFTL algorithm Both OGD and Hedge are, in fact, instantiations of a more general metaalgorithm called RFTL (Regularized-Follow-The-Leader). In an OCO setting of regret minimization, the most straightforward approach for the online player is to use at any time the optimal decision (i.e., point in the convex set) in hindsight. Formally, let x t+1 = arg min x∈K t τ =1 f τ (x). This flavor of strategy is known as \"fictitious play\" in economics, and has been named \"Follow the Leader\" (FTL) in machine learning. It is not hard to see that this simple strategy fails miserably in a worst-case sense. That is, this strategy's regret can be linear in the number of iterations, as the following example shows: Consider K = [-1, 1], let f 1 (x) = 1 2 x, and let f τ for τ = 2, . . . , T alternate between -x or x. Thus, t τ =1 f τ (x) =    1 2 x, t is odd -1 2 x, otherwise The FTL strategy will keep shifting between x t = -1 and x t = 1, always making the wrong choice. The intuitive FTL strategy fails in the example above because it is unstable. Can we modify the FTL strategy such that it won't change decisions often, thereby causing it to attain low regret? This question motivates the need for a general means of stabilizing the FTL method. Such a means is referred to as \"regularization\". Algorithm 7 Regularized Follow The Leader 1: Input: η > 0, regularization function R, and a convex compact set K. Predict x t . 5: Observe the payoff function f t and let ∇ t = ∇f t (x t ). 6: Update x t+1 = arg min x∈K η t s=1 ∇ s x + R(x) 7: end for The generic RFTL meta-algorithm is defined in Algorithm 7. The regularization function R is assumed to be strongly convex, smooth, and twice differentiable. Mirrored Descent An alternative view of this algorithm is in terms of iterative updates, which can be spelled out using the above definition directly. The resulting algorithm is called \"Mirrored Descent\". OMD is an iterative algorithm that computes the current decision using a simple gradient update rule and the previous decision, much like OGD. The generality of the method stems from the update being carried out in a \"dual\" space, where the duality notion is defined by the choice of regularization: the gradient of the regularization function defines a mapping from R n onto itself, which is a vector field. The gradient updates are then carried out in this vector field. For the RFTL algorithm the intuition was straightforward-the regularization was used to ensure stability of the decision. For OMD, regularization has an additional purpose: regularization transforms the space in which gradient updates are performed. This transformation enables better bounds in terms of the geometry of the space. The OMD algorithm comes in two flavors: an agile and a lazy version. The lazy version keeps track of a point in Euclidean space and projects onto the convex decision set K only at decision time. In contrast, the agile version maintains a feasible point at all times, much like OGD. Algorithm 8 Online Mirrored Descent 1: Input: parameter η > 0, regularization function R(x). 2: Let y 1 be such that ∇R(y 1 ) = 0 and x 1 = arg min x∈K B R (x||y 1 ). 3: for t = 1 to T do 4: Play x t . 5: Observe the payoff function f t and let ∇ t = ∇f t (x t ). 6: Update y t according to the rule: [Lazy version] ∇R(y t+1 ) = ∇R(y t ) -η ∇ t [Agile version] ∇R(y t+1 ) = ∇R(x t ) -η ∇ t Project according to B R : x t+1 = arg min x∈K B R (x||y t+1 ) 7: end for A myriad of questions arise, but first, let us see how does this algorithm give rise to both OGD. We note that there are other important special cases of the RFTL metaalgorithm: those are derived with matrix-norm regularization-namely, the von Neumann entropy function, and the log-determinant function, as well as self-concordant barrier regularization. Perhaps most importantly for optimization, also the AdaGrad algorithm is obtained via changing regularizationwhich we shall explore in detail in the next chapter. Deriving online gradient descent To derive the online gradient descent algorithm, we take R(x) = 1 2 xx 0 2 2 for an arbitrary x 0 ∈ K. Projection with respect to this divergence is the standard Euclidean projection (left as an exercise), and in addition, ∇R(x) = x-x 0 . Hence, the update rule for the OMD Algorithm 8 becomes: x t = Π K (y t ), y t = y t-1 -η∇ t-1 lazy version x t = Π K (y t ), y t = x t-1 -η∇ t-1 agile version The latter algorithm is exactly online gradient descent, as described in Algorithm 4 in Chapter 4. Furthermore, both variants are identical for the case in which K is the unit ball. We later prove general regret bounds that will imply a O(GD √ T ) regret for OGD as a special case of mirrored descent. Deriving multiplicative updates Let R(x) = x log x = i x i log x i be the negative entropy function, where log x is to be interpreted elementwise. Then ∇R(x) = 1 + log x, and hence the update rules for the OMD algorithm become: x t = arg min x∈K B R (x||y t ), log y t = log y t-1 -η∇ t-1 lazy version x t = arg min x∈K B R (x||y t ), log y t = log x t-1 -η∇ t-1 agile version With this choice of regularizer, a notable special case is the experts problem we encountered in §5.1, for which the decision set K is the n- dimensional simplex ∆ n = {x ∈ R n + | i x i = 1}. In this special case, the projection according to the negative entropy becomes scaling by the ℓ 1 norm (left as an exercise), which implies that both update rules amount to the same algorithm: x t+1 (i) = x t (i) • e -η∇t(i) n j=1 x t (j) • e -η∇t(j) , which is exactly the Hedge algorithm! The general theorem we shall prove henceforth recovers the O( √ T log n) bound for prediction from expert advice for this algorithm. Technical background: regularization functions In the rest of this chapter we analyze the mirrored descent algorithm. For this purpose, consider regularization functions, denoted R : K → R, which are strongly convex and smooth (recall definitions in §2.1). Although it is not strictly necessary, we assume that the regularization functions in this chapter are twice differentiable over K and, for all points x ∈ int(K) in the interior of the decision set, have a Hessian ∇ 2 R(x) that is, by the strong convexity of R, positive definite. We denote the diameter of the set K relative to the function R as D R = max x,y∈K {R(x) -R(y)} Henceforth we make use of general norms and their dual. The dual norm to a norm • is given by the following definition: y * max x ≤1 x, y A positive definite matrix A gives rise to the matrix norm x A = √ x Ax. The dual norm of a matrix norm is x * A = x A -1 . The generalized Cauchy-Schwarz theorem asserts x, y ≤ x y * and in particular for matrix norms, x, y ≤ x A y * A . In our derivations, we usually consider matrix norms with respect to ∇ 2 R(x), the Hessian of the regularization function R(x). In such cases, we use the notation x y x ∇ 2 R(y) and similarly x * y x ∇ -2 R(y) A crucial quantity in the analysis with regularization is the remainder term of the Taylor approximation of the regularization function, and especially the remainder term of the first order Taylor approximation. The difference between the value of the regularization function at x and the value of the first order Taylor approximation is known as the Bregman divergence, given by Definition 5.6. Denote by B R (x||y) the Bregman divergence with respect to the function R, defined as B R (x||y) = R(x) -R(y) -∇R(y) (x -y) For twice differentiable functions, Taylor expansion and the mean-value theorem assert that the Bregman divergence is equal to the second derivative at an intermediate point, i.e., (see exercises) B R (x||y) = 1 2 x -y 2 z , for some point z ∈ [x, y], meaning there exists some α ∈ [0, 1] such that z = αx + (1 -α)y. Therefore, the Bregman divergence defines a local norm, which has a dual norm. We shall denote this dual norm by • * x,y • * z . With this notation we have B R (x||y) = 1 2 xy 2 x,y . In online convex optimization, we commonly refer to the Bregman divergence between two consecutive decision points x t and x t+1 . In such cases, we shorthand notation for the norm defined by the Bregman divergence with respect to R on the intermediate point in [x t , x t+1 ] as • t • xt,x t+1 . The latter norm is called the local norm at iteration t. With this notation, we have B R (x t ||x t+1 ) = 1 2 x t -x t+1 2 t . Finally, we consider below generalized projections that use the Bregman divergence as a distance instead of a norm. Formally, the projection of a point y according to the Bregman divergence with respect to function R is given by arg min x∈K B R (x||y) Regret bounds for Mirrored Descent In this subsection we prove regret bounds for the agile version of the RFTL algorithm. The analysis is quite different than the one for the lazy version, and of independent interest. Theorem 5.7. The RFTL Algorithm 8 attains for every u ∈ K the following bound on the regret: regret T ≤ 2η T t=1 ∇ t * 2 t + R(u) -R(x 1 ) η . If an upper bound on the local norms is known, i.e. ∇ t * t ≤ G R for all times t, then we can further optimize over the choice of η to obtain regret T ≤ 2D R G R √ 2T . Proof. Since the functions f t are convex, for any x * ∈ K, f t (x t ) -f t (x * ) ≤ ∇f t (x t ) (x t -x * ). The following property of Bregman divergences follows easily from the definition: for any vectors x, y, z, (x -y) (∇R(z) -∇R(y)) = B R (x, y) -B R (x, z) + B R (y, z). Combining both observations, 2(f t (x t ) -f t (x * )) ≤ 2∇f t (x t ) (x t -x * ) = 1 η (∇R(y t+1 ) -∇R(x t )) (x * -x t ) = 1 η [B R (x * , x t ) -B R (x * , y t+1 ) + B R (x t , y t+1 )] ≤ 1 η [B R (x * , x t ) -B R (x * , x t+1 ) + B R (x t , y t+1 )] where the last inequality follows from the generalized Pythagorean inequality (see [15] Lemma 11.3), as x t+1 is the projection w.r.t the Bregman divergence of y t+1 and x * ∈ K is in the convex set. Summing over all iterations, 2regret ≤ 1 η [B R (x * , x 1 ) -B R (x * , x T )] + T t=1 1 η B R (x t , y t+1 ) ≤ 1 η D 2 + T t=1 1 η B R (x t , y t+1 ) (5.1) We proceed to bound B R (x t , y t+1 ). By definition of Bregman divergence, and the generalized Cauchy-Schwartz inequality, B R (x t , y t+1 ) + B R (y t+1 , x t ) = (∇R(x t ) -∇R(y t+1 )) (x t -y t+1 ) = η∇f t (x t ) (x t -y t+1 ) ≤ η ∇f t (x t ) * x t -y t+1 ≤ 1 2 η 2 G 2 * + 1 2 x t -y t+1 2 . where in the last inequality follows from (a -b) 2 ≥ 0. Thus, by our assumption B R (x, y) ≥ 1 2 xy 2 , we have B R (x t , y t+1 ) ≤ 1 2 η 2 G 2 * + 1 2 x t -y t+1 2 -B R (y t+1 , x t ) ≤ 1 2 η 2 G 2 * . Plugging back into Equation (5.1), and by non-negativity of the Bregman divergence, we get regret ≤ 1 2 [ 1 η D 2 + 1 2 ηT G 2 * ] ≤ DG * √ T , by taking η = D 2 √ T G * Exercises 1. (a) Show that the dual norm to a matrix norm given by A 0 corresponds to the matrix norm of A -1 . (b) Prove the generalized Cauchy-Schwarz inequality for any norm, i.e., x, y ≤ x y * 2. Prove that the Bregman divergence is equal to the local norm at an intermediate point, that is: B R (x||y) = 1 2 x -y 2 z , where z ∈ [x, y] and the interval [x, y] is defined as [x, y] = {v = αx + (1 -α)y , α ∈ [0, 1]} 3. Let R(x) = 1 2 xx 0 2 be the (shifted) Euclidean regularization function. Prove that the corresponding Bregman divergence is the Euclidean metric. Conclude that projections with respect to this divergence are standard Euclidean projections. Prove that both agile and lazy versions of the OMD meta-algorithm are equivalent in the case that the regularization is Euclidean and the decision set is the Euclidean ball. 5. For this problem the decision set is the n-dimensional simplex. Let R(x) = x log x be the negative entropy regularization function. Prove that the corresponding Bregman divergence is the relative entropy, and prove that the diameter D R of the n-dimensional simplex with respect to this function is bounded by log n. Show that projections with respect to this divergence over the simplex amounts to scaling by the ℓ 1 norm. 6. * A set K ⊆ R d is symmetric if x ∈ K implies -x ∈ K. Symmetric sets gives rise to a natural definition of a norm. Define the function • K : R d → R as x K = arg min α>0 1 α x ∈ K Prove that • K is a norm if and only if K is convex. Bibliographic Remarks Regularization in the context of online learning was first studied in [26] and [48] . The influential paper of Kalai and Vempala [45] coined the term \"follow-the-leader\" and introduced many of the techniques that followed in OCO. The latter paper studies random perturbation as a regularization and analyzes the follow-the-perturbed-leader algorithm, following an early development by [29] that was overlooked in learning for many years. In the context of OCO, the term follow-the-regularized-leader was coined in [73, 71] , and at roughly the same time an essentially identical algorithm was called \"RFTL\" in [1] . The equivalence of RFTL and Online Mirrored Descent was observed by [34] . Chapter 6 Adaptive Regularization In the previous chapter we have studied a geometric extension of online / stochastic / determinisitic gradient descent. The technique to achieve it is called regularization, and we have seen how for the problem of prediction from expert advice, it can potentially given exponential improvements in the dependence on the dimension. A natural question that arises is whether we can automatically learn the optimal regularization, i.e. best algorithm from the mirrored-descent class, for the problem at hand? The answer is positive in a strong sense: it is theoretically possible to learn the optimal regularization online and in a data-specific way. Not only that, the resulting algorithms exhibit the most significant speedups in training deep neural networks from all accelerations studied thus far. Adaptive Learning Rates: Intuition The intuition for adaptive regularization is simple: consider an optimization problem which is axis-aligned, in which each coordinate is independent of the rest. It is reasonable to fine tune the learning rate for each coordinate separately -to achieve optimal convergence in that particular subspace of the problem, independently of the rest. Thus, it is reasonable to change the SGD update rule from x t+1 ← x t -η∇ t , to the more robust x t+1 ← x t -D t ∇ t , where D t is a diagonal matrix that contains in coordinate (i, i) the learning rate for coordinate i in the gradient. Recall from the previous sections that the optimal learning rate for stochastic non-convex optimization is of the order O( 1 √ t ). More precisely, in Theorem 3.4, we have seen that this learning rate should be on the order of O( 1 √ tσ 2 ), where σ 2 is the variance of the stochastic gradients. The empirical estimator of the latter is i<t ∇ i 2 . Thus, the robust version of stochastic gradient descent for smooth nonconvex optimization should behave as the above equation, with D t (i, i) = 1 i<t ∇ t (i) 2 . This is exactly the diagonal version of the AdaGrad algorithm! We continue to rigorously derive it and prove its performance guarantee. A Regularization Viewpoint In the previous chapter we have introduced regularization as a general methodology for deriving online convex optimization algorithms. Theorem 5.7 bounds the regret of the Mirrored Descent algorithm for any strongly convex regularizer as regret T ≤ max u∈K 2 t ∇ t * 2 t B R (u||x 1 ). In addition, we have seen how to derive the online gradient descent and the multiplicative weights algorithms as special cases of the RFTL methodology. We consider the following question: thus far we have thought of R as a strongly convex function. But which strongly convex function should we choose to minimize regret? This is a deep and difficult question which has been considered in the optimization literature since its early developments. The ML approach is to learn the optimal regularization online. That is, a regularizer that adapts to the sequence of cost functions and is in a sense the \"optimal\" regularization to use in hindsight. We formalize this in the next section. Tools from Matrix Calculus Many of the inequalities that we are familiar with for positive real numbers hold for positive semi-definite matrices as well. We henceforth need the following inequality, which is left as an exercise, Proposition 6.1. For positive definite matrices A B 0: 2Tr((A -B) 1/2 ) + Tr(A -1/2 B) ≤ 2Tr(A 1/2 ). Next, we require a structural result which explicitly gives the optimal regularization as a function of the gradients of the cost functions. For a proof see the exercises. Proposition 6.2. Let A 0. The minimizer of the following minimization problem: min X Tr(X -1 A) subject to X 0 Tr(X) ≤ 1, is X = A 1/2 /Tr(A 1/2 ), and the minimum objective value is Tr 2 (A 1/2 ). The AdaGrad Algorithm and Its Analysis To be more formal, let us consider the set of all strongly convex regularization functions with a fixed and bounded Hessian in the set ∀x ∈ K . ∇ 2 R(x) = ∇ 2 ∈ H {X ∈ R n×n ; Tr(X) ≤ 1 , X 0} The set H is a restricted class of regularization functions (which does not include the entropic regularization). However, it is a general enough class to capture online gradient descent along with any rotation of the Euclidean regularization. Algorithm 9 AdaGrad (Full Matrix version) 1: Input: parameters η, x 1 ∈ K. 2: Initialize: S 0 = G 0 = 0, 3: for t = 1 to T do 4: Predict x t , suffer loss f t (x t ). 5: Update: S t = S t-1 + ∇ t ∇ t , G t = S t 1/2 y t+1 = x t -ηG -1 t ∇ t x t+1 = arg min x∈K y t+1 -x 2 Gt 6: end for The problem of learning the optimal regularization has given rise to Algorithm 9, known as the AdaGrad (Adaptive subGradient method) algorithm. In the algorithm definition and throughout this chapter, the notation A -1 refers to the Moore-Penrose pseudoinverse of the matrix A. Perhaps surprisingly, the regret of AdaGrad is at most a constant factor larger than the minimum regret of all RFTL algorithm with regularization functions whose Hessian is fixed and belongs to the class H. The regret bound on AdaGrad is formally stated in the following theorem. Then for any x ∈ K, regret T (AdaGrad) ≤ 2D min H∈H t ∇ t * 2 H . Before proving this theorem, notice that it delivers on one of the promised accounts: comparing to the bound of Theorem 5.7 and ignoring the diameter D and dimensionality, the regret bound is as good as the regret of RFTL for the class of regularization functions. We proceed to prove Theorem 6.3. First, a direct corollary of Proposition 6.2 is that Corollary 6.4. min H∈H t ∇ t * 2 H = min H∈H Tr(H -1 t ∇ t ∇ t ) = Tr t ∇ t ∇ t = Tr(G T ) Hence, to prove Theorem 6.3, it suffices to prove the following lemma. Lemma 6.5. regret T (AdaGrad) ≤ 2DTr(G T ) = 2D min H∈H t ∇ t * 2 H . Proof. By the definition of y t+1 : y t+1 -x = x t -x -ηG t -1 ∇ t , (6.1) and G t (y t+1 -x ) = G t (x t -x ) -η∇ t . (6.2) Multiplying the transpose of (6.1) by ( 6 .2) we get (y t+1 -x ) G t (y t+1 -x ) = (x t -x ) G t (x t -x ) -2η∇ t (x t -x ) + η 2 ∇ t G -1 t ∇ t . (6.3) Since x t+1 is the projection of y t+1 in the norm induced by G t , we have (see §2.1.1) (y t+1 -x ) G t (y t+1 -x ) = y t+1 -x 2 Gt ≥ x t+1 -x 2 Gt . This inequality is the reason for using generalized projections as opposed to standard projections, which were used in the analysis of online gradient descent (see §4.4 Equation (4.2)). This fact together with (6.3) gives ∇ t (x t -x ) ≤ η 2 ∇ t G -1 t ∇ t + 1 2η x t -x 2 Gt -x t+1 -x 2 Gt . Now, summing up over t = 1 to T we get that T t=1 ∇ t (x t -x ) ≤ η 2 T t=1 ∇ t G -1 t ∇ t + 1 2η x 1 -x 2 G 0 (6.4) + 1 2η T t=1 x t -x 2 Gt -x t -x 2 G t-1 - 1 2η x T +1 -x 2 G T ≤ η 2 T t=1 ∇ t G -1 t ∇ t + 1 2η T t=1 (x t -x ) (G t -G t-1 )(x t -x ). In the last inequality we use the fact that G 0 = 0. We proceed to bound each of the terms above separately. Lemma 6.6. With S t , G t as defined in Algorithm 9, T t=1 ∇ t G -1 t ∇ t ≤ 2 T t=1 ∇ t G -1 T ∇ t ≤ 2Tr(G T ). Proof. We prove the lemma by induction. The base case follows since ∇ 1 G -1 1 ∇ 1 = Tr(G -1 1 ∇ 1 ∇ 1 ) = Tr(G -1 1 G 2 1 ) = Tr(G 1 ). Assuming the lemma holds for T -1, we get by the inductive hypothesis T t=1 ∇ t G -1 t ∇ t ≤ 2Tr(G T -1 ) + ∇ T G -1 T ∇ T = 2Tr((G 2 T -∇ T ∇ T ) 1/2 ) + Tr(G -1 T ∇ T ∇ T ) ≤ 2Tr(G T ). Here, the last inequality is due to the matrix inequality 6.1. Lemma 6.7. T t=1 (x t -x ) (G t -G t-1 )(x t -x ) ≤ D 2 Tr(G T ). Proof. By definition S t S t-1 , and hence G t G t-1 . Thus, T t=1 (x t -x ) (G t -G t-1 )(x t -x ) ≤ T t=1 D 2 λ max (G t -G t-1 ) ≤ D 2 T t=1 Tr(G t -G t-1 ) A 0 ⇒ λ max (A) ≤ Tr(A) = D 2 T t=1 (Tr(G t ) -Tr(G t-1 )) linearity of the trace ≤ D 2 Tr(G T ). Plugging both lemmas into Equation (6.4), we obtain T t=1 ∇ t (x t -x ) ≤ ηTr(G T ) + 1 2η D 2 Tr(G T ) ≤ 2DTr(G T ). Diagonal AdaGrad The AdaGrad algorithm maintains potentially dense matrices, and requires the computation of the square root of these matrices. This is usually prohibitive in machine learning applications in which the dimension is very large. Fortunately, the same ideas can be applied with almost no computational overhead on top of vanilla SGD, using the diagonal version of AdaGrad given by: Algorithm 10 AdaGrad (diagonal version) 1: Input: parameters η, x 1 ∈ K. 2: Initialize: S 0 = G 0 = 0, 3: for t = 1 to T do 4: Predict x t , suffer loss f t (x t ). 5: Update: S t = S t-1 + diag(∇ t ∇ t ), G t = S t 1/2 y t+1 = x t -ηG -1 t ∇ t x t+1 = arg min x∈K y t+1 -x 2 Gt 6: end for In contrast to the full-matrix version, this version can be implemented in linear time and space, since diagonal matrices can be manipulated as vectors. Thus, memory overhead is only a single d-dimensional vector, which is used to represent the diagonal preconditioning (regularization) matrix, and the computational overhead is a few vector manipulations per iteration. Very similar to the full matrix case, the diagonal AdaGrad algorithm can be analyzed and the following performance bound obtained: Theorem 6.8. Let {x t } be defined by Algorithm 10 with parameters η = D ∞ , where D ∞ = max u∈K u -x 1 ∞ , and let diag(H) be the set of all diagonal matrices in H. Then for any x ∈ K, regret T (D-AdaGrad) ≤ 2D ∞ min H∈diag(H) t ∇ t * 2 H . State-of-the-art: from Adam to Shampoo and beyond Since the introduction of the adaptive regularization technique in the context of regret minimization, several improvements were introduced that now compose state-of-the-art. A few notable advancements include: AdaDelta: The algorithm keeps an exponential average of past gradients and uses that in the update step. Adam: Adds a sliding window to AdaGrad, as well as adding a form of momentum via estimating the second moments of past gradients and adjusting the update accordingly. Shampoo: Interpolates between full-matrix and diagonal adagrad in the context of deep neural networks: use of the special layer structure to reduce memory constraints. AdaFactor: Suggests a Shampoo-like approach to reduce memory footprint even further, to allow the training of huge models. GGT: While full-matrix AdaGrad is computationally slow due to the cost of manipulating matrices, this algorithm uses recent gradients (a thin matrix G), and via linear algebraic manipulations reduces computation by never computing GG , but rather only G G, which is low dimensional. SM3 , ET: Diagonal AdaGrad requires an extra O(n) memory to store diag(G t ). These algorithms, inspired by AdaFactor, approximate G t as a low rank tensor to save memory and computation. Exercises 1. * Prove that for positive definite matrices A B 0 it holds that (a) A 1/2 B 1/2 (b) 2Tr((A -B) 1/2 ) + Tr(A -1/2 B) ≤ 2Tr(A 1/2 ). 2. * Consider the following minimization problem where A 0: min X Tr(X -1 A) subject to X 0 Tr(X) ≤ 1. Prove that its minimizer is given by X = A 1/2 /Tr(A 1/2 ), and the minimum is obtained at Tr 2 (A 1/2 ). Bibliographic Remarks The AdaGrad algorithm was introduced in [19, 18] , its diagonal version was also discovered in parallel in [52] . Adam [46] and RMSprop [39] are widely used methods based on adaptive regularization. A cleaner analysis was recently proposed in [27] , see also [17] . Adaptive regularization has received much attention recently, see e.g., [60, 85] . Newer algorithmic developments on adaptive regularization include Shampoo [28] , GGT [3] , AdaFactor [77] , Extreme Tensoring [16] and SM3 [6] . Chapter 7 Variance Reduction In the previous chapter we have studied the first of our three acceleration techniques over SGD, adaptive regularization, which is a geometric tool for acceleration. In this chapter we introduce the second first-order acceleration technique, called variance reduction. This technique is probabilistic in nature, and applies to more restricted settings of mathematical optimization in which the objective function has a finite-sum structure. Namely, we consider optimization problems of the form min x∈K f (x) , f (x) = 1 m m i=1 f i (x) . (7.1) Such optimization problems are canonical in training of ML models, convex and non-convex. However, in the context of machine learning we should remember that the ultimate goal is generalization rather than training. Variance reduction: Intuition The intuition for variance reduction is simple, and comes from trying to improve the naive convergence bounds for SGD that we have covered in the first lesson. Recall the SGD update rule x t+1 ← x t -η ∇t , in which ∇t is an unbiased estimator for the gradient such that E[ ∇t ] = ∇ t , E[ ∇t 2 2 ] ≤ σ 2 . We have seen in Theorem 3.4, that for this update rule, E 1 T t ∇ t 2 ≤ 2 M βσ 2 T . The convergence is proportional to the second moment of the gradient estimator, and thus it makes sense to try to reduce this second moment. The variance reduction technique attempts to do so by using the average of all previous gradients, as we show next. Setting and definitions We consider the ERM optimization problem over an average of loss functions. Before we begin, we need a few preliminaries and assumptions: 1. We denote distance to optimality according to function value as h t = f (x t ) -f (x * ), and in the k'th epoch of an algorithm, we denote h k t = f (x k t ) -f (x * ). 2. We denote hk = max 4h k 0 , 8αD 2 k over an epoch. 3. Assume all stochastic gradients have bounded second moments ∇t 2 2 ≤ σ 2 . 4. We will assume that the individual functions f i in formulation (7.1) are also β-smooth and have β-Lipschitz gradient, namely ∇f i (x) -∇f i (y) ≤ β x -y . 5. We will use, proved in Lemma 2.3, that for β-smooth and α-strongly convex f we have h t ≥ 1 2β ∇ t 2 and α 2 d 2 t = α 2 x t -x * 2 ≤ h t ≤ 1 2α ∇ t 2 . 6. Recall that a function f is γ-well-conditioned if it is β-smooth, αstrongly convex and γ ≤ α β . The variance reduction advantage Consider gradient descent for γ-well conditioned functions, and specifically used for ML training as in formulation (7.1) . It is well known that GD attains linear convergence rate as we now prove for completeness: Theorem 7.1. For unconstrained minimization of γ-well-conditioned functions and η t = 1 β , the Gradient Descent Algorithm 2 converges as h t+1 ≤ h 1 e -γt . Proof. h t+1 -h t = f (x t+1 ) -f (x t ) ≤ ∇ t (x t+1 -x t ) + β 2 x t+1 -x t 2 β-smoothness = -η t ∇ t 2 + β 2 η 2 t ∇ t 2 algorithm defn. = - 1 2β ∇ t 2 choice of η t = 1 β ≤ - α β h t . by (2.1) Thus, h t+1 ≤ h t (1 - α β ) ≤ • • • ≤ h 1 (1 -γ) t ≤ h 1 e -γt where the last inequality follows from 1 -x ≤ e -x for all x ∈ R. However, what is the overall computational cost? Assuming that we can compute the gradient of each loss function corresponding to the individual training examples in O(d) time, the overall running time to compute the gradient is O(md). In order to attain approximation ε to the objective, the algorithm requires O( 1 γ log 1 ε ) iterations, as per the Theorem above. Thus, the overall running time becomes O( md γ log 1 ε ). As we show below, variance reduction can reduce this running time to be O((m + 1 γ2 )d log 1 ε ) , where γ is a different condition number for the same problem, that is in general smaller than the original. Thus, in one line, the variance reduction advantage can be summarized as: md γ log 1 ε → (m + 1 γ2 )d log 1 ε . A simple variance-reduced algorithm The following simple variance-reduced algorithm illustrates the main ideas of the technique. The algorithm is a stochastic gradient descent variant which proceeds in epochs. Strong convexity implies that the distance to the optimum shrinks with function value, so it is safe to decrease the distance upper bound every epoch. The main innovation is in line 7, which constructs the gradient estimator. Instead of the usual trick -which is to sample one example at random -here the estimator uses the entire gradient computed at the beginning of the current epoch. Algorithm 11 Epoch GD 1: Input: f , T , x 1 0 ∈ K, upper bound D 1 ≥ x 1 0 -x * , step sizes {η t } 2: for k = 1 to log 1 ε do 3: Let B D k (x k 0 ) be the ball of radius D k around x k 0 . 4: compute full gradient ∇ k 0 = ∇f (x k 0 ) 5: for t = 1 to T do 6: Sample i t ∈ [m] uniformly at random, let f t = f it . 7: construct stochastic gradient ∇k t = ∇f t (x k t ) -∇f t (x k 0 ) + ∇ k 0 8: Let y k t+1 = x k t -η t ∇k t , x t+1 = Π B D k (x k 0 ) (y t+1 ) 9: end for 10: Set x k+1 0 = 1 T T t=1 x k t . D k+1 ← D k /2. 11: end for 12: return x 0 T +1 The main guarantee for this algorithm is the following theorem, which delivers upon the aforementioned improvement, Theorem 7.2. Algorithm 11 returns an ε-approximate solution to optimization problem (7.1) in total time O m + 1 γ2 d log 1 ε . Let γ = α β < γ. Then the proof of this theorem follows from the following lemma. Lemma 7.3. For T = Õ 1 γ2 , we have E[ hk+1 ] ≤ 1 2 hk . Proof. As a first step, we bound the variance of the gradients. Due to the fact that x k t ∈ B D k (x k 0 ), we have that for k > k, x k t -x k t 2 ≤ 4D 2 k . Thus, ∇k t 2 = ∇f t (x k t ) -∇f t (x k 0 ) + ∇f (x k 0 ) 2 definition ≤ 2 ∇f t (x k t ) -∇f t (x k 0 ) 2 + 2 ∇f (x k 0 ) 2 (a + b) 2 ≤ 2a 2 + 2b 2 ≤ 2 β2 x k t -x k 0 2 + 4βh k 0 smoothness ≤ 8 β2 D 2 k + 4βh k 0 projection step ≤ β2 1 α hk + 4βh k 0 ≤ hk ( β2 α + β) Next, using the regret bound for strongly convex functions, we have E[h k+1 0 ] ≤ E[ 1 T t h k t ] Jensen ≤ 1 αT E[ t 1 t ∇k t 2 ] Theorem 4.4 ≤ 1 αT t 1 t hk ( β2 α + β) above ≤ log T T hk ( 1 γ2 + 1 γ ) γ = α β Which implies the Lemma by choice of T , definition of hk = max 4h k 0 , 8αD 2 k , and exponential decrease of D k . The expectation is over the stochastic gradient definition, and is required for using Theorem 4.4. To obtain the theorem from the lemma above, we need to strengthen it to a high probability statement using a martingale argument. This is possible since the randomness in construction of the stochastic gradients is i.i.d. The lemma now implies the theorem by noting that O(log 1 ε ) epochs suffices to get ε-approximation. Each epoch requires the computation of one full gradient, in time O(md), and Õ( 1 γ2 ) iterations that require stochastic gradient computation, in time O(d). Bibliographic Remarks The variance reduction technique was first introduced as part of the SAG algorithm [70] . Since then a host of algorithms were developed using the technique. The simplest exposition of the technique was given in [44] . The exposition in this chapter is developed from the Epoch GD algorithm [37] , which uses a related technique for stochastic strongly convex optimization, as developed in [86] . Chapter 8 Nesterov Acceleration In previous chapters we have studied our bread and butter technique, SGD, as well as two acceleration techniques of adaptive regularization and variance reduction. In this chapter we study the historically earliest acceleration technique, known as Nesterov acceleration, or simply \"acceleration\". For smooth and convex functions, Nesterov acceleration improves the convergence rate to optimality to O( 1 T 2 ), a quadratic improvement over vanilla gradient descent. Similar accelerations are possible when the function is also strongly convex: an accelerated rate of e -√ γT , where γ is the condition number, vs. e -γT of vanilla gradient descent. This improvement is theoretically very significant. However, in terms of applicability, Nesterov acceleration is theoretically the most restricted in the context of machine learning: it requires a smooth and convex objective. More importantly, the learning rates of this method are very brittle, and the method is not robust to noise. Since noise is predominant in machine learning, the theoretical guarantees in stochastic optimization environments are very restricted. However, the heuristic of momentum, which historically inspired acceleration, is extremely useful for non-convex stochastic optimization (although not known to yield significant improvements in theory). Algorithm and implementation Nesterov acceleration applies to the general setting of constrained smooth convex optimization: min x∈R d f (x). ( 8.1) For simplicity of presentation, we restrict ourselves to the unconstrained convex and smooth case. Nevertheless, the method can be extended to constrained smooth convex, and potentially strongly convex, settings. The simple method presented in Algorithm 12 below is computationally equivalent to gradient descent. The only overhead is saving three state vectors (that can be reduced to two) instead of one for gradient descent. The following simple accelerated algorithm illustrates the main ideas of the technique. Algorithm 12 Simplified Nesterov Acceleration 1: Input: f , T , initial point x 0 , parameters η, β, τ . 2: for t = 1 to T do 3: Set x t+1 = τ z t + (1 -τ )y t , and denote ∇ t+1 = ∇f (x t+1 ). 4: Let y t+1 = x t+1 -1 β ∇ t+1 5: Let z t+1 = z t -η∇ t+1 6: end for 7: return x = 1 T t x t Analysis The main guarantee for this algorithm is the following theorem. η∇ t+1 (z t -x * ) ≤ 2η 2 β(f (x t+1 ) -f (y t+1 )) + z t -x * 2 -z t+1 -x * 2 . Proof. The proof is very similar to that of Theorem 4.2. By definition of z t , 1 z t+1 -x * 2 = z t -η∇ t+1 -x * 2 = z t -x * 2 -η∇ t+1 (z t -x * ) + η 2 ∇ t+1 2 ≤ z t -x * 2 -η∇ t+1 (z t -x * ) + 2η 2 β(f (x t+1 ) -f (y t+1 )) Lemma 2.3 part 3 1 Henceforth we use Lemma 2.3 part 3. This proof of this Lemma shows that for y = x -1 β ∇f (x), it holds that f (x) -f (y) ≥ 1 2β ∇f (x) 2 . Lemma 8.3. For 2ηβ = 1-τ τ , we have that η∇ t+1 (x t+1 -x * ) ≤ 2η 2 β(f (y t ) -f (y t+1 )) + z t -x * 2 -z t+1 -x * 2 . Proof. η∇ t+1 (x t+1 -x * ) -η∇ t+1 (z t -x * ) = η∇ t+1 (x t+1 -z t ) = (1-τ )η τ ∇ t+1 (y t -x t+1 ) τ (x t+1 -z t ) = (1 -τ )(y t -x t+1 ) ≤ (1-τ )η τ (f (y t ) -f (x t+1 )). convexity Thus, in combination with Lemma 8.2, and the condition of the Lemma, we get the inequality. We can now sketch the proof of the main theorem. Proof. Telescope Lemma 8.3 for all iterations to obtain: T h T = T (f (x) -f (x * )) ≤ t ∇ t (x t -x * ) ≤ 2ηβ t (f (y t ) -f (y t+1 )) + 1 η t z t -x * 2 -z t+1 -x * 2 ≤ 2ηβ(f (y 1 ) -f (y T +1 )) + 1 η z 1 -x * 2 -z T +1 -x * 2 ≤ √ 2βh 1 D, optimizing η where h 1 is an upper bound on the distance f (y 1 ) -f (x * ), and D bounds the Euclidean distance of z t to the optimum. Thus, we get a recurrence of the form h T ≤ √ h 1 T . Restarting Algorithm 12 and adapting the learning rate according to h T gives a rate of convergence of O( 1 T 2 ) to optimality. Bibliographic Remarks Accelerated rates of order O( 1 T 2 ) were obtained by Nemirovski as early as the late seventies. The first practically efficient accelerated algorithm is due to Nesterov [56] , see also [57] . The simplified proof presented hereby is due to [5] . Chapter 9 The conditional gradient method In many computational and learning scenarios the main bottleneck of optimization, both online and offline, is the computation of projections onto the underlying decision set (see §2.1.1). In this chapter we discuss projection-free methods in convex optimization, and some of their applications in machine learning. The motivating example throughout this chapter is the problem of matrix completion, which is a widely used and accepted model in the construction of recommendation systems. For matrix completion and related problems, projections amount to expensive linear algebraic operations and avoiding them is crucial in big data applications. Henceforth we describe the conditional gradient algorithm, also known as the Frank-Wolfe algorithm. Afterwards, we describe problems for which linear optimization can be carried out much more efficiently than projections. We conclude with an application to exploration in reinforcement learning. Review: relevant concepts from linear algebra This chapter addresses rectangular matrices, which model applications such as recommendation systems naturally. Consider a matrix X ∈ R n×m . A non-negative number σ ∈ R + is said to be a singular value for X if there are two vectors u ∈ R n , v ∈ R m such that X u = σv, Xv = σu. The vectors u, v are called the left and right singular vectors respectively. The non-zero singular values are the square roots of the eigenvalues of the matrix XX (and X X). The matrix X can be written as X = U ΣV , U ∈ R n×ρ , V ∈ R ρ×m , where ρ = min{n, m}, the matrix U is an orthogonal basis of the left singular vectors of X, the matrix V is an orthogonal basis of right singular vectors, and Σ is a diagonal matrix of singular values. This form is called the singular value decomposition for X. The number of non-zero singular values for X is called its rank, which we denote by k ≤ ρ. The nuclear norm of X is defined as the ℓ 1 norm of its singular values, and denoted by X * = ρ i=1 σ i It can be shown (see exercises) that the nuclear norm is equal to the trace of the square root of the matrix times its transpose, i.e., X * = Tr( √ X X) We denote by A • B the inner product of two matrices as vectors in R n×m , that is A • B = n i=1 m j=1 A ij B ij = Tr(AB ) Motivation: matrix completion and recommendation systems Media recommendations have changed significantly with the advent of the Internet and rise of online media stores. The large amounts of data collected allow for efficient clustering and accurate prediction of users' preferences for a variety of media. A well-known example is the so called \"Netflix challenge\"-a competition of automated tools for recommendation from a large dataset of users' motion picture preferences. One of the most successful approaches for automated recommendation systems, as proven in the Netflix competition, is matrix completion. Perhaps the simplest version of the problem can be described as follows. The entire dataset of user-media preference pairs is thought of as a partially-observed matrix. Thus, every person is represented by a row in the matrix, and every column represents a media item (movie). For simplicity, let us think of the observations as binary-a person either likes or dislikes a particular movie. Thus, we have a matrix M ∈ {0, 1, * } n×m where n is the number of persons considered, m is the number of movies at our library, and 0/1 and * signify \"dislike\", \"like\" and \"unknown\" respectively: M ij =            0, person i dislikes movie j 1, person i likes movie j * , preference unknown . The natural goal is to complete the matrix, i.e. correctly assign 0 or 1 to the unknown entries. As defined so far, the problem is ill-posed, since any completion would be equally good (or bad), and no restrictions have been placed on the completions. The common restriction on completions is that the \"true\" matrix has low rank. Recall that a matrix X ∈ R n×m has rank k < ρ = min{n, m} if and only if it can be written as X = U V , U ∈ R n×k , V ∈ R k×m . The intuitive interpretation of this property is that each entry in M can be explained by only k numbers. In matrix completion this means, intuitively, that there are only k factors that determine a persons preference over movies, such as genre, director, actors and so on. Now the simplistic matrix completion problem can be well-formulated as in the following mathematical program. Denote by • OB the Euclidean norm only on the observed (non starred) entries of M , i.e., X 2 OB = M ij = * X 2 ij . The mathematical program for matrix completion is given by min X∈R n×m 1 2 X -M 2 OB s.t. rank(X) ≤ k. Since the constraint over the rank of a matrix is non-convex, it is standard to consider a relaxation that replaces the rank constraint by the nuclear norm. It is known that the nuclear norm is a lower bound on the matrix rank if the singular values are bounded by one (see exercises). Thus, we arrive at the following convex program for matrix completion: min X∈R n×m 1 2 X -M 2 OB (9.1) s.t. X * ≤ k. We consider algorithms to solve this convex optimization problem next. The Frank-Wolfe method In this section we consider minimization of a convex function over a convex domain. The conditional gradient (CG) method, or Frank-Wolfe algorithm, is a simple algorithm for minimizing a smooth convex function f over a convex set K ⊆ R n . The appeal of the method is that it is a first order interior point method -the iterates always lie inside the convex set, and thus no projections are needed, and the update step on each iteration simply requires minimizing a linear objective over the set. The basic method is given in Algorithm 13. Algorithm 13 Conditional gradient 1: Input: step sizes {η t ∈ (0, 1], t ∈ [T ]}, initial point x 1 ∈ K. 2: for t = 1 to T do 3: v t ← arg min x∈K x ∇f (x t ) . 4: x t+1 ← x t + η t (v t -x t ). 5: end for Note that in the CG method, the update to the iterate x t may be not be in the direction of the gradient, as v t is the result of a linear optimization procedure in the direction of the negative gradient. This is depicted in Figure 9 .1. The following theorem gives an essentially tight performance guarantee of this algorithm over smooth functions. Recall our notation from Chapter 2: x denotes the global minimizer of f over K, D denotes the diameter of the set K, and h t = f (x t ) -f (x ) denotes the suboptimality of the objective value in iteration t. Theorem 9.1. The CG algorithm applied to β-smooth functions with step sizes η t = min{ 2H t , 1}, for H ≥ max{1, h 1 }, attains the following convergence guarantee: Proof. As done before in this manuscript, we denote ∇ t = ∇f (x t ), and also denote H ≥ max{h 1 , 1}, such that η t = min{ 2H t , 1}. For any set of step sizes, we have h t ≤ 2βHD 2 t f (x t+1 ) -f (x ) = f (x t + η t (v t -x t )) -f (x ) ≤ f (x t ) -f (x ) + η t (v t -x t ) ∇ t + η 2 t β 2 v t -x t 2 β-smoothness ≤ f (x t ) -f (x ) + η t (x -x t ) ∇ t + η 2 t β 2 v t -x t 2 v t optimality ≤ f (x t ) -f (x ) + η t (f (x ) -f (x t )) + η 2 t β 2 v t -x t 2 convexity of f ≤ (1 -η t )(f (x t ) -f (x )) + η 2 t β 2 D 2 . (9.2) We reached the recursion h t+1 ≤ (1 -η t )h t + η 2 t βD 2 2 , and by induction, h t+1 ≤ (1 -η t )h t + η 2 t βD 2 2 ≤ (1 -η t ) 2βHD 2 t + η 2 t βD 2 2 induction hypothesis ≤ (1 - 2H t ) 2βHD 2 t + 4H 2 t 2 βD 2 2 value of η t = 2βHD 2 t - 2H 2 βD 2 t 2 ≤ 2βHD 2 t (1 - 1 t ) since H ≥ 1 ≤ 2βHD 2 t + 1 . t-1 t ≤ t t+1 9. Projections vs. linear optimization The conditional gradient (Frank-Wolfe) algorithm described before does not resort to projections, but rather computes a linear optimization problem of the form arg min x∈K x u . (9.3) When is the CG method computationally preferable? The overall computational complexity of an iterative optimization algorithm is the product of the number of iterations and the computational cost per iteration. The CG method does not converge as well as the most efficient gradient descent algorithms, meaning it requires more iterations to produce a solution of a comparable level of accuracy. However, for many interesting scenarios the computational cost of a linear optimization step (9.3) is significantly lower than that of a projection step. Let us point out several examples of problems for which we have very efficient linear optimization algorithms, whereas our state-of-the-art algorithms for computing projections are significantly slower. Recommendation systems and matrix prediction. In the example pointed out in the preceding section of matrix completion, known methods for projection onto the spectahedron, or more generally the bounded nuclearnorm ball, require singular value decompositions, which take superlinear time via our best known methods. In contrast, the CG method requires maximal eigenvector computations which can be carried out in linear time via the power method (or the more sophisticated Lanczos algorithm). Network routing and convex graph problems. Various routing and graph problems can be modeled as convex optimization problems over a convex set called the flow polytope. Consider a directed acyclic graph with m edges, a source node marked s and a target node marked t. Every path from s to t in the graph can be represented by its identifying vector, that is a vector in {0, 1} m in which the entries that are set to 1 correspond to edges of the path. The flow polytope of the graph is the convex hull of all such identifying vectors of the simple paths from s to t. This polytope is also exactly the set of all unit s-t flows in the graph if we assume that each edge has a unit flow capacity (a flow is represented here as a vector in R m in which each entry is the amount of flow through the corresponding edge). Since the flow polytope is just the convex hull of s-t paths in the graph, minimizing a linear objective over it amounts to finding a minimum weight path given weights for the edges. For the shortest path problem we have very efficient combinatorial optimization algorithms, namely Dijkstra's algorithm. Thus, applying the CG algorithm to solve any convex optimization problem over the flow polytope will only require iterative shortest path computations. Ranking and permutations. A common way to represent a permutation or ordering is by a permutation matrix. Such are square matrices over {0, 1} n×n that contain exactly one 1 entry in each row and column. Doubly-stochastic matrices are square, real-valued matrices with nonnegative entries, in which the sum of entries of each row and each column amounts to 1. The polytope that defines all doubly-stochastic matrices is called the Birkhoff-von Neumann polytope. The Birkhoff-von Neumann theorem states that this polytope is the convex hull of exactly all n × n permutation matrices. Since a permutation matrix corresponds to a perfect matching in a fully connected bipartite graph, linear minimization over this polytope corresponds to finding a minimum weight perfect matching in a bipartite graph. Consider a convex optimization problem over the Birkhoff-von Neumann polytope. The CG algorithm will iteratively solve a linear optimization problem over the BVN polytope, thus iteratively solving a minimum weight perfect matching in a bipartite graph problem, which is a well-studied combinatorial optimization problem for which we know of efficient algorithms. In contrast, other gradient based methods will require projections, which are quadratic optimization problems over the BVN polytope. Matroid polytopes. A matroid is pair (E, I) where E is a set of elements and I is a set of subsets of E called the independent sets which satisfy various interesting proprieties that resemble the concept of linear independence in vector spaces. Matroids have been studied extensively in combinatorial optimization and a key example of a matroid is the graphical matroid in which the set E is the set of edges of a given graph and the set I is the set of all subsets of E which are cycle-free. In this case, I contains all the spanning trees of the graph. A subset S ∈ I could be represented by its identifying vector which lies in {0, 1} |E| which also gives rise to the matroid polytope which is just the convex hull of all identifying vectors of sets in I. It can be shown that some matroid polytopes are defined by exponentially many linear inequalities (exponential in |E|), which makes optimization over them difficult. On the other hand, linear optimization over matroid polytopes is easy using a simple greedy procedure which runs in nearly linear time. Thus, the CG method serves as an efficient algorithm to solve any convex optimization problem over matroids iteratively using only a simple greedy procedure. Exercises 1. Prove that if the singular values are smaller than or equal to one, then the nuclear norm is a lower bound on the rank, i.e., show rank(X) ≥ X * . 2. Prove that the trace is related to the nuclear norm via X * = Tr( √ XX ) = Tr( √ X X). 3. Show that maximizing a linear function over the spectahedron is equivalent to a maximal eigenvector computation. That is, show that the following mathematical program: min X • C X ∈ S d = {X ∈ R d×d , X 0 , Tr(X) ≤ 1}, is equivalent to the following: min x∈R d x Cx s.t. x 2 ≤ 1. 4. Download the MovieLens dataset from the web. Implement an online recommendation system based on the matrix completion model: implement the OCG and OGD algorithms for matrix completion. Benchmark your results. Bibliographic Remarks The matrix completion model has been extremely popular since its inception in the context of recommendation systems [80, 66, 69, 50, 14, 75] . The conditional gradient algorithm was devised in the seminal paper by Frank and Wolfe [21] . Due to the applicability of the FW algorithm to large-scale constrained problems, it has been a method of choice in recent machine learning applications, to name a few: [42, 49, 41, 20, 30, 36, 72, 7, 82, 22, 23, 8] . The online conditional gradient algorithm is due to [36] . An optimal regret algorithm, attaining the O( √ T ) bound, for the special case of polyhedral sets was devised in [23] . Chapter 10 Second order methods for machine learning At this point in our course, we have exhausted the main techniques in first-order (or gradient-based) optimization. We have studied the main workhorse -stochastic gradient descent, the three acceleration techniques, and projection-free gradient methods. Have we exhausted optimization for ML? In this section we discuss using higher derivatives of the objective function to accelerate optimization. The canonical method is Newton's method, which involves the second derivative or Hessian in high dimensions. The vanilla approach is computationally expensive since it involves matrix inversion in high dimensions that machine learning problems usually require. However, recent progress in random estimators gives rise to linear-time second order methods, for which each iteration is as computationally cheap as gradient descent. Motivating example: linear regression In the problem of linear regression we are given a set of measurements {a i ∈ R d , b i ∈ R}, and the goal is to find a set of weights that explains them best in the mean squared error sense. As a mathematical program, the goal is to optimize: min x∈R d    1 2 i∈[m] a i x -b i 2    , or in matrix form, min x f (x) = 1 2 Ax -b 2 . Here A ∈ R m×d , b ∈ R m . Notice that the objective function f is smooth, but not necessarily strongly convex. Therefore, all algorithms that we have studied so far without exception, which are all first order methods, attain rates which are poly( 1 ε ). However, the linear regression problem has a closed form solution that can be computed by taking the gradient to be zero, i.e. (Ax -b) A = 0, which gives x = (A A) -1 A b. The Newton direction is given by the inverse Hessian multiplied by the gradient, ∇ -2 f (x)∇f (x). Observe that a single Newton step, i.e. moving in the Newton direction with step size one, from any direction gets us directly to the optimal solution in one iteration! (see exercises) More generally, Newton's method yields O(log 1 ε ) convergence rates for a large class of functions without dependence on the condition number of the function! We study this property next. Self-Concordant Functions In this section we define and collect some of the properties of a special class of functions, called self-concordant functions. These functions allow Newton's method to run in time which is independent of the condition number. The class of self-concordant functions is expressive and includes quadratic functions, logarithms of inner products, a variety of barriers such as the log determinant, and many more. An excellent reference for this material is the lecture notes on this subject by Nemirovski [55] . We begin by defining self-concordant functions. Definition 10.1 (Self-Concordant Functions). Let K ⊆ R n be a non-empty open convex set, and and let f : K → R be a C 3 convex function. Then, f is said to be self-concordant if |∇ 3 f (x)[h, h, h]| ≤ 2(h ∇ 2 f (x)h) 3/2 , where we have ∇ k f (x)[h 1 , . . . , h k ] ∂ k ∂t 1 . . . ∂t k | t 1 =•••=t k f (x + t 1 h 1 + • • • + t k h k ). NEWTON'S METHOD Another key object in the analysis of self concordant functions is the notion of a Dikin Ellipsoid, which is the unit ball around a point in the norm given by the Hessian • ∇ 2 f at the point. We will refer to this norm as the local norm around a point and denote it as • x . Formally, Definition 10.2 (Dikin ellipsoid). The Dikin ellipsoid of radius r centered at a point x is defined as E r (x) {y | y -x ∇ 2 f (x) ≤ r} One of the key properties of self-concordant functions that we use is that inside the Dikin ellipsoid, the function is well conditioned with respect to the local norm at the center. The next lemma makes this formal. The proof of this lemma can be found in [55] . Lemma 10.3 (See [55] ). For all h such that h x < 1 we have that (1 -h x ) 2 ∇ 2 f (x) ∇ 2 f (x + h) 1 (1 -h x ) 2 ∇ 2 f (x) Another key quantity, which is used both as a potential function as well as a dampening for the step size in the analysis of Newton's method, is the Newton Decrement: λ x ∇f (x) * x = ∇f (x) ∇ -2 f (x)∇f (x). The following lemma quantifies how λ x behaves as a potential by showing that once it drops below 1, it ensures that the minimum of the function lies in the current Dikin ellipsoid. This is the property which we use crucially in our analysis. The proof can be found in [55] . Lemma 10.4 (See [55] ). If λ x < 1 then x -x * x ≤ λ x 1 -λ x 10. Newton's method for self-concordant functions Before introducing the linear time second order methods, we start by introducing a robust Newton's method and its properties. The pseudo-code is given in Algorithm 14. The usual analysis of Newton's method allows for quadratic convergence, i.e. error ε in O(log log 1 ε ) iterations for convex objectives. However, we prefer to present a version of Newton's method which is robust to certain random estimators of the Newton direction. This yields a slower rate of O(log 1 ε ). The faster running time per iteration, which does not require matrix manipulations, more than makes up for this. Algorithm 14 Robust Newton's method Input: T, x 1 for t = 1 to T do Set c = 1 8 , η = min{c, c 8λx t }. Let 1 2 ∇ -2 f (x t ) ∇-2 t 2∇ -2 f (x t ). x t+1 = x t -η ∇-2 t ∇f (x t ) end for return x T +1 It is important to notice that every two consecutive points are within the same Dikin ellipsoid of radius 1  2 . Denote ∇ t = ∇ xt , and similarly for the Hessian. Then we have: x t -x t+1 2 xt = η 2 ∇ t ∇-2 t ∇ 2 t ∇-2 t ∇ t ≤ 4η 2 λ 2 t ≤ 1 2 . The advantage of Newton's method as applied to self-concordant functions is its linear convergence rate, as given in the following theorem. Theorem 10.5. Let f be self-concordant, and f (x 1 ) ≤ M , then h t = f (x t ) -f (x * ) ≤ O(M + log 1 ε ) The proof of this theorem is composed of two steps, according to the magnitude of the Newton decrement. Phase 1: damped Newton Lemma 10.6. As long as λ x ≥ 1 8 , we have that h t ≤ - 1 4 c NEWTON'S METHOD FOR SELF-CONCORDANT FUNCTIONS99 Proof. Using similar analysis to the descent lemma we have that f (x t+1 ) -f (x t ) ≤ ∇ t (x t+1 -x t ) + 1 2 (x t -x t+1 ) ∇ 2 (ζ)(x t -x t+1 ) Taylor ≤ ∇ t (x t+1 -x t ) + 1 4 (x t -x t+1 ) ∇ 2 (x t )(x t -x t+1 ) x t+1 ∈ E 1/2 (x t ) = -η∇ t ∇-2 t ∇ t + 1 4 η 2 ∇ t ∇-2 t ∇ 2 t ∇-2 t ∇ t = -ηλ 2 t + 1 4 η 2 λ 2 t ≤ -1 16 c The conclusion from this step is that after O(M ) steps, Algorithm 14 reaches a point for which λ x ≤ 1 8 . According to Lemma 10.4, we also have that xx * x ≤ 1 4 , that is, the optimum is in the same Dikin ellipsoid as the current point. Phase 2: pure Newton In the second phase our step size is changed to be larger. In this case, we are guaranteed that the Newton decrement is less than one, and thus we know that the global optimum is in the same Dikin ellipsoid as the current point. In this ellipsoid, all Hessians are equivalent up to a factor of two, and thus Mirrored-Descent with the inverse Hessian as preconditioner becomes gradient descent. We make this formal below. Algorithm 15 Preconditioned Gradient Descent Input: P, T for t = 1 to T do x t+1 = x t -ηP -1 ∇f (x t ) end for return x T +1 Lemma 10.7. Suppose that 1  2 P ∇ 2 f (x) 2P , and x 1 -x * P ≤ 1 2 , then Algorithm 15 converges as h t+1 ≤ h 1 e -1 8 t . This theorem follows from noticing that the function g(z) = f (P -1/2 x) is 1  2 -strongly convex and 2-smooth, and using Theorem 3.2. It can be shown that gradient descent on g is equivalent to Newton's method in f . Details are left as an exercise. An immediate corollary is that Newton's method converges at a rate of O(log 1 ε ) in this phase. Linear-time second-order methods Newton's algorithm is of foundational importance in the study of mathematical programming in general. A major application are interior point methods for convex optimization, which are the most important polynomial-time algorithms for general constrained convex optimization. However, the main downside of this method is the need to maintain and manipulate matrices -namely the Hessians. This is completely impractical for machine learning applications in which the dimension is huge. Another significant downside is the non-robust nature of the algorithm, which makes applying it in stochastic environments challenging. In this section we show how to apply Newton's method to machine learning problems. This involves relatively new developments that allow for linear-time per-iteration complexity, similar to SGD, and theoretically superior running times. At the time of writing, however, these methods are practical only for convex optimization, and have not shown superior performance on optimization tasks involving deep neural networks. The first step to developing a linear time Newton's method is an efficient stochastic estimator for the Newton direction, and the Hessian inverse. Estimators for the Hessian Inverse The key idea underlying the construction is the following well known fact about the Taylor series expansion of the matrix inverse. Lemma 10.8. For a matrix A ∈ R d×d such that A 0 and A ≤ 1, we have that A -1 = ∞ i=0 (I -A) i We propose two unbiased estimators based on the above series. To define the first estimator pick a probability distribution over non-negative integers {p i } and sample î from the above distribution. Let X 1 , . . . X î be independent samples of the Hessian ∇ 2 f and define the estimator as Definition 10.9 (Estimator 1). ∇-2 f = 1 p î î j=1 (I -X j ) LINEAR-TIME SECOND-ORDER METHODS Observe that our estimator of the Hessian inverse is unbiased, i.e. E[ X] = ∇ -2 f at any point. Estimator 1 has the disadvantage that in a single sample it incorporates only one term of the Taylor series. The second estimator below is based on the observation that the above series has the following succinct recursive definition, and is more efficient. For a matrix A define A -1 j = j i=0 (I -A) i i.e. the first j terms of the above Taylor expansion. It is easy to see that the following recursion holds for A -1 j A -1 j = I + (I -A)A -1 j-1 Using the above recursive formulation, we now describe an unbiased estimator of ∇ -2 f by deriving an unbiased estimator ∇-2 f j for ∇ -2 f j . Definition 10.10 (Estimator 2). Given j independent and unbiased samples {X 1 . . . X j } of the hessian ∇ 2 f . Define { ∇-2 f 0 . . . ∇-2 f j } recursively as follows ∇-2 f 0 = I ∇-2 f t = I + (I -X j ) ∇-2 f t-1 It can be readily seen that E[ ∇-2 f j ] = ∇ -2 f j and therefore E[ ∇-2 f j ] → ∇ -2 f as j → ∞ giving us an unbiased estimator in the limit. Incorporating the estimator Both of the above estimators can be computed using only Hessian-vector products, rather than matrix manipulations. For many machine learning problems, Hessian-vector products can be computed in linear time. Examples include: 1. Convex regression and SVM objectives over training data have the form min w f (w) = E i [ℓ(w x i )], where ℓ is a convex function. The Hessian can thus be written as ∇ 2 f (w) = E i [ℓ (w x i )x i x i ] Thus, the first Newton direction estimator can now be written as ∇2 f (w)∇ w = E j∼D [ j i=1 (I -ℓ (w x i )x i x i )]∇ w . Notice that this estimator can be computed using j vector-vector products if the ordinal j was randomly chosen. 2. Non-convex optimization over neural networks: a similar derivation as above shows that the estimator can be computed only using Hessianvector products. The special structure of neural networks allow this computation in a constant number of backpropagation steps, i.e. linear time in the network size, this is called the \"Pearlmutter trick\", see [61] . We note that non-convex optimization presents special challenges for second order methods, since the Hessian need not be positive semidefinite. Nevertheless, the techniques presented hereby can still be used to provide theoretical speedups for second order methods over first order methods in terms of convergence to local minima. The details are beyond our scope, and can be found in [2] . Putting everything together. These estimators we have studied can be used to create unbiased estimators to the Newton direction of the form ∇-2 x ∇ x for ∇-2 x which satisfies 1 2 ∇ -2 f (x t ) ∇-2 t 2∇ -2 f (x t ). These can be incorporated into Algorithm 14, which we proved is capable of obtaining fast convergence with approximate Newton directions of this form. 1. The search space is often discrete (for example, number of layers). As such, there is no natural notion of gradient or differentials and it is not clear how to apply the iterative methods we have studied thus far. 2. Even evaluating the objective function is extremely expensive (think of evaluating the test error of the trained neural network). Thus it is crucial to minimize the number of function evaluations, whereas other computations are significantly less expensive. 3. Evaluating the function can be done in parallel. As an example, training feedforward deep neural networks over different architectures can be done in parallel. More formally, we consider the following optimization problem min x i ∈GF (q i ) f (x), where x is the representation of discrete hyperparameters, each taking value from q i ≥ 2 possible discrete values and thus in GF (q), the Galois field of order q. The example to keep in mind is that the objective f (x) is the test error of the neural network trained with hyperparameters x. Note that x has a search space of size i q i ≥ 2 n , exponentially large in the number of different hyperparameters. Hyperparameter optimization algorithms The properties of the problem mentioned before prohibits the use of the algorithms we have studied thus far, which are all suitable for continuous optimization. A naive method is to perform a grid search over all hyperparameters, but this quickly becomes infeasible. An emerging field of research in recent years, called AutoML, aims to choose hyperparameters automatically. The following techniques are in common use: • Grid search, try all possible assignments of hyperparameters and return the best. This becomes infeasible very quickly with n -the number of hyperparameters. • Random search, where one randomly picks some choices of hyperparameters, evaluates their function objective, and chooses the one choice of hyperparameters giving best performance. An advantage of this method is that it is easy to implement in parallel. • Successive Halving and Hyperband, random search combined with early stopping using multi-armed bandit techniques. These gain a small constant factor improvement over random search. • Bayesian optimization, a statistical approach which has a prior over the objective and tries to iteratively pick an evaluation point which reduces the variance in objective value. Finally it picks the point that attains the lowest objective objective with highest confidence. This approach is sequential in nature and thus difficult to parallelize. Another important question is how to choose a good prior. The hyperparameter optimization problem is essentially a combinatorial optimization problem with exponentially large search space. Without further assumptions, this optimization problem is information-theoretically hard. Such assumptions are explored in the next section with an accompanying algorithm. Finally, we note that a simple but hard-to-beat benchmark is random search with double budget. That is, compare the performance of a method to that of random search, but allow random search double the query budget of your own method. A Spectral Method For simplicity, in this section we consider the case in which hyperparameters are binary. This retains the difficulty of the setting, but makes the mathematical derivation simpler. The optimization problem now becomes min x∈{-1,1} n f (x). (11.1) The method we describe in this section is inspired by the following key observation: although the whole search space of hyperparameters is exponentially large, it is often the case in practice that only a few hyperparameters together play a significant role in the performance of a deep neural network. To make this intuition more precise, we need some definitions and facts from Fourier analysis of Boolean functions. where d is the upper bound of polynomial degree, and k is the sparsity of Fourier coefficient α α α (indexed by S) in ℓ 1 sense (which is a convex relaxation of α α α 0 , the true sparsity). Remark 11.3. Clearly this assumption does not always hold. For example, many deep reinforcement learning algorithms nowadays rely heavily on the choice of the random seed, which can also be seen as a hyperparameter. If x ∈ {-1, 1} 32 is the bit representation of a int32 random seed, then there is no reason to assume that a few of these bits should play a more significant role than the others. Under this assumption, all we need to do now is to find out the few important sets of variables S's, as well as their coefficients α S 's, in the approximation (11.2). Fortunately, there is already a whole area of research, called compressed sensing, that aims to recover a high-dimensional but sparse vector, using only a few linear measurements. Next, we will briefly introduce the problem of compressed sensing, and one useful result from the literature. After that, we will introduce the Harmonica algorithm, which applies compressed sensing techniques to solve the hyperparameter optimization problem (11.1). Background: Compressed Sensing The problem of compressed sensing is as follows. Suppose there is a hidden signal x ∈ R n that we cannot observe. In order to recover x, we design a measurement matrix A ∈ R m×n , and obtain noisy linear measurements y = Ax + η η η ∈ R m , where η η η is some random noise. The difficulty arises when we have a limited budget for measurements, i.e. m n. Note that even without noise, recovering x is non-trivial since y = Ax is an underdetermined linear system, therefore if there is one solution x that solves this linear system, there will be infinitely many solutions. The key to this problem is to assume that x is k-sparse, that is, x 0 ≤ k. This assumption has been justified in various real-world applications; for example, natural images tend to be sparse in the Fourier/wavelet domain, a property which forms the bases of many image compression algorithms. Under the assumption of sparsity, the natural way to recover x is to solve a least squares problem, subject to some sparsity constraint x 0 ≤ k. However, ℓ 0 norm is difficult to handle, and it is often replaced by ℓ 1 norm, its convex relaxation. One useful result from the literature of compressed sensing is the following. Proposition 11.4 (Informal statement of Theorem 4.4 in [63] ). Assume the ground-truth signal x ∈ R n is k-sparse. Then, with high probability, using a randomly designed A ∈ R m×n that is \"near-orthogonal\" (random Gaussian matrix, subsampled Fourier basis, etc.), with m = O(k log(n)/ε) and η η η This result is remarkable; in particular, it says that the number of measurements needed to recover a sparse signal is independent of the dimension n (up to a logarithm term), but only depends on the sparsity k and the desired accuracy ε. The Spectral Algorithm The main idea is that, under Assumption 11.2, we can view the problem of hyperparameter optimization as recovering the sparse signal α α α from linear measurements. More specifically, we need to query T random samples, f (x 1 ), . . . , f (x T ), and then solve the LASSO problem min α α α T t=1 ( |S|≤d α S χS (x t ) -f (x t )) 2 + λ α α α 1 , (11.4) where the regularization term λ α α α 1 controls the sparsity of α α α. Also note that the constraint |S| ≤ d not only implies that the solution is a low-degree polynomial, but also helps to reduce the \"effective\" dimension of α α α from α S i χS i (x), which involves only a few dimensions of x since the LASSO solution is sparse and low-degree. The next step is to set the variables outside ∪ i∈[s] S i to arbitrary values, and compute a minimizer x * ∈ arg min g(x). In other words, we have reduced the original problem of optimizing f (x) over n variables, to the problem of optimizing g(x) (an approximation of f (x)) over only a few variables (which is now feasible to solve). One remarkable feature of this algorithm is that the returned solution x * may not belong to the samples {x 1 , . . . , x T }, which is not the case for other existing methods (such as random search). Using theoretical results from compressed sensing (e.g. Proposition 11.4), we can derive the following guarantee for the sparse recovery of α α α via LASSO. Theorem 11.6 (Informal statement of Lemma 7 in [38] ). Assume f is ksparse in the Fourier expansion. Then, with T = O(k 2 log(n)/ε) samples, the solution of the LASSO problem (11.4) achieves ε accuracy. Finally, the above derivation can be considered as only one stage in a multi-stage process, each iteratively setting the value of a few more variables that are the most significant. Bibliographic Remarks For a nice exposition on hyperparameter optimization see [64, 65] , in which the the benchmark of comparing to Random Search with double queries was proposed. Perhaps the simplest approach to HPO is random sampling of different choices of parameters and picking the best amongst the chosen evaluations [9] . Successive Halving (SH) algorithm was introduced [43] . Hyperband further improves SH by automatically tuning the hyperparameters in SH [51] . The Bayesian optimization (BO) methodology is currently the most studied in HPO. For recent studies and algorithms of this flavor see [10, 78, 81, 79, 24, 84, 40] . The spectral approach for hyperparameter optimization was introduced in [38] . For an in-depth treatment of compressed sensing see the survey of [63] , and for Fourier analysis of Boolean functions see [59] . Figure 1 : 1 Figure 1: Professor Arkadi Nemirovski, Pioneer of mathematical optimization Figure 2 . 1 : 21 Figure 2.1: Pythagorean theorem. Theorem 2 . 1 ( 21 Pythagoras, circa 500 BC). Let K ⊆ R d be a convex set, y ∈ R d and x = ΠK(y). Then for any z ∈ K we have yz ≥ xz . Theorem 2 . 2 ( 22 Karush-Kuhn-Tucker). Let K ⊆ R d be a convex set, x ∈ arg min x∈K f (x). Then for any y ∈ K we have ∇f (x ) (y -x ) ≥ 0. Figure 2 . 2 : 22 Figure 2.2: Optimality conditions: negative (sub)gradient pointing outwards. Figure 2 . 3 : 23 Figure 2.3: First and second-order local optima. Lemma 3 . 1 ( 31 Backpropagation lemma). The gradient of f can be computed in time O(|E|). 2 . 3 . 23 Given an ERM problem (a.k.a. learning from examples, see first chapter), what can we say about generalization to unseen examples? How does it affect optimization? Are there faster algorithms than SGD in the context of ML? 0 1 Figure 4 . 1 : 141 Figure 4.1: Intractability of nonsmooth optimization Theorem 4 . 2 . 42 Online gradient descent with step sizes {η t = D G √ t , t ∈ [T ]} guarantees the following for all T ≥ 1: Figure 4 . 2 : 42 Figure 4.2: Online gradient descent: the iterate x t+1 is derived by advancing x t in the direction of the current gradient ∇ t , and projecting back into K. Algorithm 4 online gradient descent 1: Input: convex set K, T , x 1 ∈ K, step sizes {η t } 2: for t = 1 to T do 3: 2 : 2 Let x 1 = arg min x∈K {R(x)}. 3: for t = 1 to T do 4: Theorem 6 . 3 . 63 Let {x t } be defined by Algorithm 9 with parameters η = D, where D = max u∈K ux 1 2 . Theorem 8 . 1 . 81 Algorithm 12 converges to an ε-approximate solution to optimization problem (8.1) in O( 1 √ ε ) iterations. The proof starts with the following lemma which follows from our earlier standard derivations. Lemma 8.2. Figure 9 . 1 : 91 Figure 9.1: Direction of progression of the conditional gradient algorithm. Fact 11 . 1 .Assumption 11 . 2 . 111112 Any function f : {-1, 1} n → [-1, 1] can be uniquely represented in the Fourier basisf (x) = S⊆[n] α s χS (x),where each Fourier basis functionχS (x) = i∈S x i .is a monomial, and thus f (x) has a polynomial representation.Now we are ready to formalize our key observation in the following assumption:The objective function f in the hyperparameter optimization problem (11.1) is low degree and sparse in the Fourier basis, i.e.f (x) ≈ |S|≤d α S χS (x), α α α 1 ≤ k,(11.2) 2 = O( √ m),x can be recovered by a convex programmin z∈R n y -Az 2 2 s.t. z 1 ≤ k,(11.3)with accuracy xz 2 ≤ ε. 1 Remark 11 . 5 . 2 + λ z 1 , 111521 The convex program(11.3) is equivalent to the following LASSO problemmin z∈R n y -Az 2with a proper choice of regularization parameter λ. The LASSO problem is an unconstrained convex program, and has efficient solvers, as per the algorithms we have studied in this course. 2 n to O(n d ), which makes it feasible to solve this LASSO problem. Denote by S 1 , . . . , S s the indices of the s largest coefficients of the LASSO solution, and define g(x) = i∈[s] It also depends on the desired high-probability bound, which is omitted in this informal statement."
}