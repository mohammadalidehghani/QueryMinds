{
  "title": "Some Insights into Lifelong Reinforcement Learning Systems",
  "abstract": "A lifelong reinforcement learning system is a learning system that has the ability to learn through trail-and-error interaction with the environment over its lifetime. In this paper, I give some arguments to show that the traditional reinforcement learning paradigm fails to model this type of learning system. Some insights into lifelong reinforcement learning are provided, along with a simplistic prototype lifelong reinforcement learning system.",
  "introduction": "Introduction An agent is an abstraction of a decision-maker. At each time instance t, it receives an observation o t ∈ O, and outputs an action a t ∈ A to be carried out in the environment it lives in. Here, O is the (finite) set of possible observations the agent can receive, and A is the (finite) set of actions the agent can choose from. An agent's observation o t depends on the current environment state s t ∈ S through an agent observation function S → O, where S is the set of possible environment states. The observation history h o t = (o 1 , o 2 ..., o t ) is the sequence of observations the agent has received till time t. Let H o t be the set of possible observation histories of length t, the policy π t : H o t → A at time t is defined as the mapping from an observation history of length t to the action the agent will take. An agent's behavior can thus be fully specified by its policy across all timesteps π = (π 1 , π 2 , ..., π t , ...). Throughout the paper, it is assumed that an agent has a finite lifespan T .",
  "body": "Introduction An agent is an abstraction of a decision-maker. At each time instance t, it receives an observation o t ∈ O, and outputs an action a t ∈ A to be carried out in the environment it lives in. Here, O is the (finite) set of possible observations the agent can receive, and A is the (finite) set of actions the agent can choose from. An agent's observation o t depends on the current environment state s t ∈ S through an agent observation function S → O, where S is the set of possible environment states. The observation history h o t = (o 1 , o 2 ..., o t ) is the sequence of observations the agent has received till time t. Let H o t be the set of possible observation histories of length t, the policy π t : H o t → A at time t is defined as the mapping from an observation history of length t to the action the agent will take. An agent's behavior can thus be fully specified by its policy across all timesteps π = (π 1 , π 2 , ..., π t , ...). Throughout the paper, it is assumed that an agent has a finite lifespan T . Scalar Reward Reinforcement Learning System We are interested in agents that can achieve some goal. In reinforcement learning, a goal is expressed by a scalar signal r t ∈ R called the reward. The reward is dependent on the agent's observation history, and is assumed to be available to the agent at each timestep in addition to the observation o t . Our aim is to find policies that maximize the expected cumulative reward an agent receives over its lifetime: max π E[ T t=1 r t (h o t )] (1) Using the maximization of expected cumulative scalar reward to formulate the general notion of goal is a design choice in reinforcement learning, based on what is commonly known as the reward hypothesis (Sutton & Barto, 2018) , In Sutton's own words: That all of what we mean by goals and purposes can be well thought of as the maximization of the expected value of the cumulative sum of a received scalar signal (called reward). This design choice, however, is somewhat arbitrary. Among other things, the reward needs not be a scalar (e.g. multiobjective reinforcement learning (White, 1982) ), nor does it have to be a quantity whose cumulative sum is to be maximized (which we will come to shortly). Leaving aside the question of whether or not all goals can be formulated by Eq. 1, I intend to show in this paper that the problem of lifelong reinforcement learning probably should not be formulated as such. Note that in Eq. 1, I defined the reward in terms of the observation history, instead of the history of environment states as in most reinforcement learning literature. This reflects the view that reward signals are internal to the agent, as pointed out by Singh et al. (2004) in their work on intrinsic motivation. Since the observations are all that the agent has access to from the external environment, the intrinsic reward should depend on the environment state only through the agent's observation history. Although the above reinforcement learning formulation recognizes the reward as a signal intrinsic to an agent, it focuses on learning across different generations 1 of agents, as opposed to learning within an agent's lifespan. From an agent's point of view, the cumulative reward is known only when it reaches its end of life, by which time no learning can Figure 1 : Architecture of a traditional reinforcement learning system. At the beginning of an agent's life, it receives a policy π i = (π i 1 , π i 2 , ...π i T ) from the learning algorithm that carries out a mix of exploitation and exploration, where the superscript i indicates that the agent belongs to the ith generation. The agent receives an observation o t at each timestep t, and act according to π i t . At the end of the agent's life, the learning algorithm gathers the observation history h o T and the cumulative reward T t=1 r(h o t ) from the agent, and outputs the the next policy π i+1 to be executed. The learning algorithm does not need to optimize the performance of any particular π i , as long as it is guaranteed to be able to eventually find the policies that maximize the expected cumulative reward. be done by the 'dying' agent itself. The individual reward received at each timestep does not really matter, since the optimization objective is the cumulative sum (of reward). The information gathered by the agent, however, can be used to improve the policy of the next generation. In other words, with the conventional reinforcement learning formulation, learning can only happen at a level higher than the lives of individual agents (Figure 1 ), with the goal that an optimal agent can eventually be found -the lifetime behavior of a particular agent is not of concern. Towards Lifelong Reinforcement Learning In lifelong reinforcement learning, on the other hand, the focus is the agent's ability to learn and adapt to the environment throughout its lifetime. Intuitively, this implies that learning component of the learning system should reside within the agent. To shed some lights on lifelong reinforcement learning, consider the Q-learning (Watkins & Dayan, 1992) algorithm for the standard reinforcement learning problem formulated by Eq. 1. For the purpose of this example only, it is further assumed that: • The reward depends only on the current observation. I.e., r(h o t ) = r(o t ) • Observations are Markov with respect to past observations and actions. I.e., P (o t |o t-1 , a t-1 , ..., o 1 , a 1 ) = P (o t |o t-1 , a t-1 ) These assumptions are only made so that Q-learning will find the solution to Eq. 1, and are not essential for the general discussion. The (non-lifelong) learning system works as follows: 1. The agent receives its initial Q estimate from the past generation. 2. At each timestep t, the agent takes an -greedy action based on the current Q estimate, then does a Bellman update on the Q estimate: Q(o t , a t ) := Q(o t , a t ) + α(r(o t ) + max a Q(o t+1 , a) -Q(o t , a t )) (2) 3. When the agent dies, pass the updated Q estimate to the next generation. At first sight, the fact that the Q estimate is updated every timestep seems to contradict my argument that learning only happens across generations. However, for Eq. 2 to be a valid update, the timestep t needs to be part of the observation -the observation o t here is in fact the raw observation o - t augmented by time t, i.e., o t = (o - t , t). Since the timestep is part of the observation, no same observation will be experienced more than once throughout the agent's lifetime, and it makes no difference to the agent whether the Q estimate is updated every timestep, or after its life ends foot_2 . It's clear that for an agent to exhibit any sensible behavior, the initial Q estimate it inherits from the past generation is vital. If the agent receives a random initial Q estimate, then it's lifelong behavior is bound to be random and meaningless. On the other side of the spectrum, if the agent receives the true Q function, then it will behave optimally. This suggests that if we care about the lifetime behaviour (which includes lifelong learning behavior) of a Q-learning agent, then Q(o t , •) is a fundamental signal the agent needs to receive in addition to the scalar reward. In a sense, if the signal represented by the scalar reward is a specification of what the goal is, then the signal represented by the Q estimate is the knowledge past generations have collected about what the goal means for this type of agent. As an analogy, the pain associated with falling to the ground could be the former signal, while the innate fear of height could be the latter. From a computational perspective, the separation of these two signals may not be necessary. Both signals can be considered as 'annotations' for the observation history that the agent receives along with its observation, and can be incorporated into the concept of reward. The reward signals are no longer restricted scalars, nor are they necessarily quantities whose cumulative sum is to be maximized -they are just messages in some reward language that 'encode' the knowledge pertaining to an agent's observation history -knowledge that enables the agent to learn continuously throughout its life. Such knowledge may include the goals of the agent, the subgoals that constitute these goals, the heuristics for achieving them, and so on. The reward is then 'decoded' by the learning algorithm, which defines how the agent responds to the reward given the observation history. The learning system should be designed such that by responding to the reward in its intended way, the agent will learn to achieve the goals implied by the reward before its end of life (Figure 2 ). To be precise, the reward r(h o t ) ∈ Σ now belongs to some reward space Σ. The learning algorithm is a mapping from reward histories to policies. Denoting the set of possible reward history of length t as H r t , and the set of all possible policies at time t as Π t , the learning algorithm m can be represented by m = (m 1 , m 2 , ..., m t , ..., m T ), where m t : H r t → Π t . The formulation is general, and a learning system formulated as such is not automatically a lifelong learning system. In fact, it subsumes traditional reinforcement learning: the reward space is set to the real numbers (Σ = R), and the learning algorithm can be set to any algorithm that converges to a policy that maximizes the expected cumulative reward. Unfortunately, the reward in traditional reinforcement learning does not contain enough information for an agent to learn within its lifetime. Viewing the reward as a general language, and the learning algorithm as the response to the reward opens up the possibilities for principled ways to embed learning bias such as guidance and intrinsic motivation into the learning system, instead of relying solely on manipulating the scalar reward on an ad-hoc basis. In the rest of the paper, my focus remains on lifelong reinforcement learning, more specifically, what lifelong reinforcement learning requires of the reward language and the corresponding learning algorithm. Reward as Formal Language Although the term 'language' used above can be understood in its colloquial sense, it can also be understood as the formal term in automata theory. To see this, consider the following deterministic finite automaton Σ, Q, δ, q 0 , F , where: • Σ is the alphabet of the automaton, and is set to the reward space of the learning system. In other words, Figure 2 : Architecture of lifelong reinforcement learning system. In contrast to traditional reinforcement learning (Figure 1 ), the learning algorithm resides inside the agent. The internal environment of the agent can be thought of as a built-in mechanism for the agent-designer to communicate with the agent (through the reward). At each timestep, the learning algorithm receives some message (encoded in the form of reward r(h o t )) from the agent's internal environment, and outputs a policy π t as a response. the alphabet of this automaton consists of all possible reward the agent can receive at any single timestep. A string is a sequence of symbols chosen from some alphabet. For this particular automaton, a string is in fact a sequence of reward, so the notation for reward history h r t is also used to denote a string of length t. The set of all strings of length k over Σ is denoted as Σ k , and the set of all strings (of any length) is denoted as Σ * . • Q is the set of states of the automaton. Each state of this automaton is a possible pair of reward history and policies till some timestep t. For example, members of Q include: h r t=1 , (π 1 ) h r t=2 , (π 1 , π 2 ) ... h r t=T , (π 1 , π 2 , ..., π T ) for any π 1 ∈ Π 1 , π 2 ∈ Π 2 , ..., π T ∈ Π T , and h r t=1 ∈ Σ 1 , h r t=2 ∈ Σ 2 , ..., h r t=T ∈ Σ T . In addition, Q has a special 'empty' member q 0 , which corresponds to the initial state before any reward is received. • δ : (Q × Σ) → Q is the transition function. The transition function corresponds to the learning algorithm of the learning system, so we have δ( h r t , (π 1 , ..., π t ) , r t+1 ) = h r t+1 , (π 1 , ..., π t , m t+1 (h r t+1 )) , where h r t+1 = (h r t , r t+1 ). • q 0 is the initial state of the automaton as explained above. • F ⊂ Q is the set of accepting states, which are the desired states of the automaton. It's not hard to see that this automaton is a model of the learning system described in Section 1.2, with its desired property specified by the accepting states F . In this paper, the desired property is that the system be a lifelong learning system, so the accepting states F are the set of h r T , (π 1 , π 2 , ..., π T ) pairs that correspond to a lifelong learner 3 . To specify learning objectives, each possible reward r ∈ Σ is assigned some semantics. These semantics implicitly define the set of valid reward sequences L ⊂ Σ * . Since L is a subset of Σ * , it is a language over Σ. We want to make sure that -for all reward sequences in L, lifelong learning can be achieved by the learning system abstracted by this automaton, or equivalently, all reward sequences in L lead to accepting states F . A Prototype Lifelong Reinforcement Learning System Designing a lifelong reinforcement learning system involves designing the reward language and the learning algorithm holistically. Intuitively, the reward needs to contain enough information to control the relevant aspects of the learning algorithm, and the learning algorithm in turn needs to 'interpret' the reward signal in its intended way. In this section, I aim to provide some insights into the design process with a prototype lifelong reinforcement learning system. Reward Language The main reason lifelong learning is impossible in conventional reinforcement learning is that the learning objective in conventional reinforcement learning is global, in the sense that the goal of the agent is defined in terms of the observation history of its entire life. For a lifelong reinforcement learning agent, the learning objectives should instead be local, meaning that the goals should be defined only for some smaller tasks that the agent can encounter multiple times during its lifetime. Once a local goal expires, whether it is because the goal has been achieved or because the agent has failed to achieve it within a certain time limit, a new local goal (can potentially be another instantiation of the same goal) ensues. This way, the agent has the opportunity to gather knowledge for each of the goals, and improve upon 3 Recall that an agent's behavior is fully decided by its policy π = (π1, π2, ..., πT ). Therefore given a reward history h r T , the policy is sufficient for us to tell whether the agent is a successful lifelong learner. them, all within one life. Local goals like this are ubiquitous for humans. For example, when a person is hungry, his main concern is probably not the global goal of being happy for the rest of his life -his goal is to have food. After the person is full, he might feel like taking a nap, which is another local goal. In fact, the local goals and the transition of them seems to embody what we mean by intrinsic motivation. To be able to specify a series of local goals, the reward in this prototype learning system has two parts: the reward state r s t ∈ G, and the reward value r v t ∈ R, where G is the set of local goals the agent may have. This form of reward is inspired by the reward machine (Icarte et al., 2018) , a Mealy machine for specifying history-dependent reward, but the semantics we assign to the reward will be different. Also note that this Mealy machine bears no relation to the automaton we discussed in Section 1.3 -the reward machine models the reward, while the automaton in Section 1.3 models the learning system, and takes the reward as input. Each reward state r s corresponds to a local goal. When a local goal (or equivalently, a reward state) expires, the agent receives a numerical reward value r v . For all other timesteps (other than the expiration of local goals), the reward value can be considered to take a special NULL value, meaning that no reward value is received. The reward value is an evaluation of the agent's performance in an episode of a reward state, where an episode of a reward state is defined as the time period between the expiration of the previous reward state (exclusive) and the expiration of the reward state itself (inclusive). The reward state can potentially depend on the entire observation history, while the reward value can only depend on the observation history of the episode it is assessing. Overall, the reward is specified by (r s t , r v t ) = r(h o t ). The local goals described here are technically similar to subgoals in hierarchical reinforcement learning (Dietterich, 2000; Sutton et al., 1999; Parr & Russell, 1997) . However, the term 'subgoal' suggests that there is some higher-level goal that the agent needs to achieve, and that the higher-level goal is the true objective the agent needs to optimize. That is not the case here -although it is totally possible that the local goals are designed in such a way that some global goal can be achieved, the agent only needs to optimize the local goals. The reward language in this prototype system makes two assumptions on the learning algorithm. As long as the two assumptions are met, the learning algorithm is considered to 'interpret' the reward correctly. The first assumption is that the learning algorithm only generates policies that are episode-wise stationary, meaning that π t1 = π t2 for any timesteps t 1 and t 2 in the same episode of a reward state, and that π t1 : O → A. This assumption is not particularly restrictive, because in cases where a local goal requires a more complex policy, we can always split the goal into mul-tiple goals (by modifying the reward function) for which the policies are episode-wise stationary. With this assumption, we can use a single policy π r s : O → A to represent the policies at all timesteps within an episode of reward state r s . The second assumption is that the learning algorithm keeps a pool of 'elite' policies for each reward state: a policy that led to high reward value in some episode has the opportunity to enter the pool, and a policy that consistently leads to higher reward value eventually dominates the policy pool. The exact criterion for selection into the pool (e.g., to use the expected reward value as the criterion, or to use the probability of the reward value being higher than a certain threshold, etc.) is not enforced, and is left up to the learning algorithm. Learning Algorithm The learning algorithm in this prototype lifelong learning system is an evolutionary algorithm, adjusted to meet the assumptions made by the reward. The algorithm maintains a policy pool D r s of maximum size d for each reward state r s ∈ G. Each item in the pool is a two tuple π, r v π where π is a policy and r v π is the reward value of the last episode in which π was executed. Conceptually, the algorithm consists of three steps: policy generation, policy execution, and (policy) pool update, which are described below. POLICY GENERATION When an episode of reward state r s starts, a policy π r s is generated from one of the following methods with probability p 1 , p 2 , p 3 , respectively: 1. Randomly sample a policy from the policy pool D r s , and mutate the policy. 2. Randomly sample a policy from D r s and keep it as is. Remove the sampled policy from D r s . This is to re-evaluate a policy in the pool. Since the transition of observations might be stochastic, the same policy does not necessarily always result in the same reward value. 3. Randomly generate a new policy π r s : O → A from scratch. This is to keep the diversity of the policy pool. p 1 , p 2 and p 3 should sum up to 1, and are hyper-parameters of the algorithm. POLICY EXECUTION Execute the generated policy π r s until a numerical reward value r v is received. POOL UPDATE If the policy pool is not full, insert π r s , r v into the pool. Otherwise compare r v with the minimum reward value in the pool. If r v is greater than or equal to the minimum reward value, replace the policy and reward value pair (that has the minimum reward value) with π r s , r v . Embedding Learning Bias Learning bias in reinforcement learning systems refers to the explicit or implicit assumptions made by the learning algorithm about the policy. Our assumption that the policy is episode-wise stationary is an example of learning bias. Arguably, a good learning bias is as important as a good learning algorithm, therefore it is important that mechanisms are provided to embed learning bias into the learning system. A straight-forward way to embed learning bias into the above lifelong learning system is through the policy generation process. This includes how existing policies are mutated, and what distribution new policies are sampled from. The learning bias provided this way does not depend on the agent's observation and reward history, and is sometimes implicit (e.g., the learning bias introduced by using a neural network of particular architecture). Another type of learning bias common in reinforcement learning is guidance, the essence of which can be illustrated by Figure 3 . Suppose in some reward state, the agent starts from observation o and the goal is to reach foot_3 observation o . Prior knowledge indicates that to reach o , visiting o is a good heuristic, but reaching o itself has little or no merit. In other words, we would like to encourage the agent to visit and explore around o more frequently (than other parts of the observation space) until a reliable policy to reach o is found. To provide guidance to the agent in the prototype lifelong learning system, we can utilize the property of the learning algorithm that policies leading to high reward values will enter the policy pool. Once a policy enters the pool, it has the opportunity to be sampled (possibly with mutation) and executed. Therefore, we just need to assign a higher reward value for reaching o (before the expiration of the reward state) than reaching neither o nor o . Also important is the ability to control the extent to which region around o is explored. To achieve this, recall that the learning algorithm occasionally re-evaluates policies in the policy pool. If we assign a lower reward value for reaching o with some probability, we can prevent the Experiment Now we evaluate the behaviour of the prototype lifelong reinforcement learning system. The source code of the experiments can be found at https://gitlab.com/  lifelong-rl/lifelongRL_gridworld Environment Consider a gridworld agent whose life revolves around getting food and taking the food back home for consumption. The agent lives in a 11 by 11 gridworld shown in Figure 4 . The shaded areas are barriers that the agent cannot go through. Some potential positions of interest are marked with letters: F is the food source and is assumed to have infinite supply of food; H is the agent's home. To get to the food source from home, and to carry the food home, the agent must pass through one of the two tunnels -the tunnel on the left is marked with L and the tunnel on the right is marked with R. At each timestep, the agent observes its position in the gridworld as well as a signal indicating whether it is in one of the four positions of interest (if yes, which), and chooses from one of the four actions: UP, RIGHT, DOWN and LEFT. Each action deterministically takes the agent to the adjacent grid in the corresponding direction, unless the destination is a barrier, in which case the agent remains in its original position. The agent starts from home at the beginning of its life, and needs to go to the food source to get food. Once it reaches the food source, it needs to carry the food back home. This process repeats until the agent dies. The lifespan of the agent is assumed to be 100 million timesteps. The agent is supposed to learn to reliably achieve these two local goals within its lifetime. Figure 4 : Gridworld environment. Learning System Setup The reward state in this experiment is represented by the conjunction of Boolean variables. For example, if three Boolean variables A, B and C are defined, then the reward state would be in the form of r s = A ∧ B ∧ C or r s = A ∧ ¬B ∧ C, etc. At the bare minimum, one Boolean variable GET FOOD needs to be defined for this agent, where GET FOOD being true corresponds to the local goal of going to the food source, and ¬GET FOOD corresponds to the local goal of carrying the food home. The agent receives a reward value of +1 if GET FOOD is true and the agent reaches F, in which case the Boolean variable GET FOOD transitions to false. Similarly, the agent receives a reward value of +1 if ¬GET FOOD is true and the agent reaches H, in which case GET FOOD transitions to true. On top of GET FOOD, we define another Boolean variable TIMED OUT, which indicates whether the agent has exceeded a certain time limit for trying to get to the food source, or for trying to carry the food home. If the reward state is ¬TIMED OUT ∧ GET FOOD, and the agent fails to reach F within the time limit, itreceives a reward value of -1, and the reward state transition to TIMED OUT ∧ GET FOOD. From TIMED OUT ∧ GET FOOD, if the agent still fails to get to F within the time limit, it receives a reward value of 0. The agent will remain in TIMED OUT ∧ GET FOOD, until it reaches F, when the reward state transitions to ¬TIMED OUT ∧ ¬GET FOOD (and receive a +1 reward value as already mentioned). For the case when GET FOOD is false, the reward transition is defined similarly. Throughout the experiments, the time limit is set to 24, which is enough for the agent to accomplish any of the local goals. We refer to this reward design as the base case. Unfortunately, even for a toy problem like this, learning can be difficult if no proper learning bias is provided. Since there are 4 actions and 74 possible positions, the number of possible episode-wise stationary policies is 4 74 for each reward state. Among those policies, very few can achieve the local goals. If the policy generation and mutation is purely random, it will take a long time for the agent to find a good policy. BIASED POLICY The first learning bias we consider is biased policy, which is in contrast to the unbiased policy case where the policy generation and mutation is purely random. More specifically, we make the policy generation process biased towards policies that take the same action for similar observations. This would encourage policies that head consistently in one direction, and discourage those that indefinitely roam around between adjacent positions. PROGRESS-BASED GUIDANCE The second learning bias we consider is guidance based on the agent's progress. Different from the base case where the agent always receives a 0 (if TIMED OUT is true) or -1 (if TIMED OUT is false) reward value when it fails to achieve the local goal within the time limit, the agent now has some probability p = 0.8 of receiving a reward value proportional to the Manhattan distance d it has traveled since the beginning of the episode. To be precise: r v := 0.01d with probability p same as the base case with probability 1 -p This way, policies leading to more progress (albeit not necessary towards the local goal) will be encouraged. SUB-OPTIMAL GUIDANCE Finally, we consider a case of sub-optimal guidance that encourages the agent to explore a sub-optimal trajectory. As we have mentioned, both reaching the food source from home and carrying the food home require the agent to go through one of the two tunnels. However, if the agent goes through the left tunnel, it has to travel more distance. Suppose that we prefer the agent to take the shorter route, but we only know the route that goes through the left tunnel; and as a result, we sub-optimally encourage the agent to explore the left tunnel. To guide the agent to take the left tunnel, Boolean variable VISITED LEFT is introduced as an indicator of whether L has been visited since the last visitation of F or H. Now we have 2 3 = 9 elements in the reward space, corresponding to 9 possible local goals. The reward transition is different from the base case in that if the agent has already visited L when the local goal GET FOOD ∧ ¬TIMED OUT ∧ ¬VISITED LEFT or ¬GET FOOD ∧ ¬TIMED OUT ∧ ¬VISITED LEFT times out, VISITED LEFT becomes true, and the agent will receive a reward value of +0.6 with 0.8 probability, and -0.2 with 0.2 probability. To express our preference for the shorter route, the agent receives a reward value of +0.8 (instead of +1) when it reaches F (when GET FOOD is true) or H (when GET FOOD is false) through the left tunnel. Figure 5 shows the learning curves for reward state GET FOOD ∧ ¬TIMED OUT with progress-based guidance. The x-axis is the timesteps (in million), and the y-axis is the percentage of times the agent transitions into a particular next reward state starting from GET FOOD ∧ ¬TIMED OUT. A next reward state of ¬GET FOOD ∧ ¬TIMED OUT means that the agent successfully reached F within the time limit, and a next reward state of GET FOOD ∧ TIMED OUT means that the agent failed to do so. As we can see, with unbiased policy, it took the agent around 25 million timesteps to achieve 100% success rate; while with biased policy, this only took around 8 million timesteps. Results Figure 6 shows the learning curves for reward state GET FOOD ∧ ¬TIMED OUT ∧ ¬VISITED LEFT with the suboptimal guidance described in Section 3.2. Similar to Figure 5 , the x-axis is the timesteps (in million), and the yaxis is the percentage of times the agent transitioned into a particular next reward state starting from GET FOOD ∧  ¬TIMED OUT ∧ ¬VISITED LEFT. A next reward state of ¬GET FOOD ∧ ¬TIMED OUT ∧ ¬VISITED LEFT means that the agent successfully reached F within the time limit; a next reward state of GET FOOD ∧ TIMED OUT ∧ VISITED LEFT means that the agent failed to reach the food source, but was able to find a way to the left tunnel; and a next reward state of GET FOOD ∧ TIMED OUT ∧ ¬VISITED LEFT means that the agent was neither able to reach the left tunnel nor the food source within the time limit. As we can see, for both unbiased and biased policy, learning is much slower than progress-based guidance. This is likely due to the much sparser guidance signal -the agent receives guidance only when it reaches the left tunnel. For the unbiased policy case, 100% success rate was not achieved within 100 million timesteps, but we can clearly see that exploration around the left tunnel was encouraged as intended. For the biased policy case, the agent was able to reach 100% success rate after 50 million timesteps. But was the agent able to figure out the optimal route, or did it only learn to take the suboptimal route as guided? Recall that the agent receives a reward value of +1 if it takes the optimal route, and a reward value of +0.8 if it takes the sub-optimal route. As shown in Figure 7 , although the agent was taking the sub-optimal route by 50 million timesteps when it just learned to reach the food source reliably, it was eventually able to figure out the optimal route by 90 million timesteps. Conclusions Lifelong reinforcement learning is sometimes viewed as a multi-task reinforcement learning problem (Abel et al., 2018) , where the agent must learn to solve tasks sampled from some distribution D. The agent is expected to (explicitly or implicitly) discover the relation between tasks, and generalize its policy to unseen tasks from D. The focus is therefore on the transfer learning (Taylor & Stone, 2009) and continual learning (Ring, 1998) aspects of lifelong reinforcement learning. In this paper, I provided a systems view on lifelong reinforcement learning. In particular, I showed that the reward in a lifelong reinforcement learning system can be a general language, and that the language needs to be designed holistically with the learning algorithm. A prototype lifelong reinforcement learning system was given, with an emphasize on how learning bias can be embedded into the learning system through the synergy of the reward language and the learning algorithm. Figure 3 : 3 Figure 3: A simplistic abstraction of guidance in reinforcement learning. policy pool from being overwhelmed only by policies that lead to o . In other words, the reward value for reaching o should have multiple candidates. Let r v ({O -{o , o }}) denote the reward value for an episode where the agent reaches neither o nor o , r v (o ) denote the reward value for reaching o , we can set the reward value r v (o ) for reaching o as: r v (o ) := a, with probability p b, with probability 1 -p where b < r v ({O -{o , o }}) < a < r v (o ). The probability p controls the frequency region around o is to be explored compared the other parts of the observation space 5 . Figure 5: Learning curve for unbiased/biased policy with progress-based guidance, averaged over 20 runs. (a) unbiased policy, sub-optimal guidance (b) biased policy, sub-optimal guidance Figure 6 : 6 Figure 6: Learning curve for unbiased/biased policy with sub-optimal guidance, averaged over 20 runs. Figure 7 : 7 Figure 7: Reward value for GET FOOD ∧ ¬TIMED OUT ∧ ¬VISITED LEFT (biased policy with sub-optimal guidance, averaged over 20 runs). Department of Electrical and Computer Engineering, University of Waterloo, Canada. Correspondence to: Changjian Li <changjian.li@uwaterloo.ca>.Preliminary work. Under Review. Usage of the word 'generation' here is only to emphasize that learning cannot be achieved within an agent's lifespan, and does not imply that evolution algorithms need to be used. The statement does not strictly hold true if function approximation is used. An update to Q θ (ot, a) can potentially affect the Q estimate of all other observations. However, this is more a side effect than a desired property. For sake of terminological convenience, we pretend that the observations here are environment states. Note that the word 'probability' here should be interpreted as the 'long-run proportion', and therefore the reward value needs not be truly stochastic. E.g., we can imagine that the reward has a third component which is the state of a pseudo-random generator."
}