{
  "title": "Collaborative Machine Learning Markets with Data-Replication-Robust Payments",
  "abstract": "We study the problem of collaborative machine learning markets where multiple parties can achieve improved performance on their machine learning tasks by combining their training data. We discuss desired properties for these machine learning markets in terms of fair revenue distribution and potential threats, including data replication. We then instantiate a collaborative market for cases where parties share a common machine learning task and where parties' tasks are different. Our marketplace incentivizes parties to submit high quality training and true validation data. To this end, we introduce a novel payment division function that is robust-toreplication and customized output models that perform well only on requested machine learning tasks. In experiments, we validate the assumptions underlying our theoretical analysis and show that these are approximately satisfied for commonly used machine learning models.",
  "introduction": "Introduction One of the main obstacles for training well-performing machine learning models is the limited availability of sufficiently diverse labeled training data. However, the data needed to train good models often exists but is not easy to leverage as it is distributed and owned by multiple parties. For instance, in the medical domain, important data about patients that could be used for learning diagnostic support systems for cancer might be in possession of different hospitals, each of which holding different data, (e.g., from a specific geographical region with different demographics). Typically, by pooling the available data, the hospitals could train better machine learning models for their application than they could using only their own data. As all hospitals would benefit from a better machine learning model obtained through data sharing, there is a need for collaborative machine learning. Naturally, this type of collaboration raises questions in terms of how to incentivize parties to participate in such a collaborative machine learning effort. Unfortunately, in many applications there is a clear and natural incentive for parties to provide quality data or share their data to begin with. Financially rewarding parties to incentivize participation seems to be natural in such cases but has to be done with great care. For example, a fixed price per data point could motivate parties to gather large amounts of low quality or fake data if there is no mechanism to control data quality. Another reason that may dis-incentivize parties from sharing data could stem from privacy and integrity concerns regarding the use of party's data once it is shared. For example, once a party's data is released it can be easily reused or sold. To overcome these challenges and enable collaborative machine learning in the outlined setting, there is a need for a secure machine learning marketplace for joint model training that guarantees fair incentives for participation and ensures secure data handling. In this work, we propose a cloudbased collaborative machine learning platform accessible to parties for submitting data and machine learning tasks. Submitted training data represents the data that a party is willing to contribute/sell, while submitting the validation data can be seen as a specification of the machine learning model a party is willing to buy. After a trade in this market, a participating party obtains a model trained on the data available to the market and customized for its task. Crucially, there is no sharing of data and parties are only provided this customized model (or query interface). As a result, only information relevant to the validation task is released through the model, limiting the possibility of copying and reusing the data for other tasks. Such markets allow multiple parties to jointly train machine learning models based on the training arXiv:1911.09052v1 [cs.GT] 8 Nov 2019 data provided by all of the parties and achieve improved performance on their own tasks. Parties pay to the market for the improvement on their validation tasks and get paid by the market for the contribution of their training data to the tasks of others. The market can support a single validation task scenario, for example, where hospitals bring together their data to train a single model for detecting cancer. Furthermore, it also supports scenarios where one's data can contribute to multiple tasks. An overview of our envisioned marketplace is shown in Figure 1 . Our market is enabled by three main components: 1. Data valuation. Each model in the market is trained on the data that is best suited for the specified validation task. Similar to recent and concurrent work (Jia et al. 2019; Ghorbani and Zou 2019) we can use Shapley values (Shapley 1953) , a solution concept from game theory discussed later, to match data to tasks. 2. Customized model training. We ensure that the model that a party receives is only suited for its own task but not the other tasks available on the market. As a result each party is incentivized to provide its true validation task. 3. Payment division. Each party receives a reward proportional to how useful its data is for training other models. We again use Shapley values, however, in this case to determine fair payoffs. One of the key challenges in designing such data marketplaces comes from the very nature of data, i.e., free replication. This means that the reward of a party submitting copies of the same dataset should not be more than the party submitting it once. Indeed the authors of (Agarwal, Dahleh, and Sarkar 2019 ) also point out that, if used naively for machine learning, Shapley value is not robust to replication (albeit in a different market setup than ours). We design a market that is robust-to-replication. The key idea behind our approach is to allow a party to contribute data only if it also submits a validation task for which it requires a trained model. Submitting a task, in turn, requires a participation fee. Hence, for every replica, a party has to pay a participation fee that depends on its validation task. As a result, the fee it pays for the improvement on its task balances the payoff it gets from the use of its training data. Finally, we ensure that our cloud-based market is secure and can be trusted by the parties. That is, the market itself cannot resell, copy or release the data or the trained models. Such a market can be instantiated using secure hardware, such as Intel SGX (Hoekstra et al. 2013) , which allows parties to submit their data encrypted and ensure that it is only decrypted and processed in secure enclaves and data is always encrypted in memory. It also provides attestation capabilities that parties can use to verify the integrity of the market (e.g., that the data was used only to train specific models and was not copied in plaintext outside of an enclave). See (Ohrimenko et al. 2016) for details. We summarize our contribution as follows: 1. Marketplace Definition: We introduce a collaborative marketplace to sell data and buy machine learning models for learning single and multiple validation tasks.",
  "body": "Introduction One of the main obstacles for training well-performing machine learning models is the limited availability of sufficiently diverse labeled training data. However, the data needed to train good models often exists but is not easy to leverage as it is distributed and owned by multiple parties. For instance, in the medical domain, important data about patients that could be used for learning diagnostic support systems for cancer might be in possession of different hospitals, each of which holding different data, (e.g., from a specific geographical region with different demographics). Typically, by pooling the available data, the hospitals could train better machine learning models for their application than they could using only their own data. As all hospitals would benefit from a better machine learning model obtained through data sharing, there is a need for collaborative machine learning. Naturally, this type of collaboration raises questions in terms of how to incentivize parties to participate in such a collaborative machine learning effort. Unfortunately, in many applications there is a clear and natural incentive for parties to provide quality data or share their data to begin with. Financially rewarding parties to incentivize participation seems to be natural in such cases but has to be done with great care. For example, a fixed price per data point could motivate parties to gather large amounts of low quality or fake data if there is no mechanism to control data quality. Another reason that may dis-incentivize parties from sharing data could stem from privacy and integrity concerns regarding the use of party's data once it is shared. For example, once a party's data is released it can be easily reused or sold. To overcome these challenges and enable collaborative machine learning in the outlined setting, there is a need for a secure machine learning marketplace for joint model training that guarantees fair incentives for participation and ensures secure data handling. In this work, we propose a cloudbased collaborative machine learning platform accessible to parties for submitting data and machine learning tasks. Submitted training data represents the data that a party is willing to contribute/sell, while submitting the validation data can be seen as a specification of the machine learning model a party is willing to buy. After a trade in this market, a participating party obtains a model trained on the data available to the market and customized for its task. Crucially, there is no sharing of data and parties are only provided this customized model (or query interface). As a result, only information relevant to the validation task is released through the model, limiting the possibility of copying and reusing the data for other tasks. Such markets allow multiple parties to jointly train machine learning models based on the training arXiv:1911.09052v1 [cs.GT] 8 Nov 2019 data provided by all of the parties and achieve improved performance on their own tasks. Parties pay to the market for the improvement on their validation tasks and get paid by the market for the contribution of their training data to the tasks of others. The market can support a single validation task scenario, for example, where hospitals bring together their data to train a single model for detecting cancer. Furthermore, it also supports scenarios where one's data can contribute to multiple tasks. An overview of our envisioned marketplace is shown in Figure 1 . Our market is enabled by three main components: 1. Data valuation. Each model in the market is trained on the data that is best suited for the specified validation task. Similar to recent and concurrent work (Jia et al. 2019; Ghorbani and Zou 2019) we can use Shapley values (Shapley 1953) , a solution concept from game theory discussed later, to match data to tasks. 2. Customized model training. We ensure that the model that a party receives is only suited for its own task but not the other tasks available on the market. As a result each party is incentivized to provide its true validation task. 3. Payment division. Each party receives a reward proportional to how useful its data is for training other models. We again use Shapley values, however, in this case to determine fair payoffs. One of the key challenges in designing such data marketplaces comes from the very nature of data, i.e., free replication. This means that the reward of a party submitting copies of the same dataset should not be more than the party submitting it once. Indeed the authors of (Agarwal, Dahleh, and Sarkar 2019 ) also point out that, if used naively for machine learning, Shapley value is not robust to replication (albeit in a different market setup than ours). We design a market that is robust-to-replication. The key idea behind our approach is to allow a party to contribute data only if it also submits a validation task for which it requires a trained model. Submitting a task, in turn, requires a participation fee. Hence, for every replica, a party has to pay a participation fee that depends on its validation task. As a result, the fee it pays for the improvement on its task balances the payoff it gets from the use of its training data. Finally, we ensure that our cloud-based market is secure and can be trusted by the parties. That is, the market itself cannot resell, copy or release the data or the trained models. Such a market can be instantiated using secure hardware, such as Intel SGX (Hoekstra et al. 2013) , which allows parties to submit their data encrypted and ensure that it is only decrypted and processed in secure enclaves and data is always encrypted in memory. It also provides attestation capabilities that parties can use to verify the integrity of the market (e.g., that the data was used only to train specific models and was not copied in plaintext outside of an enclave). See (Ohrimenko et al. 2016) for details. We summarize our contribution as follows: 1. Marketplace Definition: We introduce a collaborative marketplace to sell data and buy machine learning models for learning single and multiple validation tasks. Payment Division: We propose a novel and robust-toreplication payment division function. Customized model training: We propose to release customized models to each party and not data in order to prevent malicious parties from reselling the data while incentivizing them to submit honest validation tasks (which in our market can be seen as an indirect bid on the data). 4. Evaluation: We empirically evaluate the properties of our marketplace. Our experimental results confirm that our marketplace generates fair payoffs, customized models and is robust to replication. Background and Notation Machine Learning Models and Evaluation. In supervised machine learning, we often consider training of models for regression or classification tasks, i.e., learning of a prediction function M : Ω → R k or M : Ω → [K], respectively, where Ω is some input space, k ∈ N, and [K] = {1, . . . , K}. We introduce concepts for classification problems only but the same concepts apply to regression problems. The model M is a part of some hypothesis space H, e.g., the set of one layer neural-networks with a fixed number of hidden neurons and sigmoid activations. These functions are learned from labeled training data X , i.e., collections/sets of tuples of the form (ω, z), where z ∈ [K] for classification. Learning in that context commonly refers to minimizing a sample-wise loss function l : Ω×[K] → R, e.g., the cross-entropy loss, overloading notation: M(X ) = arg min M ∈H 1 |X | (ω,z)∈X l(M (ω), z ). The goal of the learning process is to identify functions M that perform well on unseen data, i.e., test data, and, for instance, achieve good classification accuracy. As a proxy, for estimating the performance on test data, we use validation data V. The average classification performance on the validation data is G(V, M(X )) = 1 |V| (ω,z)∈V 1 M(ω)=z , where 1 is the indicator function. Clearly, the performance measure is application dependent and can, for instance, also be the RMSE, ranking accuracy, etc. We refer to G as (performance) gain function. Properties of G . In the paper and for simplicity, we assume an idealized non-negative gain function G and idealized dependencies of the model on the training data. For training datasets X , X we assume that: (i) replicated data does not change performance: ∀X , X : M(X ) = M(X ⊕ X ); (ii) monotonicty: G(V, M(X ))) ≤ G(V, M(X ⊕ X ))); (iii) supermodularity 1 : G(V, M(X ∪ {x})) - G(V, M(X )) ≤ G(V, M(X ∪ {x})) -G(V, M(X )) for X ⊆ X and x ∈ X ; (iv) boundedness: G(V, M(X )) ≤ 1. Here, (i) captures that duplication of training data does not change the learned model. This is, for instance, true for 1-NN classifiers; (ii) characterizes that additional data either improves or does not change the performance; (iii) captures the collaborative market setting where each party provides complementary data that contributes towards a ML task even in the presence of other parties' data. Shapley Values for Fair Payoffs. Consider a (machine learning) task which M parties M = {1, . . . , M } aim to solve with a joint effort. To quantify the value of the contribution of each party towards solving the task, we consider a characteristic function v : 2 M → R. For every set S ⊆ M of parties, v(S) quantifies how well the parties in S can solve the task, e.g., v(S) could be the prediction accuracy of the best model the parties in S can train by combining their training data, i.e., v(S) = G(V, ∪ i∈S X i ), where X i is the ith party's training data. When the characteristic function depends on the maximum number of participants, we overload the notation and use w(S, M) to denote the value parties in the set S ⊆ M bring to the market with participants in M. If parties are to be compensated for helping to solve a machine learning task, it is natural to ask what a fair payoff for each parties' effort is. To this end, we consider Shapley values (Shapley 1953), i.e., unique payoffs, studied in game theory for collaborative games, that satisfy certain natural fairness properties discussed later. The Shapley value for characteristic function v and party i ∈ M is ψ(v, i) = S⊆M\\{i} |S|!(M -|S| -1)! M ! v(S ∪{i})-v(S) , (1) i.e., ψ(v, i) quantifies the average marginal contribution of party i wrt all possible subsets of parties. If v(M) = 1, Shapley values can be normalized to sum to 1 by scaling them by 1/v(M). When clear from the context which characteristic function is used, we use ψ(i). For a fixed characteristic function v, Shapley values ψ(i) are the unique payoffs satisfying properties of efficiency, symmetry, linearity and null player (explained in §3.1). These properties ensure that parties are paid equally for equal contributions and all gains are distributed among the parties. We will use Shapley values with different characteristic functions in our marketplace: u for deciding which data to use for training customized models ( §5) vs. v and w for computing the payoffs for single validation tasks ( §4.1) and multiple validation tasks ( §4.2) respectively. This is necessary as Shapley value itself is not robust to replication. A Collaborative Marketplace In our marketplace, we consider M parties P 1 , . . . , P M which aim to collaborate towards training machine learning models for their tasks. Each party simultaneously takes the role of a seller and a buyer. The ith party has training data X i and validation data V i . The performance of a machine learning model M(X ) trained on some training data X is evaluated using a performance/gain function G(V i , M(X )) ∈ [0, 1]. The goal of the market is to provide party i with a customized model trained on the subset of (or potentially all) datasets of other parties' that best fits its task (based on V i ). At the same time the market uses X i to train models of parties where this dataset fits the corresponding task (based on validation data of other parties). Definition 1 (Marketplace). A marketplace is a tuple (P, PD), where P = (P 1 , . . . , P M ) is the list of parties engaging with the market place and PD is the payment division function. We consider the following interaction with the data marketplace: 1. Parties P 1 , . . . , P M arrive. 2. The marketplace collects all training data sets X 1 , . . . , X M and validation tasks V 1 , . . . , V M . 3. Every party pays the market a participation fee A i that is determined proportional to unit increase in personal performance gain A i = 1 -G(V i , M(X i )), i.e. , valuation for increasing performance to 100% on their validation data. The market can also set a fixed value for a unit increase c > 0 in performance, such that A i = c • (1 -G(V i , M(X i ))). 4. The marketplace trains a machine learning model M i for every party i where M i = M(V i , ⊕ j∈Si X j ) and S i ⊆ M. The model M i is shared with party i. Let a i = G(V i , M i ) -G(V i , M(X i )) . Party i receives payoff t i which depends on the increase in performance on its validation data V i (i.e., they receive A i -a i ) and how much its data helps in improving performance of models for other validation tasks, b i . Hence, in total party i gains (or loses) (A i -a i ) + b i -A i = b i -a i . Desired Properties In the following we enumerate desired properties for a machine learning marketplace such that participating parties receive fair payoffs for their engagement and benefit from participation. Revenue division and payment. Our list of properties is inspired by the \"standard axioms of fairness\" since they are the de facto method to assess the marginal value of goods (i.e., features in our setting) in a cooperative game (i.e., prediction task in our setting). They include: Balance: b i = a i . Symmetry: if two parties i and j enter the market with same training and validation sets then the their payoff, t i = t j . Zero element buyer: if there is a party whose performance does not increase, it should at least get its participation fee back, t i = A i . Incentives. Party i decides on whether to enter the collaborative market or not and what V i and X i to contribute. As a result, the marketplace should incentivize the parties to join the market with good training data and honest validation data: Joining the market: The market should incentivize new parties to join. Our setting incentivizes this as follows. A new party brings a new task to the market, hence, existing parties' data may be useful for this task, increasing their payoff b i . At the same time, the new party is also bringing new training data which can increase performance of tasks submitted in the existing market, resulting in an increased payoff. Hence a party joining the market can benefit from increased utility. Validation data: A dishonest party can try to manipulate training and validation data (including their relationship) in order to gain more than it would with its true training and validation datasets. For example, V i can be seen as an implicit bid that party i places on the model M i it will obtain. There can be a case that G(V , M i ) -G(V , M(X i )) > G(V i , M i ) -G(V i , M(X i )). If it is the case, M i has higher utility than what is determined by V i . To this end, the marketplace needs to ensure that the model M i that is returned to the party does not allow for existence of V in the current marketplace, incentivizing the party to provide the best V i to get the best utility model. We enforce this incentive by training models that are customized for a specific task, i.e., maximizing their accuracy towards a specific task while minimizing their accuracy on all other tasks in the market. Training data: The market needs to ensure that the payment b i that party i receives for the use of its data to train other models incentivizes it to provide its best X i . We note that our market does not have an explicit way for parties to bid or price training data. Robustness to replication. Parties may not behave honestly and may replicate their data and create new replica parties to join the market on their behalf. The market should be robust to replication. That is, a party that replicates its training data should not earn more than it would in the original market. This is a crucial property for any data market since data as compared to physical goods is easily replicable. This problem was already highlighted for a different marketplace setup in (Agarwal, Dahleh, and Sarkar 2019) . Privacy and Integrity. Since data can be easily leaked and manipulated compared to physical goods, the market should provide assurance to its participants about the correct handling of their data and model training. At the very least it should ensure that information about the training data X i of party i is revealed only to other parties through models for validation tasks where ith training data is useful. The information about V i has to be kept secret as well. As we mention in the introduction, these properties can be provided if the market infrastructure is instantiated using Trusted Execution Environments (or enclaves): parties submit their data encrypted and allow only attested (verified) code to decrypt, compute on it, and finally encrypt the models under the encryption keys of the parties who can access these models (i.e., the party who specified the validation data for this model). Market Instantiations We provide market instantiations for both a single validation task among all the parties and multiple validation tasks. Single Validation Task Let us describe the marketplace for a single validation task V that all M parties agree on. We slightly abuse the notation by letting M S = M(⊕ k∈S X k ) be the model trained on data from parties in S for task V. The parties agree on the same marginal payment per increase of the model performance they gain (for example, per percentage increase): if G(V, M M ) = 1 then party i pays the amount proportional to A i = 1 -G(V, M i ). Hence, the largest amount that can be distributed among market participants is i∈M A i . Recall that, when entering the market the party submits X i and fee A i . After the market completes, i obtains M M and payout b i ≥ 0. In §5 we explain how to train M M from parties' datasets and here describe how we instantiate the market, compute the payoffs using Shapley and show that the market is robust to replication. Characteristic Function. Our characteristic function captures the value of data to parties in a set S for the task V as the value of the model trained on the data as well as the value the model brings to every party. As a result the characteristic function for this market is defined as v(S) = G V; M S ) value of the model + j∈S G V; M S ) -G V; M j ) model value for party j (2) This function can be seen as the value of the model trained on the datasets of all parties in S plus the marginal gains for each party. Note that for a single party the value of the data is expressed as the value of the model trained on its own training dataset. Payment Division. The total amount, a, that is distributed among the participants depends on the individual gains obtained from the final model. Let a i = G(V, M M ) - G(V, M i ). Then, a = i∈M a i . We use (normalized) Shapley values for characteristic function v to determine the distribution of a to each party i: b i = a × ψ(v, i). To simplify the notation we use ψ(i) to denote ψ(v, i). In total, party i obtains t i = (A i -a i )+b i where (A i -a i ) is the return of the original investment if the final model performance is not 1. Hence, party i gains/loses the following amount by participating in the market: (A i -a i ) + b i -A i = ψ(i)a -a i . Note that i gets ψ(i) portion from each a j and it pays 1 -ψ(i) of a i to the market. Properties. Our single-task market has the following properties: Balance: i (b i -a i ) = i a × ψ(i) -i a i = a × 1 -a = 0 . Symmetry: This follows from using Shapley value to calculate payout b i and a i would be the same for the parties with same data. Zero element buyer: If i does not benefit from other parties, that is G(V, M i ) = G(V, M M ), then A i is returned to i since a i = 0. Robustness to replication. Recall that a market is robust if a party does not gain a higher payoff in the market with the replicas compared to its gain in the original market. Let us consider the total payoff of i when it replicates itself once. Let a and a R be the values of the original and replicated markets. By definition, a R = a + a i . Let t denote i's payoff in the original market and t R be its total payoff when it replicates itself. Similarly, let ψ(•) and ψ R (•) denote Shapley values before and after replication. t R = 2 × ψ R (i)(a R -a i )-2×(1-ψ R (i))a i = 2×(ψ R (i)a R -a i ). In the market where each party is equivalent, that is ∀k, a k = a, replication does not help. Using the symmetry property of Shapley value we can show that t R = 0. Let us consider the case when the contributions of the parties are different. Recall that: t = ψ(i)a -a i and t R = 2 × (ψ R (i)(a + a i ) -a i ). Replication is useful to party i only if t < t R . If this is the case, then: ψ(i)a+a i < 2ψ R (i)(a+a i ) should hold. Condition 1. The market in §4 is robust to replication if ψ R (i) ≤ ψ(i)a+ai 2(a+ai) . We show that our single-task market instantiation is robust to replication as long as the gain function G has the properties outlined in §2. Our proof proceeds as follows. We first derive the payoff that i needs to make in the replicated market in order to break even. We then determine the marginal contribution of party i for new coalitions that are created due to the addition of its replica i (see Lemma 4 in Appendix). We then devise the relationship between the Shapley values of party i before and after replication. Finally we show that the Shapley value of i in the new replicated market satisfies the condition of robustness to replication, yielding the following theorem (proof details are provided in the appendix): Theorem 1. The single-task market instantiation in §4.1 is robust to replication as per Condition 1. Multiple Validation tasks The market setup is similar to the single task market where there is a task from each party, V i . Similarly when entering the market the party submits X i and fee A i . After the market completes, i obtains M i M and payout b i ≥ 0. In §5 we explain how to train an individual M i M from parties' datasets and use the rest of the section to describe how we instantiate the market and compute the payoffs. Characteristic Function. Let D ⊆ M be a set of indices of the distinct validation tasks, i.e., for every i ∈ M, there is j ∈ D s.t. V i = V j . Then the characteristic function for the multi-task market is defined as: w(S, M) = i∈D G V i ; M i S ) value of models for distinct tasks + i∈S G V i ; M i S ) -G V i ; M i i ) value for party i (3) When clear from the context, we omit the second argument of w(•, •). We observe that this is a natural extension from a single validation task: the goal of the market is to achieve better performance on all (distinct) tasks of the market as well as individually for each party. As we will see it also helps with lowering the impact of replicated parties on the value of the market: an addition of a replicated party will affect only the second part of the value function while a party with new data has a chance to contribute to both parts of the characteristic function. Payment division and properties. The payment division is identical to the one for a single task market in §4.1 except that w is used as the characteristic function when computing the Shapley value. Since the payment function is the same as in the singletask market, the condition on robustness is also the same and marginal contribution of i to coalitions that are created due to its replication is limited in the same (see Lemma 6 in Appendix). Since multi-task market payout is defined in the same manner as the one for single task, the following properties also hold: balance, zero element and symmetry. The main difference is the computation of the characteristic function w. The multiple-task market is robust to replication as we prove in the appendix. Theorem 2. The multiple-task market instantiation in §4.2 is robust to replication as per Condition 1. Training over Multi-Party Data In this section, we describe (1) how to align the training data provided by all parties for training models for different tasks, i.e., select the relevant training data; and (2) how to train a model for party i such that it performs well only on its corresponding task and not other tasks in the market. Training Data Selection. With multi-party data we need to select the right training data for training each parties' model. To this end, we also make use of Shapley values. Note that this step happens prior to the computation of the payoffs which again involves the computation of Shapley values but for a different characteristic function. For training data selection for party i we follow two steps: (1) Compute the Shapley values ψ(u i , i) for u i (S) = G(V i , M(∪ j∈S X j )). (2) Determine the relevant data for the task of party i as D i = {j ∈ M | ψ(u i , j) ≥ τ }, where τ is a threshold that can be used to control the amount of used training data. Note that the above steps can be trivially applied on a sample-level instead of a dataset-level. Computing sample-level Shapley value would typically result in better model performance at increased computational cost for deciding on the training data to use. In the case of a single common validation set, D i = D j , ∀i = j. The characteristic functions used for computing payoffs in §4.2 are computed using only relevant training data. In particular, when computing Shapley values for determining each parties' payoff, we use the shorthand M i S for M S∩Di . Superscript is omitted for single validation task. Customized Model Training. To minimize usefulness of the model provided to party i after interacting with the market for other parties' validation tasks, we adopt the following strategy for training the model for party i: Party i receives a model trained on the data of parties D i . Additionally the model that party i receives is optimized for maximizing the loss wrt all V k for k = i, i.e. min θ j∈M\\{i} G(V i , M(⊕ k∈M X k )) (4) s.t. G(V i , M(⊕ k∈M X k )) ≥ G * -, where G * = G(V i , M i M ) is the best performance achievable on the validation data of party i by standard model training, ≥ 0 is some constant, and θ are parameters of the models, e.g., weights of a neural network. To avoid overfitting to the validation data by using it during model training (we still need to resort to the validation data for pricing) and have a straightforwardly approachable optimization problem, we consider the proxy max θ G(∪ k∈Di X k , M i M )- λ j =i G(V j , M i M ) , where λ > 0 is a hyperparameter. This approach is evaluated in our experiments. Experiments We implemented a prototype of our marketplace and evaluated it on the task of classifying handwritten digits from the MNIST dataset (LeCun et al. 1998 ). Here we validate assumptions made in the paper and evaluate the effectiveness of our marketplace setup. The goals of our evaluation are: (i) Understand the effect of replicated training data on the accuracy on validation data; (ii) Measure the (importance) value of training data towards a single validation task; (iii) Calculate the payoffs with our payment division function for training data with and w/o replication and compare them to those of the naive payment division; (iv) Evaluate the effectiveness of an output model customized for a given validation task. Effect of Data Replication on ML models We aim to understand how data replication affects model accuracy and validate the assumption we made in §2. To this end, we consider a collaboration among 10 parties for the validation task of 10K images with all 10 digits. We measure the accuracy on this validation task on models that are trained using the data from all parties. We train a logistic regression model and a single hidden layer (500 neurons) DNN model for 100 epochs with a learning rate of 10 -2 , Adam optimizer and a value of 10 -4 for ℓ2 regularization. In the initial setup, each party contributes 1000 images corresponding to a single digit, which are randomly sampled from the training data for this digit. To understand the effect of replication, we compare the accuracy of the model trained in the initial setup with the following replication configurations. The party with digit 0 or 4, respectively, replicates and creates new parties with the same 1000 images as their training data. We vary the number of replicas from 0 to 50. Hence, there will be 50,000 samples corresponding to the digit 0 in the combined training dataset for 50 replicas. All observations are similar for the replication of other digits. In addition to the overall accuracy of the validation task, we looked at the accuracy of the digits 0 and 4 present in the validation dataset. Results. Figure 2 shows results for a logistic regression and a DNN model averaged over 50 runs (random draws of training and validation data, and of the initial network weights). The dotted and the solid lines denote the accuracy over the number of replicas. For logistic regression, the accuracy of classifying digit 0 increases initially with replication of digit 0 and then remains constant. This confirms that replication does not necessarily benefit the accuracy of the replicated digit on a model that is trained on sufficient samples. On the other hand, the accuracy of classifying the digit 0 decreases slightly with replication of 4. This result shows that replication may hurt the accuracy of other validation tasks in the market. Finally, we observe that the accuracy of the overall validation task of 10K images reduces only slightly with the replication of both digits. The results for DNNs show similar trends. Thus, in summary, the assumptions needed for our theoretical results hold approximately in practice. Customized Model Training An important component of our marketplace is customized model training, cf. §5, which consists of two steps: data selection and model training. We empirically investigate both steps here. Training data selection. To understand the usefulness of training data with respect to a validation task, we consider a setting where each party holds 2000 training samples for two randomly selected labels. As validation tasks, we consider classification of all ten digits and classifying digits (0, 1, 2, 3, 6, 8). Figure 3a shows the Shapley values using characteristic function u for both validation tasks. For all the digits in the validation data (label 0-9 in the figure), we observe that the parties with unique labels such as 1, 2 and 6 have higher Shapley values indicating higher utility of their training data. For the validation task on digits (0, 1, 2, 3, 6, 8) we observe that the parties which do not contribute any of these digits have zero Shapley values. This confirms that Shapley values are well suited for selecting training data for task-specific model training. Model training. To evaluate the customized model training we considered a setting with ten parties in which each party holds data for two different digits s.t. party j has data for labels (j, (j + 1) mod 10) for j ∈ {0, 1, . . . , 9}. For party j the training data consists of all training samples from the MNIST dataset with either of its two labels. The same holds for its validation data with respect to the validation data from MNIST. In Figure 4 we see results for applying the customized model training approach when training a logistic regression model for the validation task of each party. We observe that although the combined training points consist of all the digits in MNIST, the model trained with our approach is useful only for the specific validation task and has mediocre performance on (other) validation tasks with overlapping labels. That is, it is not useful to classify digits from the remaining labels outside the specific validation task. Payoffs in Single Task Marketplace We now empirically validate that our proposed characteristic function v in §4.1 for computing payoffs is indeed robust to replication. We also compare it to the case where Shapley values are computed for characteristic function u (model accuracy), cf. §5, which is not robust to replication. Here, we consider two parties: Honest party P 1 with digits (0,8), and replicating party P 2 with digits (2,8). P 2 creates replicas P 3 to P 6 with the same dataset. The single validation task is (0, 1) (1, 2) (2, 3) (3, 4) (4, 5) (5, 6) (6, 7) (7, 8) (8, 9) (9, 0) Training data (0, 1) (1, 2) (2, 3) (3, 4) (4, 5) (5, 6) (6, 7) (7, 8) (8, 9) (9, 0) Validation task 0.93 0.46 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.49 0.48 0.94 0.51 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.46 0.92 0.44 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.49 0.95 0.47 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.42 0.92 0.48 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.47 0.92 0.41 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.52 0.92 0.43 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.45 0.92 0.49 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.47 0.93 0.45 0.42 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.51 0.95 classification of digits 0,2,8. The parties combine their data and train a logistic regression model. Figure 3 shows Shapley values of our results as number of replicas increases. We observe that the combined Shapley value of the replicating parties increases with the number of replicas while that of the honest party P 1 decreases for u (Figure 3b ) when using Shapley values with accuracy as the characteristic function. In contrast, Figure 3c shows that when Shapley values are instantiated with our new characteristic function, Shapley values of P 1 and the combined values for the replicating parties are equal. This verifies that replication does not benefit the replicating party when using our single-task collaborative market instantiation. Related Work Multiple lines of work are related to our proposed collaborative machine learning markets framework. We organized it into work on using Shapley values for valuating data for model training and machine learning marketplaces. Also general work on game theory and mechanism design is related to our work but not discussed here in detail, cf. (Nisan et al. 2007 ) for an overview. Shapley values for valuating data. Prior work has proposed the use of Shapley values for characteristic function u to valuate data in machine learning settings. Most of these works focus on the problem of efficiently approximating Shapley values. Closest to ours, Agarwal, Dahleh, and Sarkar (2019) uses Shapley values to compute payoffs in non-collaborative marketplace. Before that, Datta et al. (2016) proposed the use of Shapley values to quantify feature importance for classification problems, and proposed sampling based approximations of Shapley values. Ghorbani et al. (2019) show that Shapley values are good metric to quantify the usefulness of data for machine learning tasks. They show that valuating data for model training based on Shapley value is better than using leave-one-out cross-validation, and propose sampling and gradient based approaches for approximating Shapley values. Also Jia et al. (2019) propose several sampling based approaches and the use of influence functions (Koh and Liang 2017) to reduce the computational cost of computing Shapley values. Machine learning marketplaces. The closest to our paper is work by Agarwal et al. (2019) who study an algorithmic approach for data marketplaces. They propose a general marketplace setup which makes use of Shapley values for computing payoffs. The marketplace sets prices for data in an online fashion and matches sellers to buyers. They highlight the problem of data replication in combination with Shapley values and propose to overcome it heuristically by downweighing Shapley values according to data similarity. Critically, their approach also reduces payoffs for honest, i.e., non-replicating parties. In contrast, we achieve robustness-to-replication naturally through the multi-party setting in combination with novel characteristic functions. Furthermore, in our marketplace no data is given to any party, avoiding further reselling of the data while in (Agarwal, Dahleh, and Sarkar 2019) this is possible. Other related work tries to price machine learning models instead of data directly (Chen, Koutris, and Kumar 2018) . In that work, a broker forms the interface between data sellers and model buyers. Their main focus is to ensure affordability of models for all buyers by adjusting the model's performance through noise-injection and prevention of arbitrage. Abernethy and Frongillo (2011) study incentive mechanisms in the setting where solving a task (e.g., ML prediction) is done in a collaborative decentralized manner with parties contributing towards solving the task with their expertise (e.g., improvements to a classifier), as opposed to contributing data. Marketplaces that treat data similar to classical goods are available at (Big Data Exchange ; QLik Data Market ). Future Work We consider the following extensions of our work: Performance: Improve the time to select training data using optimizations for evaluation of Shapley values such as sampling or influence functions (Koh and Liang 2017; Jia et al. 2019; Ghorbani and Zou 2019) . Data Privacy: Use differential privacy techniques to strengthen privacy of training data in the customized models, as a result mitigating model inversion or membership inference attacks on the output model (Shokri et al. 2017; Fredrikson, Jha, and Ristenpart 2015) . Iterative Market: Consider marketplace properties when the parties interact with the market over multiple rounds. Iterative markets would allow parties to learn additional information about the market such as the type of validation tasks and training data available, which might give advantage to adversarial parties. A Proof Details We show that our market instantiations are robust to replication. Recall that a market is robust if there is no party that gains a higher payoff in the market with its replicas compared to its gain in the original market (Condition 1). Let i be the party that replicates itself. Our proof proceeds as follows. In Lemma 1, we use the Shapley value of party i before replication (ψ i ) to bound the Shapley value of party i after replication (ψ R i ) and show that the bound holds under several assumptions on the characteristic function v. We then show that, if ψ R is bounded as it is in Lemma 1, then the market is robust to replication (Lemma 2). Finally, we prove that the characteristic functions for the single validation task market (Equation 2 ) and multiple validations task market (Equation 3 ) and corresponding Shapley values satisfy conditions of Lemma 2 and hence are both robust-to-replication (Theorems 1 and 2). In this section we outline lemmas that hold for both market instantiations and in the following sections show that assumptions of the lemma statements indeed hold for the single-and multiple-validation-task markets. Lemma 1. In a collaborative ML market with parties in set M, let a i be the gain that party i obtains for its own task by participating in the market. Let v(S, M) be a characteristic function of the value of parties in S ⊆ M with the following properties: (1) v(S, M) = v(S, M R ), ∀S ⊆ M, where M R are the same parties as in the original market along with a replica of party i ∈ M, i . ( 2 ) v(S ∪ {i}, M R ) -v(S, M R ) ≤ a i where i ∈ S and i is a replica of i. (3) v is supermodular. Let ψ and ψ R be the Shapley values of the original market and the market with i's replica, then: ψ R (i) ≤ ψ(i)v(M, M) 2v(M R ) + a i 2v(M R , M R ) = ψ(i)v(M, M) + a i 2v(M R , M R ) Proof. Let us express ψ R (i) in terms of ψ. Compare the coalition subsets S between the two values. All the new subsets in ψ R will contain the replica of i and, by the assumption of the lemma, for such subsets v(S ∪ i, M R ) -v(S, M R ) = a i . The other subsets are the same as in ψ except their value towards the overall Shapley value decreases. Let ψ R (i) = ψ R old (i) + ψ R new (i) where ψ R old is the value brought from old (coalition) subsets and ψ R new from the new ones. Bounding ψ R old (i): Since v(S, M) = v(S, M R ) for all subsets S where replica i is not present (i.e., those subsets used in computing ψ R old ), we omit the second argument of v to simplify the notation. Recall that the (normalized) Shapley values of the subsets that existed before replication for both markets are: ψ(i) = 1 v(M) S⊆M\\{i} |S|!(M -|S| -1)! M ! v(S ∪{i})-v(S) ψ R old (i) = 1 v(M R ) S⊆M\\{i} |S|!(M -|S|)! (M + 1)! v(S ∪{i})-v(S) We need to show that ψ R old (i) = 1 v(M R ) S⊆M\\{i} |S|!(M -|S|)! (M + 1)! v(S ∪{i})-v(S) ≤ ψ(i)v(M) 2v(M R ) (5) Simplifying the inequality and substituting ψ(v): S⊆M\\{i} |S|!(M -|S|)! (M + 1)! v(S ∪{i})-v(S) ≤ ψ(i)v(M) 2 S⊆M\\{i} |S|!(M -|S|)! (M + 1)! v(S ∪{i})-v(S) ≤ 1 v(M) S⊆M\\{i} |S|!(M -|S| -1)! M ! v(S ∪{i})-v(S) v(M) 2 S⊆M\\{i} |S|!(M -|S|)! (M + 1)! v(S ∪{i})-v(S) ≤ 1 2 S⊆M\\{i} |S|!(M -|S| -1)! M ! v(S ∪{i})-v(S) S⊆M\\{i} |S|!(M -|S|)! (M + 1) v(S ∪{i})-v(S) ≤ 1 2 S⊆M\\{i} |S|!(M -|S| -1)! v(S ∪{i})-v(S) S⊆M\\{i} |S|!(M -|S| + 1)!(M -2|S| -1) v(S ∪{i})-v(S) ≤ 0 Note that coefficients M -2|S| -1 are symmetric for sets |R| < M/2 and |Q| = M -|R| -1: M -2|R| -1 = -(M -2|Q| -1). There are M -1 |R| sets of size |R| and M -1 M -|R|-1 of size M -|R| -1. Note that M -1 |R| = M -1 M -|R|-1 . Hence, the number of sets is the same and we are left to define a one-to-one mapping, s.t., for every set R there is a set Q, R ⊂ Q. If this mapping exists, then we can use supermodularity property of v: v(R ∪ {i}) -v(R) ≤ v(Q ∪ {i}) -v(Q) , and the inequality is satisfied. To define the mapping, we represent sets as a bipartite graph (X, Y ) where vertices in X represent all sets of size |R| and vertices in Y represent all sets of size |Q|. For every R ⊂ Q, we add an edge between the vertices that correspond to these two sets. Note that every vertex in X and Y is connected to M -|R|-1 M -2|R|-1 vertices (i.e., we are counting the number of sets of size M -|R| -1 that contain subset R and where other elements are chosen from the remaining M -|R| -1 elements). Hall's marriage theorem states that there is a matching where every vertex x ∈ X is matched if and only if |W | ≤ |N (W )| for every W ⊆ X and where N (W ) ⊆ Y denotes neighbors of vertices in W . We prove that this is the case by construction. Take a vertex x ∈ X and initialize W = {x}. Note that |N (W )| = M -|R|-1 M -2|R|-1 . We proceed by expanding W with arbitrary vertices from X. We note that the total number of edges between W and N (W ) is always |W | × M -|R|-1 M -2|R|-1 . For every vertex x that is added there are two possibilities: either x contains same elements as sets already in W , in which case N (W ) = N (W ∪ {x }), or N (W ) ⊂ N (W ∪{x }) as sets that cover the new elements are added. Suppose we are at the stage when |W | = |N (W )|. We prove that there is no x ∈ X s.t. |N (W )| = |N (W ∪ {x })| and, hence, W cannot be expanded without also expanding N (W ). Note that if |W | = |N (W )| each vertex in N (W ) must be connected to M -|R|-1 M -2|R|-1 vertices in W to satisfy the constraint on the number of edges from a vertex in Y to X. Hence, there cannot be a vertex in X that has edges to N (W ) as this would exceed the per-vertex number of edges constraint. Hence, x does not exist. Since |X| = |Y | and there is a matching where every vertex in X is matched according to Hall's theorem, there is a mapping between every vertex in X and Y . Computing ψ R new (i): Let us now show that ψ R new (i) = ai 2v(M R ) , where we denote the number of coalitions of size s without party i in the market with M parties using, n s,M : n s,M = M -1 s Each new coalition in the new marketplace contains i . The number of such new subsets is n M,M +1 + M -1 s=1 n s,M +1 -n s,M = 1 + M -1 s=1 n s,M +1 -n s,M Since marginal contribution of i in the new coalitions will be limited to a i by the property of v, the overall value that these subsets bring to ψ R (i) is: ψ R new = a i 1 M + 1 1 v(M R ) 1 + M -1 s=1 n s,M +1 -n s,M n s,M +1 = a i 1 M + 1 1 v(M R ) 1 + M -1 2 = a i 1 M + 1 1 v(M R ) M + 1 2 = a i 2v(M R ) (6) (see Claim 1 for the expansion of the subset combinations). Then substituting derivations 5 and 6 into ψ R (i), we obtain the statement of the lemma. Corollary 1. If a i = 0, then ψ R (i) ≤ ψ(i)v(M) 2v(M) = ψ(i) 2 . Lemma 2. In a collaborative ML market with parties in set M, let a i be the gain that party i obtains for its own task by participating in the market. Let v be the characteristic function s.t. v(M) ≥ j∈M a j and v(M R ) = v(M) + a i , where M R consists of the same parties as M along with a replica of i. If ψ R ≤ ψ(i)v(M,M)+ai 2v(M R ,M R ) for every party i, then the market is robust to replication as per Condition 1. Proof. Let us prove the contrary that the market is not robust to replication and hence Condition 1 is false, i.e., that ψ R (i) > ψ(i)a + a i 2(a + a i ) where a = j∈M a j . Substituting ψ R in Condition 1 and using the property that v(M R ) = v(M) + a i , we obtain ψ(i) a 2(a + a i ) + a i 2(a + a i ) < ψ(i) v(M) 2(v(M) + a i ) + a i 2(v(M) + a i ) ψ(i)a + a i a + a i < ψ(i)v(M) + a i v(M) + a i (7) Let c = v(M) -a, where c ≥ 0 by the property of v. Then, substituting v(M): ψ(i)a + a i a + a i < ψ(i)(a + c) + a i a + c + a i a + c + a i a + a i < ψ(i)(a + c) + a i ψ(i)a + a i Let x = 1/ψ(i) ≥ 1, then a + c + a i a + a i < a + c + xa i a + xa i Let p = a+c+ai a+ai , then a + c + a i = p(a + a i ). Since c ≥ 0, a i ≥ 0, p ≥ 1. We need to show that p < a + c + xa i a + xa i = p(a + a i ) -a i + xa i a + xa i p(a + xa i ) < p(a + a i ) -a i + xa i pxa i < pa i -a i + xa i px < p + x -1 However, px ≥ p + x -1 for p, x ≥ 1 and we arrive to contradiction. Claim 1. M -1 s=1 n s,M +1 -n s,M n s,M +1 Proof. Let us expand v(S ∪ {i}) using the property of the gain function that states that replication does not change its value (i.e., G(V; M S∪{i} ) = G(V; M S )): v(S ∪ {i}) = G V; M S∪{i} ) + j∈S∪{i} G V; M S∪{i} ) -G V; M j ) = G V; M S ) + j∈S∪{i} G V; M S ) -G V; M j ) Then v(S ∪ {i}) -v(S) = G V; M S ) + j∈S∪{i} G V; M S ) -G V; M j ) -G V; M S ) - j∈S G V; M S ) -G V; M j ) = G V; M S ) -G V; M i ) ≤ a i Theorem 1. The single-task market instantiation in §4.1 is robust to replication as per Condition 1. Proof. Single task market uses a characteristic function v that satisfies properties of Lemma 1: (1) v(S, M) = v(S, M R ), ∀S ⊆ M, since v depends only on S and not the second argument. ( 2 ) v(S ∪ {i}, M R ) -v(S, M R ) ≤ a i holds as per Lemma 4 where second argument of v is omitted to simplify the notation. (3) v is supermodular as shown in Lemma 3. Hence, ψ R is bounded as in Lemma 1. Furthermore, v satisfies properties of Lemma 2: since v(S) = G V; M S ) + j∈S G V; M S ) -G V; M j ) and a i = G(V, M M ) -G(V, M i ), v(M) = G V; M S ) + j∈M a j ≥ j∈M a j . The second property, v(M R ) = v(M) + a i , holds due to the property of G on replicated data: v(M R ) = G V; M M R )+ j∈M R G V; M M R ) -G V; M j ) = G V; M M )+ j∈M R G V; M M ) -G V; M j ) = v(M)+a i . Single task market instantiation satisfies properties of Lemma 2 on v and ψ R and, hence, is robust to replication. C Multiple Validation Tasks: Proof Details Lemma 5. Let w be the characteristic function as defined in Equation 3 . Then if G is monotonic and supermodular, w is supermodular. Proof. We want to show that for sets R ⊂ Q, w(R ∪ {i}) -w(R) ≤ w(Q ∪ {i}) -w(Q), where the second argument is omitted since w has the same dependency on M for all sets in the same market instantiation. Recall that w is defined as: w(S ∪ {i}) = j∈D G V j ; M j S∪{i} ) + j∈S∪{i} G V j ; M j S∪{i} ) -G V j ; M j j ) Then w(S ∪ {i}) -w(S) is: j∈D G V j ; M j S∪{i} ) + j∈S∪{i} G V j ; M j S∪{i} ) -G V j ; M j j ) - i∈D G V i ; M i S ) - i∈S G V i ; M i S ) -G V i ; M i i ) = j∈D (G V j ; M j S∪{i} ) -G V i ; M i S )) + j∈S G V j ; M j S∪{i} ) -G V i ; M i S ) + G V i ; M i S∪{i} ) -G V i ; M i i ) Hence, v(R ∪ {i}) -v(R) ≤ v(Q ∪ {i}) -v(Q) can be written as follows: j∈D (G V j ; M j R∪{i} ) -G V i ; M i R )) + j∈R G V j ; M j R∪{i} ) -G V i ; M i R ) + G V i ; M i R∪{i} ) ≤ j∈D (G V j ; M j Q∪{i} ) -G V i ; M i Q )) + j∈Q G V j ; M j Q∪{i} ) -G V i ; M i Q ) + G V i ; M i Q∪{i} ) Figure 1 : 1 Figure 1: Collaborative marketplace setup. Figure 2 : 2 Figure 2: Accuracy for MNIST dataset trained using logistic regression (two left plots) and a DNN (two right plots) with replication of digit 0. Replication of other digits showed similar results. Figure 3 : 3 Figure 3: (a) Shapley values for parties contributing training data for validation tasks with all ten digits and only digits (0, 1, 2, 3, 6, 8). Figures (b) and (c): Shapley values on validation dataset of digits (0,2,8) with replicating parties for characteristic function u (accuracy) in (b) and our proposed characteristic function v ( §4.1) in (c). Figure 4 : 4 Figure 4: Classification accuracy of the customized models for different validation tasks. In our theoretical analysis, we show that supermodularity in combination with our other assumptions is sufficient to prove that our marketplace instantiations in §4 are robust to data replication as introduced in §3.1. However, it is not a necessary condition."
}