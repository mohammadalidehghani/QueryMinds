{
  "title": "Automated Machine Learning on Graphs: A Survey",
  "abstract": "Machine learning on graphs has been extensively studied in both academic and industry. However, as the literature on graph learning booms with a vast number of emerging methods and techniques, it becomes increasingly difficult to manually design the optimal machine learning algorithm for different graph-related tasks. To solve this critical challenge, automated machine learning (AutoML) on graphs which combines the strength of graph machine learning and AutoML together, is gaining attention from the research community. Therefore, we comprehensively survey AutoML on graphs in this paper 1 , primarily focusing on hyper-parameter optimization (HPO) and neural architecture search (NAS) for graph machine learning. We further overview libraries related to automated graph machine learning and in-depth discuss AutoGL, the first dedicated open-source library for AutoML on graphs. In the end, we share our insights on future research directions for automated graph machine learning. This paper is the first systematic and comprehensive review of automated machine learning on graphs to the best of our knowledge.",
  "introduction": "Introduction Graph data is ubiquitous in our daily life. We can use graphs to model the complex relationships and dependencies between entities ranging from small molecules in proteins and particles in physical simulations to large national-wide power grids and global airlines. Therefore, machine learning on graphs has long been an important research direction for both academics and industry [1] . In particular, network embedding [2; 3; 4; 5] and graph neural networks (GNNs) [6; 7; 8] have drawn increasing attention in the last decade. They are successfully applied to recommendation systems [9; 10] , fraud detection [11] , bioinformatics [12; 13] , physical simulation [14] , traffic forecasting [15; 16] , knowledge representation [17] , drug re-purposing [18; 19] and pandemic prediction [20] for Covid- 19 . Despite the popularity of graph machine learning algorithms, the existing literature heavily relies on manual hyperparameter or architecture design to achieve the best performance, resulting in costly human efforts when a vast number of models emerge for various graph tasks. Take GNNs as an example. At least one hundred new general-purpose architectures have been published in top-tier machine learning and data mining conferences in the year 2020 alone, not to mention cross-disciplinary researches of task-specific designs. More and more human efforts are inevitably needed if we stick to the manual try-and-error paradigm in designing the optimal algorithms for targeted tasks. On the other hand, automated machine learning (AutoML) has been extensively studied to reduce human efforts in developing and deploying machine learning models [21; 22; 23] . Complete AutoML pipelines have the potential to automate every step of machine learning, including auto data collection and cleaning, auto feature engineering, and auto model selection and optimization, etc. Due to the popularity of deep learning models, hyper-parameter optimization (HPO) [24; 25; 26] and neural architecture search (NAS) [27] are most widely studied. AutoML has achieved or surpassed humanlevel performance [28; 29; 30] with little human guidance in areas such as computer vision [31; 32] . Automated machine learning on graphs, combining the advantages of AutoML and graph machine learning, naturally serves as a promising research direction to further boost the model performance, which has attracted an increasing number of interests from the community. In this paper, we provide a comprehensive and systematic review of automated machine learning on graphs, to the best of our knowledge, for the first time. Specifically, we focus on two major topics: HPO and NAS of graph machine learning. For HPO, we focus on how to develop scalable methods. For NAS, we follow the literature and compare different methods from search spaces, search strategies, and performance estimation strategies. How different methods tackle the challenges of AutoML on graphs are discussed along the way. Then, we review libraries related to automated graph machine learning and discuss AutoGL, the first dedicated framework and open-source library for automated machine learning on graphs. We high-light the design principles of AutoGL and briefly introduce its usages, which are all specially designed for AutoML on graphs. We believe our review in this paper will significantly facilitate and further promote the studies and applications of automated machine learning on graphs. The rest of the paper is organized as follows. In Section 2, we point out the challenges for automated graph machine learning and briefly introduce basic formulations of machine learning on graphs and AutoML. We comprehensively review HPO on graph machine learning in Section 3 and NAS for graph machine learning in Section 4, followed by our overview and discussions of related libraries in Section 5. Lastly, we outline future research opportunities in Section 6.",
  "body": "Introduction Graph data is ubiquitous in our daily life. We can use graphs to model the complex relationships and dependencies between entities ranging from small molecules in proteins and particles in physical simulations to large national-wide power grids and global airlines. Therefore, machine learning on graphs has long been an important research direction for both academics and industry [1] . In particular, network embedding [2; 3; 4; 5] and graph neural networks (GNNs) [6; 7; 8] have drawn increasing attention in the last decade. They are successfully applied to recommendation systems [9; 10] , fraud detection [11] , bioinformatics [12; 13] , physical simulation [14] , traffic forecasting [15; 16] , knowledge representation [17] , drug re-purposing [18; 19] and pandemic prediction [20] for Covid- 19 . Despite the popularity of graph machine learning algorithms, the existing literature heavily relies on manual hyperparameter or architecture design to achieve the best performance, resulting in costly human efforts when a vast number of models emerge for various graph tasks. Take GNNs as an example. At least one hundred new general-purpose architectures have been published in top-tier machine learning and data mining conferences in the year 2020 alone, not to mention cross-disciplinary researches of task-specific designs. More and more human efforts are inevitably needed if we stick to the manual try-and-error paradigm in designing the optimal algorithms for targeted tasks. On the other hand, automated machine learning (AutoML) has been extensively studied to reduce human efforts in developing and deploying machine learning models [21; 22; 23] . Complete AutoML pipelines have the potential to automate every step of machine learning, including auto data collection and cleaning, auto feature engineering, and auto model selection and optimization, etc. Due to the popularity of deep learning models, hyper-parameter optimization (HPO) [24; 25; 26] and neural architecture search (NAS) [27] are most widely studied. AutoML has achieved or surpassed humanlevel performance [28; 29; 30] with little human guidance in areas such as computer vision [31; 32] . Automated machine learning on graphs, combining the advantages of AutoML and graph machine learning, naturally serves as a promising research direction to further boost the model performance, which has attracted an increasing number of interests from the community. In this paper, we provide a comprehensive and systematic review of automated machine learning on graphs, to the best of our knowledge, for the first time. Specifically, we focus on two major topics: HPO and NAS of graph machine learning. For HPO, we focus on how to develop scalable methods. For NAS, we follow the literature and compare different methods from search spaces, search strategies, and performance estimation strategies. How different methods tackle the challenges of AutoML on graphs are discussed along the way. Then, we review libraries related to automated graph machine learning and discuss AutoGL, the first dedicated framework and open-source library for automated machine learning on graphs. We high-light the design principles of AutoGL and briefly introduce its usages, which are all specially designed for AutoML on graphs. We believe our review in this paper will significantly facilitate and further promote the studies and applications of automated machine learning on graphs. The rest of the paper is organized as follows. In Section 2, we point out the challenges for automated graph machine learning and briefly introduce basic formulations of machine learning on graphs and AutoML. We comprehensively review HPO on graph machine learning in Section 3 and NAS for graph machine learning in Section 4, followed by our overview and discussions of related libraries in Section 5. Lastly, we outline future research opportunities in Section 6. Automated Machine Learning on Graphs Automated machine learning on graphs, which non-trivially combines the strength of AutoML and graph machine learning, faces the following challenges. • The uniqueness of graph machine learning: Unlike audio, image, or text, which has a grid structure, graph data lies in a non-Euclidean space [33] . Thus, graph machine learning usually has unique architectures and designs. For example, typical NAS methods focus on the search space for convolution and recurrent operations, which is distinct from the building blocks of GNNs [34] . • Complexity and diversity of graph tasks: As aforementioned, graph tasks per se are complex and diverse, ranging from node-level to graph-level problems, and with different settings, objectives, and constraints [35] . How to impose proper inductive bias and integrate domain knowledge into a graph AutoML method is indispensable. • Scalability: Many real graphs such as social networks or the Web are incredibly large-scale with billions of nodes and edges [36] . Besides, the nodes in the graph are interconnected and cannot be treated as independent samples. Designing scalable AutoML algorithms for graphs poses significant challenges since both graph machine learning and AutoML are already notorious for being compute-intensive. Approaches with HPO or NAS for graph machine learning reviewed in later sections target handling at least one of these three challenges. We briefly introduce basic problem formulations before moving to the next section. Machine Learning on Graphs Consider a graph G = (V, E) where V = v 1 , v 2 , ..., v |V| is a set of nodes and E ⊆ V × V is a set of edges. The neighborhood of node v i is denoted as N (i) = {v j : (v i , v j ) ∈ E}. The nodes can also have features denoted as F ∈ R |V|×f , where f is the number of features. We use bold uppercases (e.g., X) and bold lowercases (e.g., x) to represent matrices and vectors, respectively. Most tasks of graph machine learning can be divided into the following two categories: • Node-level tasks: the tasks are associated with individual nodes or pairs of nodes. Typical examples include node classification and link prediction. • Graph-level tasks: the tasks are associated with the whole graph, such as graph classification and graph generation. For node-level tasks, graph machine learning models usually learn a node representation H ∈ R |V|×d and then adopt a classifier or predictor on the node representation to solve the task. For graph-level tasks, a representation for the whole graph is learned and fed into a classifier/predictor. GNNs are the current state-of-the-art in learning node and graph representations. The message-passing framework of GNNs [37] is formulated as follows. m (l) i = AGG (l) a (l) ij W (l) h (l) i , ∀j ∈ N (i) (1) h (l+1) i = σ COMBINE (l) m (l) i , h (l) i , (2) where h (l) i denotes the node representation of node v i in the l th layer, m (l) is the message for node v i , AGG (l) (•) is the aggregation function, a (l) ij denotes the weights from node v j to node v i , COMBINE (l) (•) is the combining function, W (l) are learnable weights, and σ(•) is an activation function. The node representation is usually initialized as node features H (0) = F, and the final representation is obtained after L message-passing layers H = H (L) . For the graph-level representation, pooling methods (also called readout) are applied to the node representations h G = POOL (H) , (3) i.e., h G is the representation of G. AutoML Many AutoML algorithms such as HPO and NAS can be formulated as the following bi-level optimization problem: min α∈A L val (W * (α), α) s.t. W * (α) = arg min W (L train (W, α)) , (4) where α is the optimization objective of the AutoML algorithm, e.g., hyper-parameters in HPO and neural architectures in NAS, A is the feasible space for the objective, and W(α) are trainable weights in the graph machine learning models. Essentially, we aim to optimize the objective in the feasible space so that the model achieves the best results in terms of a validation function, and W * indicates that the weights are fully optimized in terms of a training function. Different Au-toML methods differ in how the feasible space is designed and how the objective functions are instantiated and optimized since directly optimizing Eq. ( 4 ) requires enumerating and training every feasible objective, which is prohibitive. Typical formulations of AutoML on graphs need to properly integrate the above formulations in Section 2.1 and Section 2.2 to form a new optimization problem. In this section, we review HPO for machine learning on graphs. The main challenge here is scalability, i.e., a real graph can have billions of nodes and edges, and each trial on the graph is computationally expensive. Next, we elaborate on how different methods tackle the efficiency challenge. Notice that we omit some straightforward HPO methods such as random search and grid search [24] . AutoNE [38] first tackles the efficiency problem of HPO on graphs by proposing a transfer paradigm that samples subgraphs as proxies for the large graph, which is similar in principle to sampling instances in previous HPO methods [39] . Specifically, AutoNE has three modules: the sampling module, the signature extraction module, and the meta-learning module. In the sampling module, multiple representative subgraphs are sampled from the large graph using a multistart random walk strategy. Then, AutoNE conducts HPO on the sampled subgraphs using Bayesian optimization [26] and learns representations of subgraphs using the signature extraction module. Finally, the meta-learning module extracts meta-knowledge from HPO results and representations of subgraphs. AutoNE fine-tunes hyper-parameters on the large graph using the meta-knowledge. In this way, Au-toNE achieves satisfactory results while maintaining scalability since multiple HPO trials on the sampled subgraphs and a few HPO trails on the large graph are properly integrated. JITuNE [40] proposes to replace the sampling process of AutoNE with graph coarsening to generate a hierarchical graph synopsis. A similarity measurement module is proposed to ensure that the coarsened graph shares sufficient similarity with the large graph. Compared with sampling, such graph synopsis can better preserve graph structural information. Therefore, JITuNE argues that the best hyperparameters in the graph synopsis can be directly transferred to the large graph. Besides, since the graph synopsis is generated in a hierarchy, the granularity can be more easily adjusted to meet the time constraints of downstream tasks. HESGA [41] proposes another strategy to improve efficiency using a hierarchical evaluation strategy together with evolutionary algorithms. Specifically, HESGA proposes to evaluate the potential of hyper-parameters by interrupting training after a few epochs and calculating the performance gap with respect to the initial performance with random model weights. This gap is used as a fast score to filter out unpromising hyper-parameters. Then, the standard full evaluation, i.e., training until convergence, is adopted as the final assessor to select the best hyper-parameters to be stored in the population of the evolutionary algorithm. Besides efficiency, AutoGM [42] focuses on proposing a unified framework for various graph machine learning algorithms. Specifically, AutoGM finds that many popular GNNs can be characterized in a framework similar to Eq. ( 1 ) with five hyper-parameters: the number of message-passing neighbors, the number of message-passing steps, the aggregation function, the dimensionality, and the non-linearity. Au-toGM adopts Bayesian optimization to optimize these hyperparameters. NAS for Graph Machine Learning NAS methods can be compared in three aspects [27] : search space, search strategy, and performance estimation strategy. Next, we review NAS methods for graph machine learning from these three aspects. We mainly review NAS for GNNs fitting Eq. ( 1 ) and summarize the characteristics of different methods in Table 1 . Search Space The first challenge of NAS on graphs is the search space design since the building blocks of graph machine learning are usually distinct from other deep learning models such as CNNs or RNNs. For GNNs, the search space can be divided into the following four categories. Micro Search Space Following the message-passing framework in Eq. ( 1 ), the micro search space defines how nodes exchange messages with others in each layer. Commonly adopted micro search spaces [34; 43] compose the following components: • Aggregation function AGG(•): SUM, MEAN, MAX, and MLP. • Aggregation weights aij: common choices are listed in Table 2 . • Number of heads when using attentions: 1, 2, 4, 6, 8, 16, etc. • Combining function COMBINE(•): CONCAT, ADD, and MLP. • Dimensionality of h l : 8, 16, 32, 64, 128, 256, 512, etc. • Non-linear activation function σ(•): Sigmoid, Tanh, ReLU, Identity, Softplus, Leaky ReLU, ReLU6, and ELU. However, directly searching all these components results in thousands of possible choices in a single message-passing layer. Thus, it may be beneficial to prune the space to focus on a few crucial components depending on applications and domain knowledge [44] . Macro Search Space Similar to residual connections and dense connections in CNNs, node representations in one layer of GNNs do not necessarily solely depend on the immediate previous layer [62; 63] . These connectivity patterns between layers form the macro search space. Formally, such designs are formulated as H (l) = j<l F jl H (j) , (5) where F jl (•) can be the message-passing layer in Eq. ( 1 ), ZERO (i.e., not connecting), IDENTITY (e.g., residual connections), or an MLP. Since the dimensionality of H (j) can vary, IDENTITY can only be adopted if the dimensionality of each layer matches. Pooling Methods In order to handle graph-level tasks, information from all the nodes is aggregated to form graph-level representations using the pooling operation in Eq (3) . [51] propose a pooling search space including row-or column-wise sum, mean, or maximum, attention pooling, attention sum, and flatten. More advanced methods such as hierarchical pooling [64] could also be added to the search space with careful designs. Method Search space Tasks Search Strategy Performance Other Characteristics Micro Macro Pooling HP Layers Node Graph Estimation -GraphNAS [34] Fixed RNN controller + RL --AGNN [43] Fixed Self-designed controller + RL Inherit weights -SNAG [44] Fixed RNN controller + RL Inherit weights Simplify the micro search space PDNAS [45] Fixed Differentiable Single-path one-shot -POSE [46] Fixed Differentiable Single-path one-shot Support heterogenous graphs NAS-GNN [47] Fixed Evolutionary algorithm --AutoGraph [48] Various Evolutionary algorithm --GeneticGNN [49] Fixed Evolutionary algorithm --EGAN [50] Fixed Differentiable One-shot Sample small graphs for efficiency NAS-GCN [51] Fixed Evolutionary algorithm -Handle edge features LPGNAS [52] Fixed Differentiable Single-path one-shot Search for quantisation options You et al. [53] Various Random search -Transfer across datasets and tasks SAGS [54] Fixed Self-designed algorithm --Peng et al. [55] Fixed CEM-RL [56] -Search spatial-temporal modules GNAS [57] Various Differentiable One-shot -AutoSTG [58] Fixed Differentiable One-shot+meta learning Search spatial-temporal modules DSS [59] Fixed Differentiable One-shot Dynamically update search space SANE [60] Fixed Differentiable One-shot -AutoAttend [61] Fixed Evolutionary algorithm One-shot Cross-layer attention Table 1 : A summary of different NAS methods for graph machine learnings. Type Formulation CONST a const ij = 1 GCN a gcn ij = 1 √ |N (i)||N (j)| GAT a gat ij = LeakyReLU (ATT (Wa [hi, hj])) SYM-GAT a sym ij = a gat ij + a gat ji COS a cos ij = cos (Wahi, Wahj) LINEAR a lin ij = tanh (sum (Wahi + Wahj)) GENE-LINEAR a gene ij = tanh (sum (Wahi + Wahj)) W a Table 2: A typical search space of different aggregation weights. Hyper-parameters Besides architectures, other training hyper-parameters can be incorporated into the search space, i.e., similar to jointly conducting NAS and HPO. Typical hyper-parameters include the learning rate, the number of epochs, the batch size, the optimizer, the dropout rate, and the regularization strengths such as the weight decay. These hyper-parameters can be jointly optimized with architectures or separately optimized after the best architectures are found. HPO methods in Section 3 can also be combined here. Another critical choice is the number of message-passing layers. Unlike CNNs, most currently successful GNNs are shallow, e.g., with no more than three layers, possibly due to the over-smoothing problem [65; 62] . Limited by this problem, the existing NAS methods for GNNs usually preset the number of layers as a small fixed number. How to automatically design deep GNNs while integrating techniques to alleviate over-smoothing remains mostly unexplored. On the other hand, NAS may also bring insights to help to tackle the over-smoothing problem [34] . Search Strategy Search strategies can be broadly divided into three categories: architecture controllers trained with reinforcement learning (RL), differentiable methods, and evolutionary algorithms. Controller + RL A widely adopted NAS search strategy uses a controller to generate the neural architecture descriptions and train the controller with reinforcement learning to maximize the model performance as rewards. For example, if we consider neural architecture descriptions as a sequence, we can use RNNs as the controller [28] . Such methods can be directly applied to GNNs with a suitable search space and performance evaluation strategy. Differentiable Differentiable NAS methods such as DARTS [29] and SNAS [66] have gained popularity in recent years. Instead of optimizing different operations separately, differentiable methods construct a single super-network (known as the oneshot model) containing all possible operations. Formally, we denote (6) where o (x,y) (x) is an operation in the GNN with input x and output y, O are all candidate operations, and z (x,y) are learnable vectors to control which operation is selected. Briefly speaking, each operation is regarded as a probability distribution of all possible operations. In this way, the architecture and model weights can be jointly optimized via gradientbased algorithms. The main challenges lie in making the NAS algorithm differentiable, where several techniques such as Gumbel-softmax [67] and concrete distribution [68] are resorted to. When applied to GNNs, slight modification may be needed to incorporate the specific operations defined in the search space. y = o (x,y) (x) = o∈O exp(z (x,y) o ) o ∈O exp(z (x,y) o ) o(x), Evolutionary Algorithms Evolutionary algorithms are a class of optimization algorithms inspired by biological evolution. For NAS, randomly generated architectures are considered initial individuals in a population. Then, new architectures are generated using mutations and crossover operations on the population. The architectures are evaluated and selected to form the new population, and the same process is repeated. The best architectures are recorded while updating the population, and the final solutions are obtained after sufficient updating steps. For GNNs, regularized evolution (RE) NAS [32] has been widely adopted. RE's core idea is an aging mechanism, i.e., in the selection process, the oldest individuals in the population are removed. Genetic-GNN [69] also proposes an evolution process to alternatively update the GNN architecture and the learning hyper-parameters to find the best fit of each other. Combinations It is also feasible to combine these three types of search strategies mentioned above. For example, AGNN [43] proposes a reinforced conservative search strategy by adopting both RNNs and evolutionary algorithms in the controller and train the controller with RL. By only generating slightly different architectures, the controller can find well-performing GNNs more efficiently. [55] adopt CEM-RL [56] , which combines evolutionary and differentiable methods. Performance Estimation Strategy Due to the large number of possible architectures, it is infeasible to fully train each architecture independently. Next, we review some performance estimation strategies. A commonly adopted \"trick\" to speed up performance estimation is to reduce fidelity [27] , e.g., by reducing the number of epochs or the number of data points. This strategy can be directly generalized to GNNs. Another strategy successfully applied to CNNs is sharing weights among different models, known as parameter sharing or weight sharing [30] . For differentiable NAS with a large one-shot model, parameter sharing is naturally achieved since the architectures and weights are jointly trained. However, training the one-shot model may be difficult since it contains all possible operations. To further speed up the training process, single-path one-shot model [70] has been proposed where only one operation between an input and output pair is activated during each pass. For NAS without a one-shot model, sharing weights among different architecture is more difficult but not entirely impossible. For example, since it is known that some convolutional filters are common feature extractors, inheriting weights from previous architectures is feasible and reasonable in CNNs [71] . However, since there is still a lack of understandings of what weights in GNNs represent, we need to be more cautious about inheriting weights [44] . AGNN [43] proposes three constraints for parameter inheritance: same weight shapes, same attention and activation functions, and no parameter sharing in batch normalization and skip connections. Discussions The Search Space Besides the basic search space presented in Section 4.1, different graph tasks may require other search spaces. For example, meta-paths are critical for heterogeneous graphs [46] , edge features are essential in modeling molecular graphs [51] , and spatial-temporal modules are needed in skeleton-based recognition [55] . Sampling mechanisms to accelerate GNNs are also critical, especially for large-scale graphs [34] . A suitable search space usually requires careful designs and domain knowledge. Transferability It is non-trivial to transfer GNN architectures across different datasets and tasks due to the complexity and diversity of graph tasks. [72] adopt a fixed set of GNNs as anchors on different tasks and datasets. Then, the rank correlation serves as a metric to measure the similarities between different datasets and tasks. The best-performing GNNs of the most similar tasks are transferred to solve the target task. The Efficiency Challenge of Large-scale Graphs Similar to AutoNE introduced in Section 3, EGAN [50] proposes to sample small graphs as proxies and conduct NAS on the sampled subgraphs to improve the efficiency of NAS. While achieving some progress, more advanced and principle approaches are further needed to handle billion-scale graphs. Libraries for AutoML on Graphs Publicly available libraries are important to facilitate and advance the research and applications of AutoML on graphs. Popular libraries for graph machine learning include PyTorch Geometric [73] , Deep Graph Library [74] , GraphNets [75] , AliGraph [76] , Euler [77] , PBG [78] , Stellar Graph [79] , Spektral [80] , CodDL [81] , OpenNE [82] , GEM [83] , Karateclub [84] , DIG [85] , and classical NetworkX [86] . However, these libraries do not support AutoML. On the other hand, AutoML libraries such as NNI [87] , Au-toKeras [88] , AutoSklearn [89] , Hyperopt [90] , TPOT [91] , AutoGluon [92] , MLBox [93] , and MLJAR [94] are widely adopted. Unfortunately, because of the uniqueness and complexity of graph tasks, they cannot be directly applied to automate graph machine learning. Recently, some HPO and NAS methods for graphs such as AutoNE [38] , AutoGM [42] , GraphNAS [34] Graph-Gym [53] have open-sourced their codes, facilitating reproducibility and promoting AutoML on graphs. Besides, Au-toGL [95] foot_0 , the first dedicated library for automated graph learning, is developed. Next, we review AutoGL in detail. Figure 1 shows the overall framework of AutoGL. The main characteristics of AutoGL are three-folded: • Open-source: all the source codes of AutoGL are publicly available under the MIT license. • Easy to use: AutoGL is designed to be easy to use. For example, less than ten lines of codes are needed to conduct some quick experiments of AutoGL. • Flexible to be extended: AutoGL adopts a modular design with high-level base classes API and extensive documentations, allowing flexible and customized extensions. We briefly review the dataset management and four core components of AutoGL: Auto Feature Engineering, Model Training, Hyper-Parameters Optimization, and Auto Ensemble. These components are designed in a modular and objectoriented fashion to enable clear logic flows, easy usages, and flexibility in extending. AutoGL Dataset. inherits from PyTorch Geometric [73] , covering common benchmarks for node and graph classification, including the recent Open Graph Benchmark [35] . Users can easily add customized datasets following documentations. Auto Feature Engineering. module first processes the graph data using three categories of operations: generators, where new node and edge features are constructed; selectors, filtering out and compressing useless and meaningless features; sub-graph generators, generating graph-level features. Convenient wrappers are also provided to support PyTorch Geometric and NetworkX [96]. Model Training. module handles the training and evaluation process of graph tasks with two functional sub-modules: model and trainer. Model handles the construction of graph machine learning models, e.g., GNNs, by defining learnable parameters and the forward pass. Trainer controls the optimization process for the given model. Common optimization methods, training controls, and regularization methods are packaged as high-level APIs. Hyper-Parameter Optimization. module conducts HPO for a specified model, covering methods presented in Section 3 such as AutoNE and general-purpose algorithms like random search [24] and Tree Parzen Estimator [97] . The model training module can specify the hyper-parameters, their types (e.g., integer, numerical, or categorical), and feasible ranges. Users can also customize HPO algorithms. Auto Ensemble. module can automatically integrate the optimized individual models to form a more powerful final model. Two kinds of ensemble methods are provided: voting and stacking. Voting is a simple yet powerful ensemble method that directly averages the output of individual models while stacking trains another meta-model that learns to combine the output of models in a more principled way. The general linear model (GLM) and gradient boosting machine (GBM) are supported as meta-models. AutoGL Solver. On top of the four modules, another highlevel API Solver is proposed to control the overall pipeline. In the Solver, the four modules are organized to form the Au-toML solution for graph data. The Solver also provides global controls. For example, the time budget can be explicitly set, and the training/evaluation protocols can be selected. AutoGL is still actively updated. Key features to be released shortly include neural architecture search, large-scale datasets support, and more graph tasks. For the most up-todate information, please visit the project homepage. All kinds of inputs and suggestions are also warmly welcomed. Future Directions • Graph models for AutoML: In this paper, we mainly focus on how AutoML methods are extended to graphs. The other direction, i.e., using graphs to help AutoML, is also feasible and promising. For example, we can model neural networks as a directed acyclic graph (DAG) to analyze their structures [98; 72] or adopt GNNs to facilitate NAS [99; 100; 69] . Ultimately, we expect graphs and AutoML to form tighter connections and further facilitate each other. • Robustness and explainability: Since many graph applications are risk-sensitive, e.g., finance and healthcare, model robustness and explainability are indispensable for actual usages. Though there exist some initial studies on the robustness [101] and explainability [102] of graph machine learning, how to generalize these techniques into AutoML on graphs remains to be further explored [103] . • Hardware-aware models: To further improve the scalability of automated machine learning on graphs, hardware-aware models may be a critical step, especially in real industrial environments. Both hardware-aware graph models [104] and hardware-aware AutoML models [105; 106; 107] have been studied, but integrating these techniques still poses significant challenges. • Comprehensive evaluation protocols: Currently, most AutoML on graphs are tested on small traditional benchmarks such as three citation graphs, i.e., Cora, Cite-Seer, and PubMed [108] . However, these benchmarks have been identified as insufficient to compare different graph machine learning models [109] , not to mention AutoML on graphs. More comprehensive evaluation protocols are needed, e.g., on recently proposed graph machine learning benchmarks [35; 110] or new dedicated graph AutoML benchmarks similar to the NASbench series [111] . Figure 1 : 1 Figure 1: The overall framework of AutoGL. AutoGL homepage: https://mn.cs.tsinghua.edu.cn/AutoGL"
}