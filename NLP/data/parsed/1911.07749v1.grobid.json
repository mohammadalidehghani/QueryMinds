{
  "title": "On the computation of counterfactual explanations -A survey",
  "abstract": "Due to the increasing use of machine learning in practice it becomes more and more important to be able to explain the prediction and behavior of machine learning models. An instance of explanations are counterfactual explanations which provide an intuitive and useful explanations of machine learning models. In this survey we review model-specific methods for efficiently computing counterfactual explanations of many different machine learning models and propose methods for models that have not been considered in literature so far.",
  "introduction": "Introduction Due to recent advances in machine learning (ML), ML methods are increasingly use in real world scenarios [1] [2] [3] [4] . Especially, ML technology is nowadays used in critical situations like predictive policing [5] and loan approval [6] . In order to increase trust and acceptance of these kind of technology, it is important to be able to explain the behaviour and prediction of these models [7] -in particular answer questions like \"Why did the model do that? And why not smth. else?\". This becomes even more important in view to legal regulations like the EU regulation on GDPR [8] , that grants the user a right to an explanation. A popular method for explaining models [7, [9] [10] [11] are counterfactual explanations (often just called counterfactuals) [12] . A counterfactual explanation states changes to some features that lead to a different (specified) behaviour or prediction of the model. Thus, counterfactual explanation can be interpreted as a recommendation what to do in order to achieve a requested goal. This is why counterfactual explanations are that popular -they are intuitive and user-friendly [7, 12] . Counterfactual explanations are an instance of model-agnostic methods. Therefore, counterfactuals are not tailored to a particular model but can be computed for all possible models (in theory). Other instances of model-agnostic methods are feature interaction methods [13] , feature importance methods [14] , partial dependency plots [15] and local methods that approximates the model locally by an explainable model (e.g. a decisiontree) [16, 17] . The nice thing about model-agnostic methods is that they (in theory) do not need access to model internals and/or training data -it is sufficient to have an interface where we can pass data points to the model and observe the output/predictions of the model. However, it turns out that efficiently computing high quality counterfactual explanations of black-box models can be very difficult [18] . Therefore, it is beneficial to develop model-specific methods -that use model internals -for efficiently computing counterfactual explanations. Whenever we have access to model internals, we can use the model-specific method over the model-agnostic method for efficiently computing counterfactual explanations. In this work we focus on such model-specific methods. In particular, our contributions are: • We review model-specific methods for efficiently computing counterfactual explanations of different ML models. • We propose model-specific methods for efficiently computing counterfactual explanations of models that have not been considered in literature so far. The remainder of this paper is structured as follows: First, we briefly review counterfactual explanations (section 2). Then, in section 3 we review and propose model-specific methods for computing counterfactual explanations. Finally, section 5 summarizes this papers. All derivations and mathematical details can be found in the appendix (section 6).",
  "body": "Introduction Due to recent advances in machine learning (ML), ML methods are increasingly use in real world scenarios [1] [2] [3] [4] . Especially, ML technology is nowadays used in critical situations like predictive policing [5] and loan approval [6] . In order to increase trust and acceptance of these kind of technology, it is important to be able to explain the behaviour and prediction of these models [7] -in particular answer questions like \"Why did the model do that? And why not smth. else?\". This becomes even more important in view to legal regulations like the EU regulation on GDPR [8] , that grants the user a right to an explanation. A popular method for explaining models [7, [9] [10] [11] are counterfactual explanations (often just called counterfactuals) [12] . A counterfactual explanation states changes to some features that lead to a different (specified) behaviour or prediction of the model. Thus, counterfactual explanation can be interpreted as a recommendation what to do in order to achieve a requested goal. This is why counterfactual explanations are that popular -they are intuitive and user-friendly [7, 12] . Counterfactual explanations are an instance of model-agnostic methods. Therefore, counterfactuals are not tailored to a particular model but can be computed for all possible models (in theory). Other instances of model-agnostic methods are feature interaction methods [13] , feature importance methods [14] , partial dependency plots [15] and local methods that approximates the model locally by an explainable model (e.g. a decisiontree) [16, 17] . The nice thing about model-agnostic methods is that they (in theory) do not need access to model internals and/or training data -it is sufficient to have an interface where we can pass data points to the model and observe the output/predictions of the model. However, it turns out that efficiently computing high quality counterfactual explanations of black-box models can be very difficult [18] . Therefore, it is beneficial to develop model-specific methods -that use model internals -for efficiently computing counterfactual explanations. Whenever we have access to model internals, we can use the model-specific method over the model-agnostic method for efficiently computing counterfactual explanations. In this work we focus on such model-specific methods. In particular, our contributions are: • We review model-specific methods for efficiently computing counterfactual explanations of different ML models. • We propose model-specific methods for efficiently computing counterfactual explanations of models that have not been considered in literature so far. The remainder of this paper is structured as follows: First, we briefly review counterfactual explanations (section 2). Then, in section 3 we review and propose model-specific methods for computing counterfactual explanations. Finally, section 5 summarizes this papers. All derivations and mathematical details can be found in the appendix (section 6). Counterfactual explanations Counterfactual explanations [12] (often just called counterfactuals) are an instance of example-based explanations [19] . Other instances of example-based explanations [7] are influential instances [20] and prototypes & criticisms [21] . A counterfactual states a change to some features/dimensions of a given input such that the resulting data point (called counterfactual) has a different (specified) prediction than the original input. Using a counterfactual instance for explaining the prediction of the original input is considered to be fairly intuitive, human-friendly and useful because it tells people what to do in order to achieve a desired outcome [7, 12] . A classical use case of counterfactual explanations is loan application [6, 7] : Imagine you applied for a credit at a bank. Unfortunately, the bank rejects your application. Now, you would like to know why. In particular, you would like to know what would have to be different so that your application would have been accepted. A possible explanation might be that you would have been accepted if you would earn 500$ more per month and if you would not have a second credit card. Although counterfactuals constitute very intuitive explanation mechanisms, there do exist a couple of problems. One problem is that there often exist more than one counterfactual -this is called Rashomon effect [7] . If there are more than one possible explanation (counterfactual), it is not clear which one should be selected. An alternative -but very similar in the spirit -to counterfactuals [12] is the Growing Spheres method [22] . However, this method suffers from the curse of dimensionality because it has to draw samples from the input space, which can become difficult if the input space is high-dimensional. According to [12] , we formally define the finding of a counterfactual as follows: Assume a prediction function h : X → Y is given. Computing a counterfactual x ′ ∈ R d of a given input x ∈ R d1 can be interpreted as an optimization problem: arg min x ′ ∈ R d ℓ h( x ′ ), y ′ + C • θ( x ′ , x) (1) where ℓ() denotes a loss function that penalizes deviation of the prediction h( x ′ ) from the requested prediction y ′ . θ() denotes a regularization that penalizes deviations from the original input x and the hyperparameter C denotes the regularization strength. Two common regularizations are the weighted Manhattan distance and the generalized L2 distance. The weighted Manhattan distance is defined as θ( x ′ , x) = j α j • |( x) j -( x ′ ) j | (2) where α j > 0 denote the feature wise weights. A popular choice [12] for α j is the inverse median absolute deviation of the j-th feature median in the training data set D: α j = 1 MAD j where MAD j = median x ∈ D ( x) j -median x ∈ D ( x) j (3) The weights α j compensate for the (potentially) different variability of the features. However, because we need access to the training data set D, this regularization is not a truly model-agnostic method -it is not usable if we only have access to a prediction interface of a black-box model. Although counterfactual explanations are a model-agnostic method, the computation of a counterfactual becomes much more efficient when having access to the internals of the model. In this work we assume that we have access to all needed model internals as well as access to the training data set -we will only need the training data for computing the weights α j in the weighted Manhattan distance Eq. 2. We do not need access to the training data if we do not use the weighted Manhattan distance or if we use some other methods for computing the weights α j (e.g. setting all weights to 1). A slightly modified version of Eq. 1 was proposed in [23] . The authors claim that the original formalization in Eq. 1 does not take into account that the counterfactual should lie on the data manifold -the counterfactual should be a plausible data instance. To deal with this issue, the authors propose to add two additional terms to the original objective Eq. 1: 1. The distance/norm between the counterfactual x ′ and the reconstructed version of it that has been computed by using a pretrained autoencoder. 2. The distance/norm between the encoding of the counterfactual x ′ and the mean encoding of training samples that belong to the requested class y ′ . The first term is supposed to make sure that the counterfactual x ′ lies on the data manifold and thus is a plausible data instance. The second term is supposed to accelerate the solver for computing the solution of the final optimization problem. Both claims have been evaluated empirically [23] . Recently, another approach for computing plausible/feasible counterfactual explanations was proposed [24] . Instead of computing a single counterfactual, the authors propose to compute a path of intermediate counterfactuals that lead to the final counterfactual. The idea behind this path of intermediate counterfactuals is to provide the user with a set of intermediate goals that finally lead to the desired goal -it might be more feasible to \"go into the direction\" of the final goal step by step instead of accomplishing it in a single step. In order to compute such a path of intermediate counterfactuals, the authors propose different strategies for constructing a graph on the training data set -including the query point. In this graph, two samples are connected by a weighted edge if they are \"sufficient close to each other\" -the authors propose different measurements for closeness (e.g. based on density estimation). The path of intermediate counterfactuals is equal to the shortest path between the query point and a point that satisfies the desired goal -this is the final counterfactual. Therefore the final counterfactual as well as all intermediate counterfactuals are elements from the training data set. Despite the highlighted issues [23, 24] of the original formalization Eq. 1, we stick to it and leave further investigations on the computation of feasible & plausible counterfactuals as future research. However, many of the approaches for computing counterfactuals -that are discussed in this paper -can be augmented to restrict the space of potential counterfactuals. These restrictions provide an opportunity for encoding domain knowledge that lead to more plausible and feasible counterfactuals. Computation of counterfactuals In the subsequent sections we explore model-specific methods for efficiently computing counterfactual explanations of many different ML models. But before looking at model-specific methods, we first (section 3.1) discuss methods for dealing with arbitrary types of models -gradient based as well as gradient free methods. Note that for the purpose of better readability and due to space constraints, we put all derivations in the appendix (section 6). The general case We can compute a counterfactual explanation of any model we like by plugging the prediction function h of the model into Eq. 1 and choosing a loss (eq. 0-1 loss) and regularization (e.g. Manhattan distance) function. Depending on the model, loss and regularization function, the resulting optimization problem might be differentiable or not. If it is differentiable, we can use gradient-based methods like (L-)BFGS and conjugate gradients for solving the optimization problem. If Eq. 1 is not differentiable, we can use gradient-free methods like the Downhill-Simplex method or an evolutionary algorithm like CMA-ES or CERTIFAI [25] -the nice thing about evolutionary algorithms is that they can easily deal with categorical features. Another approach, limited to linear classifiers, for handling contious and discrete features is to use mixed-integer programming (MIP) [26] . Unfortuantely, solving a MIP is NP-hard. However, there exist solvers that can compute an approximate solution very efficiently. Popular methods are branchand-bound and branch-and-cut algorithms [27] . When developing model-specific methods for computing counterfactuals, we always consider untransformed inputs only -since a non-linear feature transformation usually makes the problem non-convex. Furthermore, we only consider the Euclidean distance and the weighted Manhattan distance as candidates for the regularization function θ(•). Separating hyperplane models A model whose prediction function h can be written as: h( x) = sign( w ⊤ x + b) (4) is called a separating hyperplane model. Popular instances of separating hyperplane models are SVM, LDA, perceptron and logistic regression. Without loss of generality, we assume Y = {-1, 1}. Then, the optimization problem for computing a counterfactual explanation Eq. 1 can be rewritten as: arg min x ′ ∈ R d θ( x ′ , x) s.t. q ⊤ x ′ + c < 0 (5) where q = -y ′ w (6) c = -by ′ (7) Depending on the regularization, the optimization problem Eq. 5 becomes either a linear program (LP) -if the weighted Manhattan distance is used -or a convex quadratic program (QP) with linear constraints -if the Euclidean distance is used. More details can be found in the appendix (section 6.2). If we would have some discrete features instead of contious features only, we would obtain a MIP or MIQP as described in [26] . Generalized linear model In a generalized linear model we assume that the distribution of the response variable belongs to the exponential family. The expected value is connected to a linear combination of features by a link function, where different distributions have different link functions. In the subsequent sections, we explore how to efficiently compute counterfactual explanations of popular instances of the generalized model. Logistic regression In logistic regression we model the response variable as a Bernoulli distribution. The prediction function h of a logistic regression model is given as h( x) = 1 if p(y = 1 | x) ≥ t -1 otherwise ( 8 ) where t is the discrimination threshold (often t = 0.5) and p(y = 1 | x) = 1 1 + exp(-w ⊤ x -b) (9) When ignoring all probabilities and setting t = 0.5, the prediction function h of a logistic regression model becomes a separating hyperplane: h( x) = sign( w ⊤ x + b) (10) Therefore, computing a counterfactual of a logistic regression model is exactly the same as for a separating hyperplane model (section 3.2). Softmax regression In softmax regression we model the distribution of the response variable as a generalized Bernoulli distribution. The prediction function h of a softmax regression model is given as: h( x) = arg max i ∈ Y exp( w ⊤ i x + b i ) k exp( w ⊤ k x + b k ) (11) In this case, the optimization problem for computing a counterfactual explanation Eq. 1 can be rewritten as: arg min x ′ ∈ R d θ( x ′ , x) s.t. q ⊤ ij x ′ + c ij < 0 ∀ j ∈ Y, j = i = y ′ (12) where q ij = w j -w i (13) c ij = b j -b i (14) Depending on the regularization, the optimization problem Eq. 12 becomes either a LP -if the weighted Manhattan distance is used -or a convex QP with linear constraints -if the Euclidean distance is used. More information can be found in the appendix (section 6.3.1). Linear regression In linear regression we model the distribution of the response variable as a Gaussian distribution. The prediction function f of a linear regression model is given as: f ( x) = w ⊤ x + b (15) The optimization problem for computing a counterfactual explanation Eq. 1 can be rewritten as: arg min x ′ ∈ R d θ( x ′ , x) s.t. w ⊤ x ′ + c ≤ ǫ -w ⊤ x ′ -c ≤ ǫ (16) where c = b -y ′ (17) and ǫ ≥ 0 denotes the tolerated deviation from the requested prediction y ′ . Depending on the regularization, the optimization problem Eq. 16 becomes either a LP (if the weighted Manhattan distance is used) or a convex QP with linear constraints (if the Euclidean distance is used). More information can be found in the appendix (section 6.3.2). Poisson regression In Poisson regression we model the distribution of the response variable as a Poisson distribution. The prediction function f of a Poisson regression model is given as: f ( x) = exp( w ⊤ x + b) (18) In this case, the optimization problem for computing a counterfactual explanation Eq. 1 can be rewritten as: arg min x ′ ∈ R d θ( x ′ , x) s.t. w ⊤ x ′ + c ≤ ǫ -w ⊤ x ′ -c ≤ ǫ (19) where c = b -log(y ′ ) ( 20 ) and ǫ ≥ 0 denotes the tolerated deviation from the requested prediction y ′ . Depending on the regularization, the optimization problem Eq. 19 becomes either a LP (if the weighted Manhattan distance is used) or a convex QP with linear constraints (if the Euclidean distance is used). More information can be found in the appendix (section 6.3.3). Exponential regression In exponential regression we model the distribution of the response variable as a exponential distribution. The prediction function f of an exponential regression model is given as: f ( x) = - 1 w ⊤ x + b (21) Then, the optimization problem for computing a counterfactual explanation Eq. 1 can be rewritten as: arg min x ′ ∈ R d θ( x ′ , x) s.t. w ⊤ x ′ + c ≤ ǫ -w ⊤ x ′ -c ≤ ǫ (22) where c = b + 1 y ′ (23) and ǫ ≥ 0 denotes the tolerated deviation from the requested prediction y ′ . Depending on the regularization, the optimization problem Eq. 22 becomes either a LP (if the weighted Manhattan distance is used) or a convex QP with linear constraints (if the Euclidean distance is used). More information can be found in the appendix (section 6.3.4). Gaussian naive Bayes The Gaussian naive Bayes model makes the assumption that all features are independent of each other and follow a normal distribution. The prediction function h of a Gaussian naive Bayes model is given as: h( x) = arg max i ∈ Y d k=1 N ( x | µ ik , σ 2 ik )π i ( 24 ) where π i denotes the a-priori probability of the i-th class. The optimization problem for computing a counterfactual explanation Eq. 1 can be rewritten as: arg min x ′ ∈ R d θ( x ′ , x) s.t. x ′⊤ A ij x ′ + q ⊤ ij x ′ + c ij < 0 ∀ j ∈ Y, j = i = y ′ (25) where A ij = diag 1 2σ 2 ik - 1 2σ 2 jk ( 26 ) q ij = µ j1 σ 2 j1 - µ i1 σ 2 i1 , . . . , µ jd σ 2 jd - µ id σ 2 id ⊤ ( 27 ) c ij = log π j π i + d k=1 log   2πσ 2 ik 2πσ 2 jk   - µ 2 jk 2σ 2 jk + µ 2 ik 2σ 2 ik (28) Because we can not make any statement about the definiteness of A ij , the quadratic constraints in Eq. 25 are non-convex. Therefore, the optimization problem Eq. 25 is a non-convex quadratically constrained quadratic program (QCQP). We can approximately solve Eq. 25 by using an approximation method like the Suggest-Improve framework [28] . Furthermore, if we have a binary classification problem, we can solve a semi-definite program (SDP) whose solution is equivalent to Eq. 25. More details can be found in the appendix (sections 6.4,6.9.1 and 6.9.2). Quadratic discriminant analysis In quadratic discriminant analysis (QDA) we model each class distribution as an independent Gaussian distribution -note that in contrast to LDA each class distribution has its own covariance matrix. The prediction function h of a QDA model is given as: h( x) = arg max i ∈ Y N ( x | µ i , Σ i )π i ( 29 ) where π i denotes the a-priori probability of the i-th class. In this case, the optimization problem for computing a counterfactual explanation Eq. 1 can be rewritten as: arg min x ′ ∈ R d θ( x ′ , x) s.t. 1 2 x ′⊤ A ij x ′ + x ′⊤ q ij + c ij < 0 ∀ j ∈ Y, j = i = y ′ (30) where A ij = Σ -1 i -Σ -1 j ( 31 ) q ij = Σ -1 j µ j -Σ -1 i µ i ( 32 ) c ij = 1 2 µ ⊤ i Σ -1 i µ i -µ ⊤ j Σ -1 j µ j + 1 2 log det(Σ i ) det(Σ j ) + log π j π i (33) Because we can not make any statement about the definiteness of A ij , the quadratic constraints in Eq. 30 are non-convex. Thus, like in Gaussian naive Bayes (section 3.4), the optimization problem Eq. 30 is a non-convex QCQP. Like in the case of the previous non-convex QCQPs, we can approximately solve Eq. 30 by using an approximation method. Furthermore, if we have a binary classification problem, we can solve a SDP whose solution is equivalent to Eq. 30. More details can be found in the appendix (sections 6.5,6.9.1 and 6.9.2). Learning vector quantization models Learning vector quantization (LVQ) models [29] compute a set of labeled prototypes {( p i , o i )} from a given training data set -we refer to the i-th prototype as p i and the corresponding label as o i . The prediction function h of a LVQ model is given as: h( x) = o i s.t. min d( x, p i ) ( 34 ) where d() denotes a function for computing the distance between a data point and a prototype -usually this is the Euclidean distance: d( x, p) = ( x -p) ⊤ I( x -p) (35) There exist LVQ models like (L)GMLVQ [30] and (L)MRSLVQ [31] that learn a custom (class or prototype specific) distance matrix Ω p that is used instead of the identity I when computing the distance between a data point and a prototype. This gives rise to the generalized L2 distance: d( x, p) = ( x -p) ⊤ Ω p ( x -p) (36) Because a LVQ model assigns the label of the nearest prototype to a given input, the nearest prototype of a counterfactual must be a prototype p i with o i = y ′ . According to [18] , for computing a counterfactual, it is sufficient to solve the following optimization problem for each prototype p i with o i = y ′ and select the counterfactual x ′ yielding the smallest value of θ( x ′ , x): arg min x ′ ∈ R d θ( x ′ , x) s.t. d( x ′ , p i ) < d( x ′ , p j ) ∀ p j ∈ P(y ′ ) (37) where P(y ′ ) denotes the set of all prototypes not labeled as y ′ . Note that the feasible region of Eq. 37 is always non-empty -the prototype p i is always a feasible solution. In the subsequent sections we explore the type of constraints of Eq. 37 for different LVQ models. (Generalized matrix) LVQ In case of a (generalized matrix) LVQ model -all prototypes use the same distance matrix Ω, the optimization problem Eq. 37 becomes [18] : arg min x ′ ∈ R d θ( x ′ , x) s.t. x ′⊤ q ij + c ij < 0 ∀ p j ∈ P(y ′ ) (38) where q ij = 1 2 Ω( p j -p i ) (39) c ij = 1 2 p ⊤ i Ω p i -p ⊤ j Ω p j (40) Depending on the regularization, the optimization problem Eq. 38 becomes either a LP (if the Euclidean distance is used) or a convex QP with linear constraints (if the weighted Manhattan distance is used). More information can be found in the appendix (section 6.6). (Localized generalized matrix) LVQ In case of a (localiced generalized matrix) LVQ model -there are different, class or prototype specific, distance matrices Ω p , the optimization problem Eq. 37 becomes [18] : arg min x ′ ∈ R d θ( x ′ , x) 1 2 x ′⊤ A ij x ′ + x ′⊤ q ij + c ij < 0 ∀ p j ∈ P(y ′ ) (41) where A ij = Ω i -Ω j ( 42 ) q ij = 1 2 Ω j p j -Ω i p i (43) c ij = 1 2 p ⊤ i Ω i p i -p ⊤ j Ω j p j (44) Because we can not make any statement about the definiteness of A ij , the quadratic constraints in Eq. 41 are non-convex. Thus, like in Gaussian naive Bayes (section 3.4) and QDA (section 3.5), the optimization problem Eq. 41 is a non-convex QCQP. Like the previous non-convex QCQPs, we can approximately solve Eq. 41 by using an approximation method. Furthermore, if we have a binary classification problem and each class is represented by a single prototype, we can solve a SDP whose solution is equivalent to Eq. 41. More details can be found in the appendix (sections 6.6,6.9.1 and 6.9.2). Tree based models Tree based models are very popular in data science because they often achieve a high predictive-accuracy [32] . In the subsequent sections we discuss how to compute counterfactual explanations of tree based models. In particular, we consider decision/regression trees and tree based ensembles like random forest models. Decision trees In case of decision/regression tree models, we can compute a counterfactual by enumerating all possible paths that lead to the requested prediction [17, 33] . However, it might happen that some requested predictions are not possible because all possible predictions of the tree are encoded in the leafs. In this case one might define an interval of acceptable predictions so that a counterfactual exists. The procedure for computing a counterfactual of a decision/regression tree is described in Algorithm 1. Algorithm 1 Computing a counterfactual of a decision/regression tree Input: Original input x, requested prediction y ′ of the counterfactual, the tree model Output: Counterfactual x ′ 1: Enumerate all leafs with prediction y ′ 2: For each leaf, enumerate all paths reaching the leaf 3: For each path, compute the minimal change to x that yields the path 4: Sort all paths according to regularization of the change to x 5: Select the path and the corresponding change to x that minimizes the regularization Tree based ensembles Popular instances of tree based enesmbles are random forest and gradient boosting regression trees. It turns out that the problem of computing a counterfactual explanation of such models is NP-hard [33] . The following heuristic for computing a counterfactual explanation of a random forest model was proposed in [34] : First, we compute a counterfactual of a model from the ensemble. Next, we use this counterfactual as a starting point for minimizing the number of trees that do not outpur the requested prediction by using a gradient-free optimization method like the Downhill-Simplex method. The idea behind this approach is that the counterfactual of a tree from the ensemble is close to the decision boundary of the ensemble so that computing a counterfactual of the ensemble becomes easier. By doing this for all trees in the ensemble, we get many counterfactuals and we can select the one that minimizes the regularization the most. This heuristic seems to work well in practice [34] . Another approach for computing counterfactual explanations of an ensemble of trees was propsed in [33] -although the authors do not call it counterfactuals, they actually compute counterfactuals. Their algorithm works as follows: We iterate over all trees in the ensemble that do not yield the requested prediction. Next, we compute all possible counterfactuals of each of these trees (see section 3.7.1). If this counterfactual turns our to be counterfactual of the ensemble, we store it so that in the end we can select the counterfactual with the smallest deviation from the original input. However, it can not be guaranteed that a counterfactual of the ensemble is found because it might happen that by changing the data point so that it becomes a counterfactual of a particular tree, the prediction of other trees in the ensemble change as well. According to the authors, this algorithm/heuristic works well in practice. Unfortunately, the worst-case complexity is exponential in the number of features and thus it is not suitable for high dimensional data. Implementation The gradient-based and gradient free methods, as well as the model specific methods for tree based models are already implemented in CEML [34] . The implementation of the LVQ specific methods are provided by the authors of [18] . The Python [35] implementation of our proposed methods is available on GitHub foot_1 and is based on the Python packages scikit-learn [36] , numpy [37] and cvxpy [38] . We plan to add these model-specific methods to CEML [34] in the near future. Conclusion In this survey we extensively studied how to compute counterfactual explanations of many different ML models. We reviewed known methods from literature and proposed methods (mostly LPs and (QC)QPs) for computing counterfactuals of ML models that have not been considered in literature so far. Relaxing strict inequalities When modeling the problem of computing counterfactuals, we often obtain strict inequalities like g( x) < 0 (45) Strict inequalities are not allowed in convex programming because the feasible region would become an open set. However, we could turn the < into a ≤ by adding a small number to the left side of the inequality: g( x) + ǫ ≤ 0 (46) where ǫ > 0 is a small number. In practice, when implementing our methods, we found that we can often safely replace all < by ≤ without changing anything else -this might be because of the numerics (like round-off errors) of fixed size floating-point numbers. Separating hyperplane Recall that the prediction function h is given as: h( x) = sign( w ⊤ x + b) (47) If we multiply the projection w ⊤ x + b by the requested prediction y 3 , the result is positive if and only if the classification h( x) is equal to y. Therefore, the linear constraint for predicting class y is given as y w ⊤ x + b > 0 ⇔ q ⊤ x + c < 0 (48) where q = -y w (49) c = -by (50) 6.3 Generalized linear models Softmax regression Recall that the prediction function h is given as: h( x) = arg max i ∈ Y exp( w ⊤ i x + b i ) k exp( w ⊤ k x + b k ) (51) Thus, the constraint for obtaining a specific prediction y ′ is given as: exp( w ⊤ i x + b i ) k exp( w ⊤ k x + b k ) > exp( w ⊤ j x + b j ) k exp( w ⊤ k x + b k ) ∀ j = i = y ′ (52) Holding i and j fixed, we can simplify Eq. 52: exp( w ⊤ i x + b i ) k exp( w ⊤ k x + b k ) > exp( w ⊤ j x + b j ) k exp( w ⊤ k x + b k ) ⇔ exp( w ⊤ i x + b i ) > exp( w ⊤ j x + b j ) ⇔ w ⊤ i x + b i > w ⊤ j x + b j ⇔ q ⊤ ij x ′ + c ij < 0 (53) where q ij = w j -w i (54) c ij = b j -b i (55) Therefore, we can rewrite Eq. 52 as a set of linear inequalities. Linear regression Recall that the prediction function f is given as: f ( x) = w ⊤ x + b (56) By introducing the parameter ǫ ≥ 0 that specifies the maximum tolerated deviation from the requested prediction -we set ǫ = 0 if we do not allow any deviations -the constraint for obtaining the requested prediction y ′ is given as |f ( x ′ ) -y ′ | ≤ ǫ ⇔ | w ⊤ x ′ + b -y ′ | ≤ ǫ ⇔ | w ⊤ x ′ + c| ≤ ǫ (57) where c = b -y ′ (58) Finally, we can rewrite Eq. 57 as two linear inequality constraints: w ⊤ x ′ + c ≤ ǫ -w ⊤ x ′ -c ≤ ǫ (59) Poisson regression Recall that the prediction function f is given as f ( x) = exp( w ⊤ x + b) (60) The constraint for exactly obtaining the requested prediction y ′ is f ( x ′ ) = y ′ ⇔ exp( w ⊤ x ′ + b) = y ′ ⇔ w ⊤ x ′ + b -log(y ′ ) = 0 ⇔ w ⊤ x ′ + c = 0 (61) where c = b -log(y ′ ) (62) Finally, we obtain the following set of linear inequality constraints: w ⊤ x ′ + c ≤ ǫ -w ⊤ x ′ -c ≤ ǫ (63) where we introduced the parameter ǫ ≥ 0 that specifies the maximum tolerated deviation from the requested prediction -we set ǫ = 0 if we do not allow any deviations. Exponential regression Recall that the prediction function f is given as: f ( x) = - 1 w ⊤ x + b (64) The constraint for a specific prediction y ′ is given as: f ( x ′ ) = y ′ ⇔ - 1 w ⊤ x ′ + b = y ′ ⇔ w ⊤ x ′ + b + 1 y ′ = 0 ⇔ w ⊤ x ′ + c = 0 (65) where c = b + 1 y ′ (66) Finally, we obtain the following set of linear inequality constraints: w ⊤ x ′ + c ≤ ǫ -w ⊤ x ′ -c ≤ ǫ ( 67 ) where we introduced the parameter ǫ ≥ 0 that specifies the maximum tolerated deviation from the requested prediction -we set ǫ = 0 if we do not allow any deviations. Gaussian naive bayes Recall that the prediction function h is given as: h( x) = arg max i ∈ Y d k=1 N ( x | µ ik , σ 2 ik )π i (68) We note that Eq. 68 is equivalent to h( x) = arg max i ∈ Y d k=1 log N ( x | µ ik , σ 2 ik ) + log(π i ) (69) Simplifying the term in Eq. 69 yields log(π i ) + d k=1 log N ( x | µ ik , σ 2 ik ) = log(π i ) + d k=1 log 1 2πσ 2 ik + d k=1 - 1 2σ 2 ik ( x) k -µ ik 2 2 = log(π i ) + d k=1 log 1 2πσ 2 ik - d k=1 1 2σ 2 ik ( x) 2 k + µ 2 ik -2( x) k µ ik = c i -x ⊤ A i x + q ⊤ i x (70) where c i = log(π i ) + d k=1 log 1 2πσ 2 ik - µ 2 ik 2σ 2 ik ( 71 ) A i = diag 1 2σ 2 ik (72) q i = µ i1 σ 2 i1 , . . . , µ id σ 2 id ⊤ (73) For a sample x, in order to be classified as the i-th class, the following set of strict inequalities must hold: c i -x ⊤ A i x + q ⊤ i x > c j -x ⊤ A j x + q ⊤ j x ∀ j = i (74) By rearranging terms in Eq. 74, we get the final constraints x ⊤ A ij x + q ⊤ ij x + c ij < 0 ∀ j = i (75) where A ij = A i -A j = diag 1 2σ 2 ik - 1 2σ 2 jk (76) q ij = q j -q i = µ j1 σ 2 j1 - µ i1 σ 2 i1 , . . . , µ jd σ 2 jd - µ id σ 2 id ⊤ ( 77 ) c ij = c j -c i = log(π j ) -log(π i )+ d k=1 log   1 2πσ 2 jk   - µ 2 jk 2σ 2 jk -log 1 2πσ 2 ik + µ 2 ik 2σ 2 ik = log π j π i + d k=1 log   2πσ 2 ik 2πσ 2 jk   - µ 2 jk 2σ 2 jk + µ 2 ik 2σ 2 ik ( 78 ) Because we can not make any statement about the definiteness of the diagonal matrix A ij , the constraint Eq. 75 is a non-convex quadratic inequality constraint. Quadratic discriminant analysis Recall that the prediction function h is given as: h( x) = arg max i ∈ Y N ( x | µ i , Σ i )π i (79) We can rewrite Eq. 79 as h( x) = arg max i ∈ Y log N ( x | µ i , Σ i )π i (80) Working on the log term yields log N ( x | µ i , Σ i )π i = log N ( x | µ i , Σ i ) + log(π i ) = - d 2 log(2π) - 1 2 log det(Σ -1 i ) - 1 2 ( x -µ i ) ⊤ Σ -1 i ( x -µ i ) + log(π i ) = - 1 2 x ⊤ Σ -1 i x + x ⊤ q i + c i (81) where q i = Σ -1 i µ i ( 82 ) c i = - d 2 log(2π) - 1 2 log det(Σ i ) - 1 2 µ ⊤ i Σ -1 i µ i + log(π i ) (83) For a sample x, in order to be classified as the i-th class, the following set of strict inequalities must hold: - 1 2 x ⊤ Σ -1 i x + x ⊤ q i + c i > - 1 2 x ⊤ Σ -1 j x + x ⊤ q j + c j ∀ j = i (84) Rearranging Eq. 84 yields 1 2 x ⊤ A ij x + x ⊤ q ij + c ij < 0 ∀ j = i (85) where A ij = Σ -1 i -Σ -1 j ( 86 ) q ij = q j -q i = Σ -1 j µ j -Σ -1 i µ i ( 87 ) c ij = c j -c i = - d 2 log(2π) - 1 2 log det(Σ j ) - 1 2 µ ⊤ j Σ -1 j µ j + log(π j )+ d 2 log(2π) + 1 2 log det(Σ i ) + 1 2 µ ⊤ i Σ -1 i µ i -log(π i ) = 1 2 µ ⊤ i Σ -1 i µ i -µ ⊤ j Σ -1 j µ j + 1 2 log det(Σ i ) det(Σ j ) + log π j π i (88) The final constraint Eq. 85 is a non-convex quadratic constraint because we can not make any statement about the definiteness of A ij . Learning vector quantization Note: The subsequent sections are taken from [18] . 6.6.1 Enforcing a specific prototype as the nearest neighbor By using the following set of inequalities, we can force the prototype p i to be the nearest neighbor of the counterfactual x ′ -which would cause x ′ to be classified as o i : d( x ′ , p i ) < d( x ′ , p j ) ∀ p j ∈ P(y ′ ) (89) We consider a fixed pair of i and j: d( x ′ , p i ) < d( x ′ , p j ) ⇔ x ′ -p i 2 Ωi < x ′ -p j 2 Ωj ⇔ ( x ′ -p i ) ⊤ Ω i ( x ′ -p i ) < ( x ′ -p j ) ⊤ Ω j ( x ′ -p j ) ⇔ x ′⊤ Ω i x ′ -2 x ′⊤ Ω i p i + p ⊤ i Ω i p i < x ′⊤ Ω j x ′ -2 x ′⊤ Ω j p j + p ⊤ j Ω i p j ⇔ x ′⊤ Ω i x ′ -x ′⊤ Ω j x ′ -2 x ′⊤ Ω i p i + 2 x ′⊤ Ω j p j + p ⊤ i Ω i p i -p ⊤ j Ω i p j < 0 ⇔ x ′⊤ (Ω i -Ω j ) x ′ + x ′⊤ (-2Ω i p i + 2Ω j p j ) + ( p ⊤ i Ω i p i -p ⊤ j Ω i p j ) ⇔ 1 2 x ′⊤ (Ω i -Ω j ) x ′ + 1 2 x ′⊤ (Ω j p j -Ω i p i ) + 1 2 ( p ⊤ i Ω i p i -p ⊤ j Ω i p j ) < 0 ⇔ 1 2 x ′⊤ A ij x ′ + x ′⊤ q ij + c ij < 0 (90) where A ij = Ω i -Ω j (91) q ij = 1 2 Ω j p j -Ω i p i (92) c ij = 1 2 p i ⊤Ω i p i -p j ⊤Ω j p j (93) If we only have one global distance matrix Ω, we find that A ij = 0 and the inequality Eq. 90 simplifies: d( x, p i ) < d( x, p j ) ⇔ x ′⊤ q ij + c ij < 0 (94) where q ij = 1 2 Ω p j -p i (95) c ij = 1 2 p ⊤ i Ω p i -p ⊤ j Ω p j (96) If we do not use a custom distance matrix, we have Ω = I and Eq. 90 becomes: d( x, p i ) < d( x, p j ) ⇔ x ′⊤ q ij + c ij < 0 (97) where q ij = 1 2 p j -p i (98) c ij = 1 2 p ⊤ i p i -p ⊤ j p j (99) Minimizing the Euclidean distance Minimizing the Euclidean distance (Eq. 36) yields a quadratic objective. First, we expand the Euclidean distance (Eq. 36): x ′ -x 2 2 = ( x ′ -x) ⊤ ( x ′ -x) = x ′⊤ x ′ -x ′⊤ x -x ⊤ x ′ + x ⊤ x = x ′⊤ x ′ -2 x ⊤ x ′ + x ⊤ x (100) Next, we note that that we can drop the constant x ⊤ x when optimizing with respect to x ′ : min x ′ ∈ R d x ′ -x 2 2 ⇔ min x ′ ∈ R d 1 2 x ′⊤ x ′ -x ⊤ x ′ (101) Minimizing the weighted Manhattan distance Minimizing the weighted Manhattan distance (Eq. 2) yields a linear objective. First, we transform the problem of minimizing the weighted Manhattan distance (Eq. 2) into epigraph form: min x ′ ∈ R d j α j • |( x ′ ) j -( x) j | ⇔ min x ′ ∈ R d ,β ∈ R β s.t. j α j • |( x ′ ) j -( x) j | ≤ β β ≥ 0 (102) Next, we separate the dimensions: min x ′ ∈ R d ,β ∈ R β s.t. j α j • |( x ′ ) j -( x) j | ≤ β β ≥ 0 ⇔ min x ′ , β ∈ R d j ( β) j s.t. α j • |( x ′ ) j -( x) j | ≤ ( β) j ∀ j ( β) j ≥ 0 ∀ j (103) After that, we remove the absolute value function: min x ′ , β ∈ R d j ( β) j s.t. α j • |( x ′ ) j -( x) j | ≤ ( β) j ∀ j ( β) j ≥ 0 ∀ j ⇔ min x ′ , β ∈ R d j ( β) j s.t. α j ( x ′ ) j -α j ( x) j ≤ ( β) j ∀ j -α j ( x ′ ) j + α j ( x) j ≤ ( β) j ∀ j ( β) j ≥ 0 ∀ j (104) Finally, we rewrite everything in matrix-vector notation: min x ′ , β ∈ R d 1 ⊤ β s.t. Υ x ′ -Υ x ≤ β -Υ x ′ + Υ x ≤ β β ≥ 0 ( 105 ) where Υ = diag(α j ) (106) 6.9 Solving a non-convex QCQP Solving a non-convex QCQP is known to be NP-hard [28, 39] . In section 6.9.1 we discuss a method for approximately solving a non-convex QCQP and in section 6.9.2 we describe how to solve the special case of a nonconvex QCQP having a single constraint. Approximately solving a non-convex QCQP Recall the non-convex quadratic constraint: 1 2 x ′⊤ A ij x ′ + x ′⊤ q ij + r ij ≤ 0 (107) In this paper, we always defined the matrix A ij as the difference of two s.p.s.d. matrices A i and A j : A ij = A i -A j (108) By making use of Eq. 108, we can rewrite Eq. 107 as: 1 2 x ′⊤ A i x ′ + x ′⊤ q ij + r ij - 1 2 x ′⊤ A j x ′ ≤ 0 ⇔ f ( x ′ ) -g( x ′ ) ≤ 0 (109) where f ( x ′ ) = 1 2 x ′⊤ A i x ′ + x ′⊤ q ij + r ij (110) g( x ′ ) = 1 2 x ′⊤ A j x ′ (111) Under the assumption that our regularization function θ() is a convex function 4 , we can rewrite a generic version of the non-convex QCQP Eq. 41 as follows: min x ′ ∈ R d θ( x ′ , x) s.t. f ( x ′ ) -g( x ′ ) ≤ 0 (112) Because A i and A j are s.p.s.d. matrices, we know that f ( x ′ ) and g( x ′ ) are convex functions. Therefore, Eq. 112 is a difference-of-convex program (DCP). This allows us to use the penalty convex-concave procedure (CCP) [28] for computing an approximate solution of Eq. 112, yielding an approximate solution of the original non-convex QCQP. For using the penalty CCP, we need the first order Taylor approximation of g( x ′ ) around a current point x k : ĝ( x ′ ) x k = g( x k ) + (∇ x ′ g)( x k ) ⊤ ( x ′ -x k ) = 1 2 x ⊤ k A j x k + (A j x k ) ⊤ ( x ′ -x k ) = (A j x k ) ⊤ x ′ + 1 2 x ⊤ k A j x k -(A j x k ) ⊤ x k = ρ ⊤ jk x ′ + cjk (113) where ρ jk = A j x k (114) cjk = - 1 2 x ⊤ k A j x k (115) In order to run the convex-concave procedure, we have to provide an initial (feasible) solution. We could either use the original data point as an initial infeasible solution, some data point yielding the requested prediction as an initial feasible solution or some other \"smart\" initialization. As an alternative, we could use other methods for approximately computing a solution of the non-convex QCQP like the Suggest-Improve framework [28] actually, the methods we described in the previous paragraph is an instance of the Suggest-Improve framework. Solving a non-convex QCQP with just one constraint We consider the general QCQP min x ′ ∈ R d x ′⊤ Q x ′ + q ⊤ x ′ + c s.t. x ′⊤ A x ′ + b ⊤ x ′ + r ≤ 0 (116) where Q, A ∈ R d×d , q, b ∈ R d and c, r ∈ R. If Q and A are not symmetric positive semi-definite, Eq. 116 is a non-convex QCQP. However, despite the non-convexity, we can solve Eq. 116 efficiently by solving the dual of Eq. 116 and observing that the duality gap is zero [39] -under the assumption that Eq. 116 is strictly feasible 5 . Therefore, solving Eq. 116 is equivalent to solving the following semi-definite program (SDP) [39] : arg min X ∈ S d , x ′ ∈ R d trace(QX) + q ⊤ x ′ + c s.t. trace (AX) + b ⊤ x ′ + r ≤ 0 X x ′ x ′⊤ 1 0 ( 117 ) where we introduced an additional variable 6 X that can be discarded afterwards. We restrict ourself to R d , but in theory one could use an arbitrary domain X . https://github.com/andreArtelt/OnTheComputationOfCounterfactualExplanations We can always achieve strict feasibility by moving a non-strict feasible point away from the decision boundary."
}