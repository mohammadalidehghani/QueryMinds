{
  "title": "A Survey of Optimization Methods from a Machine Learning Perspective",
  "abstract": "Machine learning develops rapidly, which has made many theoretical breakthroughs and is widely applied in various fields. Optimization, as an important part of machine learning, has attracted much attention of researchers. With the exponential growth of data amount and the increase of model complexity, optimization methods in machine learning face more and more challenges. A lot of work on solving optimization problems or improving optimization methods in machine learning has been proposed successively. The systematic retrospect and summary of the optimization methods from the perspective of machine learning are of great significance, which can offer guidance for both developments of optimization and machine learning research. In this paper, we first describe the optimization problems in machine learning. Then, we introduce the principles and progresses of commonly used optimization methods. Next, we summarize the applications and developments of optimization methods in some popular machine learning fields. Finally, we explore and give some challenges and open problems for the optimization in machine learning.",
  "introduction": "I. INTRODUCTION R ECENTLY, machine learning has grown at a remarkable rate, attracting a great number of researchers and practitioners. It has become one of the most popular research directions and plays a significant role in many fields, such as machine translation, speech recognition, image recognition, recommendation system, etc. Optimization is one of the core components of machine learning. The essence of most machine learning algorithms is to build an optimization model and learn the parameters in the objective function from the given data. In the era of immense data, the effectiveness and efficiency of the numerical optimization algorithms dramatically influence the popularization and application of the machine learning models. In order to promote the development of machine learning, a series of effective optimization methods were put forward, which have improved the performance and efficiency of machine learning methods. From the perspective of the gradient information in optimization, popular optimization methods can be divided into three categories: first-order optimization methods, which are represented by the widely used stochastic gradient methods; high-order optimization methods, in which Newton's method is a typical example; and heuristic derivative-free optimization methods, in which the coordinate descent method is a representative. As the representative of first-order optimization methods, the stochastic gradient descent method [1] , [2] , as well as its variants, has been widely used in recent years and is evolving at a high speed. However, many users pay little attention to the characteristics or application scope of these methods. They often adopt them as black box optimizers, which may limit the functionality of the optimization methods. In this paper, we comprehensively introduce the fundamental optimization methods. Particularly, we systematically explain their advantages and disadvantages, their application scope, and the characteristics of their parameters. We hope that the targeted introduction will help users to choose the first-order optimization methods more conveniently and make parameter adjustment more reasonable in the learning process. Compared with first-order optimization methods, highorder methods [3] , [4] , [5] converge at a faster speed in which the curvature information makes the search direction more effective. High-order optimizations attract widespread attention but face more challenges. The difficulty in highorder methods lies in the operation and storage of the inverse matrix of the Hessian matrix. To solve this problem, many variants based on Newton's method have been developed, most of which try to approximate the Hessian matrix through some techniques [6] , [7] . In subsequent studies, the stochastic quasi-Newton method and its variants are introduced to extend highorder methods to large-scale data [8] , [9] , [10] . Derivative-free optimization methods [11] , [12] are mainly used in the case that the derivative of the objective function may not exist or be difficult to calculate. There are two main ideas in derivative-free optimization methods. One is adopting a heuristic search based on empirical rules, and the other is fitting the objective function with samples. Derivativefree optimization methods can also work in conjunction with gradient-based methods. Most machine learning problems, once formulated, can be solved as optimization problems. Optimization in the fields of deep neural network, reinforcement learning, meta learning, variational inference and Markov chain Monte Carlo encounters different difficulties and challenges. The optimization methods developed in the specific machine learning fields are different, which can be inspiring to the development of general optimization methods. Deep neural networks (DNNs) have shown great success in pattern recognition and machine learning. There are two very popular NNs, i.e., convolutional neural networks (CNNs) [13] and recurrent neural networks (RNNs), which play important roles in various fields of machine learning. CNNs are feedforward neural networks with convolution calculation. CNNs have been successfully used in many fields such as image processing [14] , [15] , video processing [16] and natural language processing (NLP) [17] , [18] . RNNs are a kind of sequential model and very active in NLP [19] , [20] , [21] , [22] . Besides, RNNs are also popular in the fields of image processing [23] , [24] and video processing [25] . In the field of constrained optimization, RNNs can achieve excellent results [26] , [27] , [28] , [29] . In these works, the parameters of weights in RNNs can be learned by analytical methods, and these methods can find the optimal solution according to the trajectory of the state solution. Stochastic gradient-based algorithms are widely used in deep neural networks [30] , [31] , [32] , [33] . However, various problems are emerging when employing stochastic gradient-based algorithms. For example, the learning rate will be oscillating in the later training stage of some adaptive methods [34] , [35] , which may lead to the problem of non-converging. Thus, further optimization algorithms based on variance reduction were proposed to improve the convergence rate [36] , [37] . Moreover, combining the stochastic gradient descent and the characteristics of its variants is a possible direction to improve the optimization. Especially, switching an adaptive algorithm to the stochastic gradient descent method can improve the accuracy and convergence speed of the algorithm [38] . Reinforcement learning (RL) is a branch of machine learning, for which an agent interacts with the environment by trial-and-error mechanism and learns an optimal policy by maximizing cumulative rewards [39] . Deep reinforcement learning combines the RL and deep learning techniques, and enables the RL agent to have a good perception of its environment. Recent research has shown that deep learning can be applied to learn a useful representation for reinforcement learning problems [40] , [41] , [42] , [43] , [44] . Stochastic optimization algorithms are commonly used in RL and deep RL models. Meta learning [45] , [46] has recently become very popular in the field of machine learning. The goal of meta learning is to design a model that can efficiently adapt to the new environment with as few samples as possible. The application of meta learning in supervised learning can solve the few-shot learning problems [47] . In general, meta learning methods can be summarized into the following three types [48] : metricbased methods [49] , [50] , [51] , [52] , model-based methods [53] , [54] and optimization-based methods [55] , [56] , [47] . We will describe the details of optimization-based meta learning methods in the subsequent sections. Variational inference is a useful approximation method which aims to approximate the posterior distributions in Bayesian machine learning. It can be considered as an optimization problem. For example, mean-field variational inference uses coordinate ascent to solve this optimization problem [57] . As the amount of data increases continuously, it is not friendly to use the traditional optimization method to handle the variational inference. Thus, the stochastic variational inference was proposed, which introduced natural gradients and extended the variational inference to large-scale data [58] . Optimization methods have a significative influence on various fields of machine learning. For example, [5] proposed the transformer network using Adam optimization [33] , which is applied to machine translation tasks. [59] proposed superresolution generative adversarial network for image super resolution, which is also optimized by Adam. [60] proposed Actor-Critic using trust region optimization to solve the deep reinforcement learning on Atari games as well as the MuJoCo environments. The stochastic optimization method can also be applied to Markov chain Monte Carlo (MCMC) sampling to improve efficiency. In this kind of application, stochastic gradient Hamiltonian Monte Carlo (HMC) is a representative method [61] where the stochastic gradient accelerates the step of gradient update when handling large-scale samples. The noise introduced by the stochastic gradient can be characterized by introducing Gaussian noise and friction terms. Additionally, the deviation caused by HMC discretization can be eliminated by the friction term, and thus the Metropolis-Hasting step can be omitted. The hyper-parameter settings in the HMC will affect the performance of the model. There are some efficient ways to automatically adjust the hyperparameters and improve the performance of the sampler. The development of optimization brings a lot of contributions to the progress of machine learning. However, there are still many challenges and open problems for optimization problems in machine learning. 1) How to improve optimization performance with insufficient data in deep neural networks is a tricky problem. If there are not enough samples in the training of deep neural networks, it is prone to cause the problem of high variances and overfitting [62] . In addition, non-convex optimization has been one of the difficulties in deep neural networks, which makes the optimization tend to get a locally optimal solution rather than the global optimal solution. 2) For sequential models, the samples are often truncated by batches when the sequence is too long, which will cause deviation. How to analyze the deviation of stochastic optimization in this case and correct it is vital. 3) The stochastic variational inference is graceful and practical, and it is probably a good choice to develop methods of applying high-order gradient information to stochastic variational inference. 4) It may be a great idea to introduce the stochastic technique to the conjugate gradient method to obtain an elegant and powerful optimization algorithm. The detailed techniques to make improvements in the stochastic conjugate gradient is an interesting and challenging problem. The purpose of this paper is to summarize and analyze classical and modern optimization methods from a machine learning perspective. The remainder of this paper is organized as follows. Section II summarizes the machine learning problems from the perspective of optimization. Section III discusses the classical optimization algorithms and their latest developments in machine learning. Particularly, the recent popular optimization methods including the first and second order optimization algorithms are emphatically introduced. Section IV describes the developments and applications of optimization methods in some specific machine learning fields. Section V presents the challenges and open problems in the optimization methods. Finally, we conclude the whole paper.",
  "body": "I. INTRODUCTION R ECENTLY, machine learning has grown at a remarkable rate, attracting a great number of researchers and practitioners. It has become one of the most popular research directions and plays a significant role in many fields, such as machine translation, speech recognition, image recognition, recommendation system, etc. Optimization is one of the core components of machine learning. The essence of most machine learning algorithms is to build an optimization model and learn the parameters in the objective function from the given data. In the era of immense data, the effectiveness and efficiency of the numerical optimization algorithms dramatically influence the popularization and application of the machine learning models. In order to promote the development of machine learning, a series of effective optimization methods were put forward, which have improved the performance and efficiency of machine learning methods. From the perspective of the gradient information in optimization, popular optimization methods can be divided into three categories: first-order optimization methods, which are represented by the widely used stochastic gradient methods; high-order optimization methods, in which Newton's method is a typical example; and heuristic derivative-free optimization methods, in which the coordinate descent method is a representative. As the representative of first-order optimization methods, the stochastic gradient descent method [1] , [2] , as well as its variants, has been widely used in recent years and is evolving at a high speed. However, many users pay little attention to the characteristics or application scope of these methods. They often adopt them as black box optimizers, which may limit the functionality of the optimization methods. In this paper, we comprehensively introduce the fundamental optimization methods. Particularly, we systematically explain their advantages and disadvantages, their application scope, and the characteristics of their parameters. We hope that the targeted introduction will help users to choose the first-order optimization methods more conveniently and make parameter adjustment more reasonable in the learning process. Compared with first-order optimization methods, highorder methods [3] , [4] , [5] converge at a faster speed in which the curvature information makes the search direction more effective. High-order optimizations attract widespread attention but face more challenges. The difficulty in highorder methods lies in the operation and storage of the inverse matrix of the Hessian matrix. To solve this problem, many variants based on Newton's method have been developed, most of which try to approximate the Hessian matrix through some techniques [6] , [7] . In subsequent studies, the stochastic quasi-Newton method and its variants are introduced to extend highorder methods to large-scale data [8] , [9] , [10] . Derivative-free optimization methods [11] , [12] are mainly used in the case that the derivative of the objective function may not exist or be difficult to calculate. There are two main ideas in derivative-free optimization methods. One is adopting a heuristic search based on empirical rules, and the other is fitting the objective function with samples. Derivativefree optimization methods can also work in conjunction with gradient-based methods. Most machine learning problems, once formulated, can be solved as optimization problems. Optimization in the fields of deep neural network, reinforcement learning, meta learning, variational inference and Markov chain Monte Carlo encounters different difficulties and challenges. The optimization methods developed in the specific machine learning fields are different, which can be inspiring to the development of general optimization methods. Deep neural networks (DNNs) have shown great success in pattern recognition and machine learning. There are two very popular NNs, i.e., convolutional neural networks (CNNs) [13] and recurrent neural networks (RNNs), which play important roles in various fields of machine learning. CNNs are feedforward neural networks with convolution calculation. CNNs have been successfully used in many fields such as image processing [14] , [15] , video processing [16] and natural language processing (NLP) [17] , [18] . RNNs are a kind of sequential model and very active in NLP [19] , [20] , [21] , [22] . Besides, RNNs are also popular in the fields of image processing [23] , [24] and video processing [25] . In the field of constrained optimization, RNNs can achieve excellent results [26] , [27] , [28] , [29] . In these works, the parameters of weights in RNNs can be learned by analytical methods, and these methods can find the optimal solution according to the trajectory of the state solution. Stochastic gradient-based algorithms are widely used in deep neural networks [30] , [31] , [32] , [33] . However, various problems are emerging when employing stochastic gradient-based algorithms. For example, the learning rate will be oscillating in the later training stage of some adaptive methods [34] , [35] , which may lead to the problem of non-converging. Thus, further optimization algorithms based on variance reduction were proposed to improve the convergence rate [36] , [37] . Moreover, combining the stochastic gradient descent and the characteristics of its variants is a possible direction to improve the optimization. Especially, switching an adaptive algorithm to the stochastic gradient descent method can improve the accuracy and convergence speed of the algorithm [38] . Reinforcement learning (RL) is a branch of machine learning, for which an agent interacts with the environment by trial-and-error mechanism and learns an optimal policy by maximizing cumulative rewards [39] . Deep reinforcement learning combines the RL and deep learning techniques, and enables the RL agent to have a good perception of its environment. Recent research has shown that deep learning can be applied to learn a useful representation for reinforcement learning problems [40] , [41] , [42] , [43] , [44] . Stochastic optimization algorithms are commonly used in RL and deep RL models. Meta learning [45] , [46] has recently become very popular in the field of machine learning. The goal of meta learning is to design a model that can efficiently adapt to the new environment with as few samples as possible. The application of meta learning in supervised learning can solve the few-shot learning problems [47] . In general, meta learning methods can be summarized into the following three types [48] : metricbased methods [49] , [50] , [51] , [52] , model-based methods [53] , [54] and optimization-based methods [55] , [56] , [47] . We will describe the details of optimization-based meta learning methods in the subsequent sections. Variational inference is a useful approximation method which aims to approximate the posterior distributions in Bayesian machine learning. It can be considered as an optimization problem. For example, mean-field variational inference uses coordinate ascent to solve this optimization problem [57] . As the amount of data increases continuously, it is not friendly to use the traditional optimization method to handle the variational inference. Thus, the stochastic variational inference was proposed, which introduced natural gradients and extended the variational inference to large-scale data [58] . Optimization methods have a significative influence on various fields of machine learning. For example, [5] proposed the transformer network using Adam optimization [33] , which is applied to machine translation tasks. [59] proposed superresolution generative adversarial network for image super resolution, which is also optimized by Adam. [60] proposed Actor-Critic using trust region optimization to solve the deep reinforcement learning on Atari games as well as the MuJoCo environments. The stochastic optimization method can also be applied to Markov chain Monte Carlo (MCMC) sampling to improve efficiency. In this kind of application, stochastic gradient Hamiltonian Monte Carlo (HMC) is a representative method [61] where the stochastic gradient accelerates the step of gradient update when handling large-scale samples. The noise introduced by the stochastic gradient can be characterized by introducing Gaussian noise and friction terms. Additionally, the deviation caused by HMC discretization can be eliminated by the friction term, and thus the Metropolis-Hasting step can be omitted. The hyper-parameter settings in the HMC will affect the performance of the model. There are some efficient ways to automatically adjust the hyperparameters and improve the performance of the sampler. The development of optimization brings a lot of contributions to the progress of machine learning. However, there are still many challenges and open problems for optimization problems in machine learning. 1) How to improve optimization performance with insufficient data in deep neural networks is a tricky problem. If there are not enough samples in the training of deep neural networks, it is prone to cause the problem of high variances and overfitting [62] . In addition, non-convex optimization has been one of the difficulties in deep neural networks, which makes the optimization tend to get a locally optimal solution rather than the global optimal solution. 2) For sequential models, the samples are often truncated by batches when the sequence is too long, which will cause deviation. How to analyze the deviation of stochastic optimization in this case and correct it is vital. 3) The stochastic variational inference is graceful and practical, and it is probably a good choice to develop methods of applying high-order gradient information to stochastic variational inference. 4) It may be a great idea to introduce the stochastic technique to the conjugate gradient method to obtain an elegant and powerful optimization algorithm. The detailed techniques to make improvements in the stochastic conjugate gradient is an interesting and challenging problem. The purpose of this paper is to summarize and analyze classical and modern optimization methods from a machine learning perspective. The remainder of this paper is organized as follows. Section II summarizes the machine learning problems from the perspective of optimization. Section III discusses the classical optimization algorithms and their latest developments in machine learning. Particularly, the recent popular optimization methods including the first and second order optimization algorithms are emphatically introduced. Section IV describes the developments and applications of optimization methods in some specific machine learning fields. Section V presents the challenges and open problems in the optimization methods. Finally, we conclude the whole paper. II. MACHINE LEARNING FORMULATED AS OPTIMIZATION Almost all machine learning algorithms can be formulated as an optimization problem to find the extremum of an objective function. Building models and constructing reasonable objective functions are the first step in machine learning methods. With the determined objective function, appropriate numerical or analytical optimization methods are usually used to solve the optimization problem. According to the modeling purpose and the problem to be solved, machine learning algorithms can be divided into supervised learning, semi-supervised learning, unsupervised learning, and reinforcement learning. Particularly, supervised learning is further divided into the classification problem (e.g., sentence classification [17] , [63] , image classification [64] , [65] , [66] , etc.) and regression problem; unsupervised learning is divided into clustering and dimension reduction [67] , [68] , [69] , among others. A. Optimization Problems in Supervised Learning For supervised learning, the goal is to find an optimal mapping function f (x) to minimize the loss function of the training samples, min θ 1 N N i=1 L(y i , f (x i , θ)), (1) where N is the number of training samples, θ is the parameter of the mapping function, x i is the feature vector of the ith samples, y i is the corresponding label, and L is the loss function. There are many kinds of loss functions in supervised learning, such as the square of Euclidean distance, crossentropy, contrast loss, hinge loss, information gain and so on. For regression problems, the simplest way is using the square of Euclidean distance as the loss function, that is, minimizing square errors on training samples. But the generalization performance of this kind of empirical loss is not necessarily good. Another typical form is structured risk minimization, whose representative method is the support vector machine. On the objective function, regularization items are usually added to alleviate overfitting, e.g., in terms of L 2 norm, min θ 1 N N i=1 L(y i , f (x i , θ)) + λ θ 2 2 . ( 2 ) where λ is the compromise parameter, which can be determined through cross-validation. B. Optimization Problems in Semi-supervised Learning Semi-supervised learning (SSL) is the method between supervised and unsupervised learning, which incorporates labeled data and unlabeled data during the training process. It can deal with different tasks including classification tasks [70] , [71] , regression tasks [72] , clustering tasks [73] , [74] and dimensionality reduction tasks [75] , [76] . There are different kinds of semi-supervised learning methods including selftraining, generative models, semi-supervised support vector machines (S3VM) [77] , graph-based methods, multi-learning method and others. We take S3VM as an example to introduce the optimization in semi-supervised learning. S3VM is a learning model that can deal with binary classification problems and only part of the training set in this problem is labeled. Let D l be labeled data which can be represented as D l = {{x 1 , y 1 }, {x 2 , y 2 }, ..., {x l , y l }}, and D u be unlabeled data which can be represented as D u = {x l+1 , x l+2 , ..., x N } with N = l + u. In order to use the information of unlabeled data, additional constraint on the unlabeled data is added to the original objective of SVM with slack variables ζ i . Specifically, define ǫ j as the misclassification error of the unlabeled instance if its true label is positive and z j as the misclassification error of the unlabeled instance if its true label is negative. The constraint means to make N j=l+1 min(ǫ i , ζ i ) as small as possible. Thus, an S3VM problem can be described as min ω +C   l i=1 ζ i + N j=l+1 min(ǫ i , z j )   , subject to y i (w • x i + b) + ζ i ≥ 1, ζ ≥ 0, i = 1, ..., l, w • x j + b + ǫ j ≥ 1, ǫ ≥ 0, j = l + 1, ..., N, -(w • x j + b) + z j ≥ 1, z j ≥ 0, (3) where C is a penalty coefficient. The optimization problem in S3VM is a mixed-integer problem which is difficult to deal with [78] . There are various methods summarized in [79] to deal with this problem, such as the branch and bound techniques [80] and convex relaxation methods [81] . C. Optimization Problems in Unsupervised Learning Clustering algorithms [67] , [82] , [83] , [84] divide a group of samples into multiple clusters ensuring that the differences between the samples in the same cluster are as small as possible, and samples in different clusters are as different as possible. The optimization problem for the k-means clustering algorithm is formulated as minimizing the following loss function: min S K k=1 x∈S k x -µ k 2 2 , ( 4 ) where K is the number of clusters, x is the feature vector of samples, µ k is the center of cluster k, and S k is the sample set of cluster k. The implication of this objective function is to make the sum of variances of all clusters as small as possible. The dimensionality reduction algorithm ensures that the original information from data is retained as much as possible after projecting them into the low-dimensional space. Principal component analysis (PCA) [85] , [86] , [87] is a typical algorithm of dimensionality reduction methods. The objective of PCA is formulated to minimize the reconstruction error as min N i=1 x i -x i 2 2 where x i = D ′ j=1 z i j e j , D ≫ D ′ , (5) where N represents the number of samples, x i is a Ddimensional vector, x i is the reconstruction of x i . z i = {z i 1 , ..., z i D ′ } is the projection of x i in D ′ -dimensional coordinates. e j is the standard orthogonal basis under D ′dimensional coordinates. Another common optimization goal in probabilistic models is to find an optimal probability density function of p(x), which maximizes the logarithmic likelihood function (MLE) of the training samples, max N i=1 ln p(x i ; θ). (6) In the framework of Bayesian methods, some prior distributions are often assumed on parameter θ, which also has the effect of alleviating overfitting. D. Optimization Problems in Reinforcement Learning Reinforcement learning [42] , [88] , [89] , unlike supervised learning and unsupervised learning, aims to find an optimal strategy function, whose output varies with the environment. For a deterministic strategy, the mapping function from state s to action a is the learning target. For an uncertain strategy, the probability of executing each action is the learning target. In each state, the action is determined by a = π(s), where π(s) is the policy function. The optimization problem in reinforcement learning can be formulated as maximizing the cumulative return after executing a series of actions which are determined by the policy function, (7) where V π (s) is the value function of state s under policy π, r is the reward, and γ ∈ [0, 1] is the discount factor. max π V π (s) where V π (s) = E ∞ k=0 γ k r t+k |S t = s , E. Optimization for Machine Learning Overall, the main steps of machine learning are to build a model hypothesis, define the objective function, and solve the maximum or minimum of the objective function to determine the parameters of the model. In these three vital steps, the first two steps are the modeling problems of machine learning, and the third step is to solve the desired model by optimization methods. III. FUNDAMENTAL OPTIMIZATION METHODS AND PROGRESSES From the perspective of gradient information, fundamental optimization methods can be divided into first-order optimization methods, high-order optimization methods and derivativefree optimization methods. These methods have a long history and are constantly evolving. They are progressing in many practical applications and have achieved good performance. Besides these fundamental methods, preconditioning is a useful technique for optimization methods. Applying reasonable preconditioning can reduce the number of iterations and obtain better spectral characteristics. These technologies have been widely used in practice. For the convenience of researchers, we summarize the existing common optimization toolkits in a table at the end of this section. A. First-Order Methods In the field of machine learning, the most commonly used first-order optimization methods are mainly based on gradient descent. In this section, we introduce some of the representative algorithms along with the development of the gradient descent methods. At the same time, the classical alternating direction method of multipliers and the Frank-Wolfe method in numerical optimization are also introduced. 1) Gradient Descent: The gradient descent method is the earliest and most common optimization method. The idea of the gradient descent method is that variables update iteratively in the (opposite) direction of the gradients of the objective function. The update is performed to gradually converge to the optimal value of the objective function. The learning rate η determines the step size in each iteration, and thus influences the number of iterations to reach the optimal value [90] . The steepest descent algorithm is a widely known algorithm. The idea is to select an appropriate search direction in each iteration so that the value of the objective function minimizes the fastest. Gradient descent and steepest descent are not the same, because the direction of the negative gradient does not always descend fastest. Gradient descent is an example of using the Euclidean norm in steepest descent [91] . Next, we give the formal expression of gradient descent method. For a linear regression model, we assume that f θ (x) is the function to be learned, L(θ) is the loss function, and θ is the parameter to be optimized. The goal is to minimize the loss function with L(θ) = 1 2N N i=1 (y i -f θ (x i )) 2 , (8) f θ (x) = D j=1 θ j x j , (9) where N is the number of training samples, D is the number of input features, x i is an independent variable with x i = (x i 1 , ..., x i D ) for i = 1, ..., N and y i is the target output. The gradient descent alternates the following two steps until it converges: 1) Derive L(θ) for θ j to get the gradient corresponding to each θ j : ∂L(θ) ∂θ j = - 1 N N i=1 (y i -f θ (x i ))x i j . (10) 2) Update each θ j in the negative gradient direction to minimize the risk function: θ ′ j = θ j + η • 1 N N i=1 (y i -f θ (x i ))x i j . (11) The gradient descent method is simple to implement. The solution is global optimal when the objective function is convex. It often converges at a slower speed if the variable is closer to the optimal solution, and more careful iterations need to be performed. In the above linear regression example, note that all the training data are used in each iteration step, so the gradient descent method is also called the batch gradient descent. If the number of samples is N and the dimension of x is D, the computation complexity for each iteration will be O(N D). In order to mitigate the cost of computation, some parallelization methods were proposed [92] , [93] . However, the cost is still hard to accept when dealing with large-scale data. Thus, the stochastic gradient descent method emerges. 2) Stochastic Gradient Descent: Since the batch gradient descent has high computational complexity in each iteration for large-scale data and does not allow online update, stochastic gradient descent (SGD) was proposed [1] . The idea of stochastic gradient descent is using one sample randomly to update the gradient per iteration, instead of directly calculating the exact value of the gradient. The stochastic gradient is an unbiased estimate of the real gradient [1] . The cost of the stochastic gradient descent algorithm is independent of sample numbers and can achieve sublinear convergence speed [37] . SGD reduces the update time for dealing with large numbers of samples and removes a certain amount of computational redundancy, which significantly accelerates the calculation. In the strong convex problem, SGD can achieve the optimal convergence speed [94] , [95] , [96] , [36] . Meanwhile, it overcomes the disadvantage of batch gradient descent that cannot be used for online learning. The loss function (8) can be written as the following equation: L(θ) = 1 N N i=1 1 2 (y i -f θ (x i )) 2 = 1 N N i=1 cost(θ, (x i , y i )). (12) If a random sample i is selected in SGD, the loss function will be L * (θ): L * (θ) = cost(θ, (x i , y i )) = 1 2 (y i -f θ (x i )) 2 . ( 13 ) The gradient update in SGD uses the random sample i rather than all samples in each iteration, θ ′ = θ + η(y i -f θ (x i ))x i . ( 14 ) Since SGD uses only one sample per iteration, the computation complexity for each iteration is O(D) where D is the number of features. The update rate for each iteration of SGD is much faster than that of batch gradient descent when the number of samples N is large. SGD increases the overall optimization efficiency at the expense of more iterations, but the increased iteration number is insignificant compared with the high computation complexity caused by large numbers of samples. It is possible to use only thousands of samples overall to get the optimal solution even when the sample size is hundreds of thousands. Therefore, compared with batch methods, SGD can effectively reduce the computational complexity and accelerate convergence. However, one problem in SGD is that the gradient direction oscillates because of additional noise introduced by random selection, and the search process is blind in the solution space. Unlike batch gradient descent which always moves towards the optimal value along the negative direction of the gradient, the variance of gradients in SGD is large and the movement direction in SGD is biased. So, a compromise between the two methods, the mini-batch gradient descent method (MSGD), was proposed [1] . The MSGD uses b independent identically distributed samples (b is generally in 50 to 256 [90] ) as the sample sets to update the parameters in each iteration. It reduces the variance of the gradients and makes the convergence more stable, which helps to improve the optimization speed. For brevity, we will call MSGD as SGD in the following sections. As a common feature of stochastic optimization, SGD has a better chance of finding the global optimal solution for complex problems. The deterministic gradient in batch gradient descent may cause the objective function to fall into a local minimum for the multimodal problem. The fluctuation in the SGD helps the objective function jump to another possible minimum. However, the fluctuation in SGD always exists, which may more or less slow down the process of converging. There are still many details to be noted about the use of SGD in the concrete optimization process [90] , such as the choice of a proper learning rate. A too small learning rate will result in a slower convergence rate, while a too large learning rate will hinder convergence, making loss function fluctuate at the minimum. One way to solve this problem is to set up a predefined list of learning rates or a certain threshold and adjust the learning rate during the learning process [97] , [98] . However, these lists or thresholds need to be defined in advance according to the characteristics of the dataset. It is also inappropriate to use the same learning rate for all parameters. If data are sparse and features occur at different frequencies, it is not expected to update the corresponding variables with the same learning rate. A higher learning rate is often expected for less frequently occurring features [30] , [33] . Besides the learning rate, how to avoid the objective function being trapped in infinite numbers of the local minimum is a common challenge. Some work has proved that this difficulty does not come from the local minimum values, but comes from the \"saddle point\" [99] . The slope of a saddle point is positive in one direction and negative in another direction, and gradient values in all directions are zero. It is an important problem for SGD to escape from these points. Some research about escaping from saddle points were developed [100] , [101] . 3) Nesterov Accelerated Gradient Descent: Although SGD is popular and widely used, its learning process is sometimes prolonged. How to adjust the learning rate, how to speed up the convergence, and how to prevent being trapped at a local minimum during the search are worthwhile research directions. Much work is presented to improve SGD. For example, the momentum idea was proposed to be applied in SGD [102] . The concept of momentum is derived from the mechanics of physics, which simulates the inertia of objects. The idea of applying momentum in SGD is to preserve the influence of the previous update direction on the next iteration to a certain degree. The momentum method can speed up the convergence when dealing with high curvature, small but consistent gradients, or noisy gradients [103] . The momentum algorithm introduces the variable v as the speed, which represents the direction and the rate of the parameter's movement in the parameter space. The speed is set as the average exponential decay of the negative gradient. In the gradient descent method, the speed update is v = η • (-∂L(θ) ∂(θ) ) each time. Using the momentum algorithm, the amount of the update v is not just the amount of gradient descent calculated by η • (-∂L(θ) ∂(θ) ). It also takes into account the friction factor, which is represented as the previous update v old multiplied by a momentum factor ranging between [0, 1]. Generally, the mass of the object is set to 1. The formulation is expressed as v = η • (- ∂L(θ) ∂(θ) ) + v old • mtm, ( 15 ) where mtm is the momentum factor. If the current gradient is parallel to the previous speed v old , the previous speed can speed up this search. The proper momentum plays a role in accelerating the convergence when the learning rate is small. If the derivative decays to 0, it will continue to update v to reach equilibrium and will be attenuated by friction. It is beneficial for escaping from the local minimum in the training process so that the search process can converge more quickly [102] , [104] . If the current gradient is opposite to the previous update v old , the value v old will have a deceleration effect on this search. The momentum method with a proper momentum factor plays a positive role in reducing the oscillation of convergence when the learning rate is large. How to select the proper size of the momentum factor is also a problem. If the momentum factor is small, it is hard to obtain the effect of improving convergence speed. If the momentum factor is large, the current point may jump out of the optimal value point. Many experiments have empirically verified the most appropriate setting for the momentum factor is 0.9 [90] . Nesterov Accelerated Gradient Descent (NAG) makes further improvement over the traditional momentum method [104] , [105] . In Nesterov momentum, the momentum v old • mtm is added to θ, denoted as θ. The gradient of θ is used when updating. The detailed update formulae for parameters θ are as follows:          θ = θ + v old • mtm, v = v old • mtm + η • (- ∂L( θ) ∂(θ) ), θ ′ = θ + v. (16) The improvement of Nesterov momentum over momentum is reflected in updating the gradient of the future position instead of the current position. From the update formula, we can find that Nestorov momentum includes more gradient information compared with the traditional momentum method. Note that Nesterov momentum improves the convergence from O( 1 k ) (after k steps) to O( 1 k 2 ) , when not using stochastic optimization [105] . Another issue worth considering is how to determine the size of the learning rate. It is more likely to occur the oscillation if the search is closer to the optimal point. Thus, the learning rate should be adjusted. The learning rate decay factor d is commonly used in the SGD's momentum method, which makes the learning rate decrease with the iteration period [106] . The formula of the learning rate decay is defined as η t = η 0 1 + d • t , (17) where η t is the learning rate at the tth iteration, η 0 is the original learning rate, and d is a decimal in [0, 1]. As can be seen from the formula, the smaller the d is, the slower the decay of the learning rate will be. The learning rate remains unchanged when d = 0 and the learning rate decays fastest when d = 1. 4) Adaptive Learning Rate Method: The manually regulated learning rate greatly influences the effect of the SGD method. It is a tricky problem for setting an appropriate value of the learning rate [30] , [33] , [107] . Some adaptive methods were proposed to adjust the learning rate automatically. These methods are free of parameter adjustment, fast to converge, and often achieving not bad results. They are widely used in deep neural networks to deal with optimization problems. The most straightforward improvement to SGD is AdaGrad [30] . AdaGrad adjusts the learning rate dynamically based on the historical gradient in some previous iterations. The update formulae are as follows:              g t = ∂L(θ t ) ∂θ , V t = t i=1 (g i ) 2 + ǫ, θ t+1 = θ t -η g t V t , (18) where g t is the gradient of parameter θ at iteration t, V t is the accumulate historical gradient of parameter θ at iteration t, and θ t is the value of parameter θ at iteration t. The difference between AdaGrad and gradient descent is that during the parameter update process, the learning rate is no longer fixed, but is computed using all the historical gradients accumulated up to this iteration. One main benefit of AdaGrad is that it eliminates the need to tune the learning rate manually. Most implementations use a default value of 0.01 for η in (18) . Although AdaGrad adaptively adjusts the learning rate, it still has two issues. 1) The algorithm still needs to set the global learning rate η manually. 2) As the training time increases, the accumulated gradient will become larger and larger, making the learning rate tend to zero, resulting in ineffective parameter update. AdaGrad was further improved to AdaDelta [31] and RMSProp [32] for solving the problem that the learning rate will eventually go to zero. The idea is to consider not accumulating all historical gradients, but focusing only on the gradients in a window over a period, and using the exponential moving average to calculate the second-order cumulative momentum, V t = βV t-1 + (1 -β)(g t ) 2 , ( 19 ) where β is the exponential decay parameter. Both RMSProp and AdaDelta have been developed independently around the same time, stemming from the need to resolve the radically diminishing learning rates of AdaGrad. Adaptive moment estimation (Adam) [33] is another advanced SGD method, which introduces an adaptive learning rate for each parameter. It combines the adaptive learning rate and momentum methods. In addition to storing an exponentially decaying average of past squared gradients V t , like AdaDelta and RMSProp, Adam also keeps an exponentially decaying average of past gradients m t , similar to the momentum method: m t = β 1 m t-1 + (1 -β 1 )g t , (20) V t = β 2 V t-1 + (1 -β 2 )(g t ) 2 , (21) where β 1 and β 2 are exponential decay rates. The final update formula for the parameter θ is θ t+1 = m t -η √ 1 -β 2 1 -β 1 m t V t + ǫ . (22) The default values of β 1 , β 2 , and ǫ are suggested to set to 0.9, 0.999, and 10 -8 , respectively. Adam works well in practice and compares favorably to other adaptive learning rate algorithms. 5) Variance Reduction Methods: Due to a large amount of redundant information in the training samples, the SGD methods are very popular since they were proposed. However, the stochastic gradient method can only converge at a sublinear rate and the variance of gradient is often very large. How to reduce the variance and improve SGD to the linear convergence has always been an important problem. Stochastic Average Gradient The stochastic average gradient (SAG) method [36] is a variance reduction method proposed to improve the convergence speed. The SAG algorithm maintains parameter d recording the sum of the N latest gradients {g i } in memory where g i is calculated using one sample i, i ∈ {1, ..., N }. The detailed implementation is to select a sample i t to update d randomly, and use d to update the parameter θ in iteration t:        d = d -ĝit + g it (θ t-1 ), ĝit = g it (θ t-1 ), θ t = θ t-1 - α N d, (23) where the updated item d is calculated by replacing the old gradient ĝit in d with the new gradient g it (θ t-1 ) in iteration t, α is a constant representing the learning rate. Thus, each update only needs to calculate the gradient of one sample, not the gradients of all samples. The computational overhead is no different from SGD, but the memory overhead is much larger. This is a typical way of using space for saving time. The SAG has been shown to be a linear convergence algorithm [36] , which is much faster than SGD, and has great advantages over other stochastic gradient algorithms. However, the SAG method is only applicable to the case where the loss function is smooth and the objective function is convex [36] , [108] , such as convex linear prediction problems. In this case, the SAG achieves a faster convergence rate than the SGD. In addition, under some specific problems, it can even deliver better convergence than the standard batch gradient descent. Stochastic Variance Reduction Gradient Since the SAG method is only applicable to smooth and convex functions and needs to store the gradient of each sample, it is inconvenient to be applied in non-convex neural networks. The stochastic variance reduction gradient (SVRG) [37] method was proposed to improve the performance of optimization in the complex models. The algorithm of SVRG maintains the interval average gradient μ by calculating the gradients of all samples in every w iterations instead of in each iteration: μ = 1 N N i=1 g i ( θ), ( 24 ) where θ is the interval update parameter. The interval parameter μ contains the average memory of all sample gradients in the past time for each time interval w. SVRG picks uniform i t ∈ {1, ..., N } randomly, and executes gradient updates to the current parameters: θ t = θ t-1 -η • (g it (θ t-1 ) -g it ( θ) + μ). ( 25 ) The gradient is calculated up to two times in each update. After w iterations, perform θ ← θ w and start the next w iterations. Through these update, θ t and the interval update parameter θ will converge to the optimal θ * , and then μ → 0, and g it (θ t-1 ) -g it ( θ) + μ → g it (θ t-1 ) -g it (θ * ) → 0. ( 26 ) SVRG proposes a vital concept called variance reduction. This concept is related to the convergence analysis of SGD, in which it is necessary to assume that there is a constant upper bound for the variance of the gradients. This constant upper bound implies that the SGD cannot achieve linear convergence. However, in SVRG, the upper bound of variance can be continuously reduced due to the special update item g it (θ t-1 )g it ( θ) + μ , thus achieving linear convergence [37] . The strategies of SAG and SVRG are related to variance reduction. Compared with SAG, SVRG does not need to maintain all gradients in memory, which means that memory resources are saved, and it can be applied to complex problems efficiently. Experiments have shown that the performance of SVRG is remarkable on a non-convex neural network [37] , [109] , [110] . There are also many variants of such linear convergence stochastic optimization algorithms, such as the SAGA algorithm [111] . 6) Alternating Direction Method of Multipliers: Augmented Lagrangian multiplier method is a common method to solve optimization problems with linear constraints. Compared with the naive Lagrangian multiplier method, it makes problems easier to solve by adding a penalty term to the objective. Consider the following example, min {θ 1 (x) + θ 2 (y)|Ax + By = b, x ∈ X , y ∈ Y} . (27) The augmented Lagrange function for problem (27) is L β (x, y, λ) =θ 1 (x) + θ 2 (y) -λ ⊤ (Ax + By -b) + β 2 ||Ax + By -b|| 2 . ( 28 ) When solved by the augmented Lagrangian multiplier method, its tth step iteration starts from the given λ t , and the optimization turns out to (x t+1 , y t+1 ) = arg min {L β (x, y, λ t )|x ∈ X , y ∈ Y} , λ t+1 = λ t -β(Ax t+1 + By t+1 -b). (29) Separating the (x, y) sub-problem in ( 29 ), the augmented Lagrange multiplier method can be relaxed to the following alternating direction method of multipliers (ADMM) [112] , [113] . Its tth step iteration starts with the given (y t , λ t ), and the details of iterative optimization are as follows: The penalty parameter β has a certain impact on the convergence rate of the ADMM. The larger β is, the greater the penalties for the constraint term. In general, a monotonically increasing sequence of {β t } can be adopted instead of the fixed β [114] . Specifically, an auto-adjustment criterion that automatically adjusts {β t } based on the current value of {x t } during the iteration was proposed, and applied for solving some convex optimization problems [115] , [116] .              x t+1 = arg min θ 1 (x) -(λ t ) ⊤ Ax + β 2 ||Con x || 2 |x ∈ X , y t+1 = arg min θ 2 (y) -(λ t ) ⊤ By + β 2 ||Con y || 2 |y ∈ Y , λ t+1 = λ t -β(Ax t+1 + By t+1 -b), (30) The ADMM method uses the separable operators in the convex optimization problem to divide a large problem into multiple small problems that can be solved in a distributed manner. In theory, the framework of ADMM can solve most of the large-scale optimization problems. However, there are still some problems in practical applications. For example, if we use a stop criterion to determine whether convergence occurs, the original residuals and dual residuals are both related to β, and β with a large value will lead to difficulty in meeting the convergence conditions [117] . 7) Frank-Wolfe Method: In 1956, Frank and Wolfe proposed an algorithm for solving linear constraint problems [118] . The basic idea is to approximate the objective function with a linear function, then solve the linear programming to find the feasible descending direction, and finally make a onedimensional search along the direction in the feasible domain. This method is also called the approximate linearization method. Here, we give a simple example of Frank-Wolfe method. Consider the optimization problem,    min f (x), s.t. Ax = b, x ≥ 0, (31) where A is an m × n full row rank matrix, and the feasible region is S = {x|Ax = b, x ≥ 0}. Expand f (x) linearly at x 0 , f (x) ≈ f (x 0 ) + ∇f (x 0 ) ⊤ (x -x 0 ), and substitute it into equation (31) . Then we have min f (x t ) + ∇f (x t ) ⊤ (x -x t ), s.t. x ∈ S, (32) which is equivalent to min ∇f (x t ) ⊤ x, s.t. x ∈ S. (33) Suppose there exist an optimal solution y t , and then there must be ∇f (x t ) ⊤ y t < ∇f (x t ) ⊤ x t , ∇f (x t ) ⊤ (y t -x t ) < 0. ( 34 ) So y tx t is the decreasing direction of f (x) at x t . A fetch step of λ t updates the search point in a feasible direction. The detailed operation is shown in Algorithm 1. Algorithm 1 Frank-Wolfe Method [118] , [119] Input: x 0 , ε ≥ 0, t := 0 Output: x * y t ← min ∇f (x t ) ⊤ x while |∇f (x t ) ⊤ (y t -x t )| > ε do λ t = arg min 0≤λ≤1 f (x t + λ(y t -x t )) x t+1 ≈ x t + λ t (y t -x t ) t := t + 1 y t ← min ∇f (x t ) ⊤ x end while x * ≈ x t The algorithm satisfies the following convergence theorem [118] : (1) x t is the Kuhn-Tucker point of (31) when ∇f (x t ) ⊤ (y tx t ) = 0. (2) Since y t is an optimal solution for problem (33) , the vector d t satisfies d t = y tx t and is the feasible descending direction of f at point x t when ∇f (x t ) ⊤ (y tx t ) = 0. The Frank-Wolfe algorithm is a first-order iterative method for solving convex optimization problems with constrained conditions. It consists of determining the feasible descent direction and calculating the search step size. The algorithm is characterized by fast convergence in early iterations and slower in later phases. When the iterative point is close to the optimal solution, the search direction and the gradient direction of the objective function tend to be orthogonal. Such a direction is not the best downward direction so that the Frank-Wolfe algorithm can be improved and extended in terms of the selection of the descending directions [120] , [121] , [122] . 8) Summary: We summarize the mentioned first-order optimization methods in terms of properties, advantages, and disadvantages in Table I . B. High-Order Methods The second-order methods can be used for addressing the problem where an objective function is highly non-linear and ill-conditioned. They work effectively by introducing curvature information. This section begins with introducing the conjugate gradient method, which is a method that only needs first-order derivative information for well-defined quadratic programming, but overcomes the shortcoming of the steepest descent method, and avoids the disadvantages of Newton's method of storing and calculating the inverse Hessian matrix. But note that when applying it to general optimization problems, the secondorder gradient is needed to get an approximation to quadratic programming. Then, the classical quasi-Newton method using second-order information is described. Although the convergence of the algorithm can be guaranteed, the computational process is costly and thus rarely used for solving large machine learning problems. In recent years, with the continuous improvement of high-order optimization methods, more and more high-order methods have been proposed to handle largescale data by using stochastic techniques [124] , [125] , [126] . From this perspective, we discuss several high-order methods including the stochastic quasi-Newton method (integrating the second-order information and the stochastic method) and their variants. These algorithms allow us to use high-order methods to process large-scale data. 1) Conjugate Gradient Method: The conjugate gradient (CG) approach is a very interesting optimization method, which is one of the most effective methods for solving largescale linear systems of equations. It can also be used for solving nonlinear optimization problems [93] . As we know, the first-order methods are simple but have a slow convergence speed, and the second-order methods need a lot of resources. Conjugate gradient optimization is an intermediate algorithm, which can only utilize the first-order information for some problems but ensures the convergence speed like high-order methods. Early in the 1960s, a conjugate gradient method for solving a linear system was proposed, which is an alternative to Gaussian elimination [127] . Then in 1964, the conjugate gradient method was extended to handle nonlinear optimization for general functions [93] . For years, many different algorithms have been presented based on this method, some of which have been widely used in practice. The main features of these algorithms are that they have faster convergence speed than steepest descent. Next, we describe the conjugate gradient method. Consider a linear system, Aθ = b, ( 35 ) where A is an n × n symmetric, positive-definite matrix. The matrix A and vector b are known, and we need to solve the value of θ. The problem (35) can also be considered as an optimization problem that minimizes the quadratic positive definite function, min θ F (θ) = 1 2 θ ⊤ Aθ -bθ + c. (36) The above two equations have an identical unique solution. It enables us to regard the conjugate gradient as a method for solving optimization problems. The gradient of F (θ) can be obtained by simple calculation, and it equals the residual of the linear system [93] : r(θ) = ∇F (θ) = Aθ -b. Definition 1: Conjugate: Given an n×n symmetric positivedefinite matrix A, two non-zero vector d i , d j are conjugate with respect to A if d ⊤ i Ad j = 0. (37) A set of non-zero vector {d 1 , d 2 , d 3 , ...., d n } is said to be conjugate with respect to A if any two unequal vectors are conjugate with respect to A [93]. Next, we introduce the detailed derivation of the conjugate gradient method. θ 0 is a starting point, {d t } n-1 t=1 is a set of conjugate directions. In general, one can generate the update sequence {θ 1 , θ 2 , ...., θ n } by a iteration formula: θ t+1 = θ t + η t d t . (38) The step size η t can be obtained by a linear search, which means choosing η t to minimize the object function f (•) along θ t +η t d t . After some calculations (more details in [93] , [128] ), the update formula of η t is η t = r ⊤ t r t d ⊤ t Ad t . ( 39 ) The search direction d t is obtained by a linear combination of the negative residual and the previous search direction, d t = -r t + β t d t-1 , (40) where r t can be updated by r t = r t-1 + η t- 1 Ad t-1 . The scalar β t is the update parameter, which can be determined by satisfying the requirement that d t and d t-1 are conjugate with respect to A, i.e., d ⊤ t Ad t-1 = 0. Multiplying both sides of the equation (40) by d ⊤ t-1 A, one can obtain β t by β t = d ⊤ t-1 Ar t d ⊤ t-1 Ad t-1 . ( 41 ) After several derivations of the above formula according to [93] , the simplified version of β t is β t = r ⊤ t r t r ⊤ t-1 r t-1 . ( 42 ) The CG method, has a graceful property that generating a new vector d t only using the previous vector d t-1 , which does not need to know all the previous vectors d 0 , d 1 , d 2 . . . d t-2 . The linear conjugate gradient algorithm is shown in Algorithm 2. TABLE I: Summary of First-Order Optimization Methods Method Properties Advantages Disadvantages GD Solve the optimal value along the direction of the gradient descent. The method converges at a linear rate. The solution is global optimal when the objective function is convex. In each parameter update, gradients of total samples need to be calculated, so the calculation cost is high. SGD [1] The update parameters are calculated using a randomly sampled mini-batch. The method converges at a sublinear rate. The calculation time for each update does not depend on the total number of training samples, and a lot of calculation cost is saved. It is difficult to choose an appropriate learning rate, and using the same learning rate for all parameters is not appropriate. The solution may be trapped at the saddle point in some cases. NAG [105] Accelerate the current gradient descent by accumulating the previous gradient as momentum and perform the gradient update process with momentum. When the gradient direction changes, the momentum can slow the update speed and reduce the oscillation; when the gradient direction remains, the momentum can accelerate the parameter update. Momentum helps to jump out of locally optimal solution. It is difficult to choose a suitable learning rate. AdaGrad [30] The learning rate is adaptively adjusted according to the sum of the squares of all historical gradients. In the early stage of training, the cumulative gradient is smaller, the learning rate is larger, and learning speed is faster. The method is suitable for dealing with sparse gradient problems. The learning rate of each parameter adjusts adaptively. As the training time increases, the accumulated gradient will become larger and larger, making the learning rate tend to zero, resulting in ineffective parameter updates. A manual learning rate is still needed. It is not suitable for dealing with non-convex problems. AdaDelta/ RMSProp [31] , [32] Change the way of total gradient accumulation to exponential moving average. Improve the ineffective learning problem in the late stage of AdaGrad. It is suitable for optimizing non-stationary and non-convex problems. In the late training stage, the update process may be repeated around the local minimum. Adam [33] Combine the adaptive methods and the momentum method. Use the first-order moment estimation and the secondorder moment estimation of the gradient to dynamically adjust the learning rate of each parameter. Add the bias correction. The gradient descent process is relatively stable. It is suitable for most non-convex optimization problems with large data sets and high dimensional space. The method may not converge in some cases. SAG [36] The old gradient of each sample and the summation of gradients over all samples are maintained in memory. For each update, one sample is randomly selected and the gradient sum is recalculated and used as the update direction. The method is a linear convergence algorithm, which is much faster than SGD. The method is only applicable to smooth and convex functions and needs to store the gradient of each sample. It is inconvenient to be applied in nonconvex neural networks. SVRG [37] Instead of saving the gradient of each sample, the average gradient is saved at regular intervals. The gradient sum is updated at each iteration by calculating the gradients with respect to the old parameters and the current parameters for the randomly selected samples. The method does not need to maintain all gradients in memory, which saves memory resources. It is a linear convergence algorithm. To apply it to larger/deeper neural nets whose training cost is a critical issue, further investigation is still needed. ADMM [123] The method solves optimization problems with linear constraints by adding a penalty term to the objective and separating variables into sub-problems which can be solved iteratively. The method uses the separable operators in the convex optimization problem to divide a large problem into multiple small problems that can be solved in a distributed manner. The framework is practical in most largescale optimization problems. The original residuals and dual residuals are both related to the penalty parameter whose value is difficult to determine. Frank-Wolfe [118] The method approximates the objective function with a linear function, solves the linear programming to find the feasible descending direction, and makes a one-dimensional search along the direction in the feasible domain. The method can solve optimization problems with linear constraints, whose convergence speed is fast in early iterations. The method converges slowly in later phases. When the iterative point is close to the optimal solution, the search direction and the gradient of the objective function tend to be orthogonal. Such a direction is not the best downward direction. Algorithm 2 Conjugate Gradient Method [128] Input: A, b, θ 0 Output: The solution θ * r 0 = Aθ 0 -b d 0 = -r 0 , t = 0 while Unsatisfied convergence condition do η t = r ⊤ t rt d ⊤ t Adt θ t+1 = θ t + η t d t r t+1 = r t + η t Ad t β t+1 = r ⊤ t+1 rt+1 r ⊤ t rt d t+1 = -r t+1 + β t+1 d t t = t + 1 end while 2) Quasi-Newton Methods: Gradient descent employs firstorder information, but its convergence rate is slow. Thus, the natural idea is to use second-order information, e.g., Newton's method [129] . The basic idea of Newton's method is to use both the first-order derivative (gradient) and secondorder derivative (Hessian matrix) to approximate the objective function with a quadratic function, and then solve the minimum optimization of the quadratic function. This process is repeated until the updated variable converges. The one-dimensional Newton's iteration formula is shown as θ t+1 = θ t - f ′ (θ t ) f ′′ (θ t ) , ( 43 ) where f is the object function. More general, the highdimensional Newton's iteration formula is θ t+1 = θ t -∇ 2 f (θ t ) -1 ∇f (θ t ) , t ≥ 0, (44) where ∇ 2 f is a Hessian matrix of f . More precisely, if the learning rate (step size factor) is introduced, the iteration formula is shown as d t = -∇ 2 f (θ t ) -1 ∇f (θ t ), θ t+1 = θ t + η t d t , (45) where d t is the Newton's direction, η t is the step size. This method can be called damping Newton's method [130] . Geometrically speaking, Newton's method is to fit the local surface of the current position with a quadratic surface, while the gradient descent method is to fit the current local surface with a plane [131] . Quasi-Newton Method Newton's method is an iterative algorithm that requires the computation of the inverse Hessian matrix of the objective function at each step, which makes the storage and computation very expensive. To overcome the expensive storage and computation, an approximate algorithm was considered which is called the quasi-Newton method. The essential idea of the quasi-Newton method is to use a positive definite matrix to approximate the inverse of the Hessian matrix, thus simplifying the complexity of the operation. The quasi-Newton method is one of the most effective methods for solving non-linear optimization problems. Moreover, the second-order gradient is not directly needed in the quasi-Newton method, so it is sometimes more efficient than Newton's method. In the following section, we will introduce several quasi-Newton methods, in which the Hessian matrix and its inverse matrix are approximated by different methods. Quasi-Newton Condition We first introduce the quasi-Newton condition. Assuming that the objective function f can be approximated by a quadratic function, we can extend f (θ) to Taylor series at θ = θ t+1 , i.e., f (θ) ≈ f (θ t+1 ) + ∇f (θ t+1 ) ⊤ (θ -θ t+1 ) + 1 2 (θ -θ t+1 ) ⊤ ∇ 2 f (θ t+1 )(θ -θ t+1 ). (46) Then we can compute the gradient on both sides of the above equation, and obtain ∇f (θ) ≈ ∇f (θ t+1 ) + ∇ 2 f (θ t+1 )(θ -θ t+1 ). (47) Set θ = θ t in (47), we have ∇f (θ t ) ≈ ∇f (θ t+1 ) + ∇ 2 f (θ t+1 )(θ t -θ t+1 ). (48) Use B to represent the approximate matrix of the Hessian matrix. Set s t = θ t+1θ t , and u t = ∇f (θ t+1 ) -∇f (θ t ). The matrix B t+1 is satisfied that u t = B t+1 s t . ( 49 ) This equation is called the quasi-Newton condition, or secant equation. The search direction of quasi-Newton method is d t = -B -1 t g t , (50) where g t is the gradient of f , and the update of quasi-Newton is θ t+1 = θ t + η t d t . (51) The step size η t is chosen to satisfy the Wolfe conditions, which is a set of inequalities for inexact line searches min ηt f (θ t + η t d t ) [132] . Unlike Newton's method, quasi-Newton method uses B t to approximate the true Hessian matrix. In the following paragraphs, we will introduce some particular quasi-Newton methods, in which H t is used to express the inverse of B t , i.e., H t = B -1 t . DFP In the 1950s, a physical scientist, William C. Davidon [133] , proposed a new approach to solve nonlinear problems. Then Fletcher and Powel [134] explained and improved this method, which sparked a lot of research in the late 1960s and early 1970s [6] . DFP is the first quasi-Newton method named after the initials of their three names. The DFP correction formula is one of the most creative inventions in the field of non-linear optimization, shown as below: B (DF P ) t+1 = (I - u t s ⊤ t u ⊤ t s t )B t (I - s t u ⊤ t u ⊤ t s t ) + u t u ⊤ t u ⊤ t s t . ( 52 ) The update formula of H t+1 is H DF P t+1 = H t - H t u t u ⊤ t H t u ⊤ t H t u t + s t s ⊤ t u ⊤ t s t . ( 53 ) BFGS Broyden, Fletcher, Goldfarb and Shanno proposed the BFGS method [135] , [136] , [137] , [3] , in which B t+1 is updated according to B (BF GS) t+1 = B t - B t s t s ⊤ t B t s ⊤ t B t s t + u t u ⊤ t u ⊤ t s t . (54) The corresponding update of H t+1 is H (BF GS) t+1 = (I - s t u ⊤ t s ⊤ t u t )H t (I - u t s ⊤ t s ⊤ t u t ) + u t s ⊤ t s ⊤ t u t . ( 55 ) The quasi-Newton algorithm still cannot solve large-scale data optimization problem because the method generates a sequence of matrices to approximate the Hessian matrix. Storing these matrices needs to consume computer resources, especially for high-dimensional problems. It is also impossible to retain these matrices in the high-speed storage of computers, restricting its use to even small and midsize problems [138] . L-BFGS Limited memory quasi-Newton methods, named L-BFGS [138] , [139] is an improvement based on the quasi-Newton method, which is feasible in dealing with the highdimensional situation. The method stores just a few ndimensional vectors, instead of retaining and computing fully dense n × n approximations of the Hessian [140] . The basic idea of L-BFGS is to store the vector sequence in the calculation of approximation H t+1 , instead of storing complete matrix H t . L-BFGS makes further consolidation for the update formula of H t+1 , H t+1 = (I - s t u ⊤ t u ⊤ t s t )H t (I - u t s ⊤ t u ⊤ t s t ) + s t s ⊤ t u ⊤ t s t = V ⊤ t H t V t + ρs t s ⊤ t , (56) where V t = I -ρu t s ⊤ t , ρ t = 1 s ⊤ t u t . ( 57 ) The above equation means that the inverse Hessian approximation H t+1 can be obtained using the sequence pair {s l , u l } t l=t-p+1 . H t+1 can be computed if we know pairs {s l , y l } t l=t-p+1 . In other words, instead of storing and calculating the complete matrix H t+1 , L-BFGS only computes the latest p pairs of {s l , y l }. According to the equation, a recursive procedure can be reached. When the latest p steps are retained, the calculation of H t+1 can be expressed as [139] H t+1 = (V ⊤ t V ⊤ t-1 • • • V ⊤ t-p+1 )H 0 t (V t-p+1 V t-p+2 • • • V t ) + ρ t-p+1 (V ⊤ t V ⊤ t-1 • • • V t-p+2 )s t-p+1 s ⊤ t-p+1 (V t-p+2 • • • V t ) + ρ t-p+2 (V ⊤ t V ⊤ t-1 • V ⊤ t-p+3 )s t-p+2 s ⊤ t-p+2 (V t-p+3 • • • V t ) + • • • + ρ t s t s ⊤ t . (58) The update direction d t = H t g t can be calculated, where g t is the gradient of the objective function f . The detailed algorithm is shown in Algorithms 3 and 4. For more information about BFGS and L-BFGS algorithms, one can refer to [93] , [138] . Recently, the batch L-BFGS on machine learning was proposed [141] , which uses the Algorithm 3 Two-Loop Recursion for H t g t [93] Input: ∇f t , u t , s t Output: H t+1 g t+1 g t = ∇f t H 0 t = s ⊤ t ut ut 2 I for l = t -1 to t -p do η l = ρ l s ⊤ l g l+1 g l = g l+1 -η l u l end for r t-p-1 = H 0 t g t-p for l = t -p to t -1 do β l = ρ l u ⊤ l ρ l-1 ρ l = ρ l-1 + s l (η l -β l ) end for H t+1 g t+1 = ρ Algorithm 4 Limited-BFGS [139] Input: θ 0 ∈ R n , ǫ > 0 Output: the solution θ * t = 0 g 0 = ∇f 0 u 0 = 1 s 0 = 1 while g t < ǫ do Choose H 0 t , for example H 0 t = s ⊤ t ut ut 2 I g t = ∇f t d t = -H t g t from Algorithm L-BFGS two-loop recursion for H t g t Search a step size η t through Wolfe rule θ t+1 = θ t + η t d t if k > p then Discard the vector pair {s t-p , y t-p } from storage end if Compute and save s t = θ t+1θ t , u t = g t+1g t t = t + 1 end while overlapping mini-batches for consecutive samples for quasi-Newton update. It means that the calculation of u t becomes u t = ∇ St+1 f (θ t+1 )-∇ St f (θ t ) , where S t is a small subset of samples, meanwhile S t+1 and S t are not independent, perhaps containing a relatively large overlap. Some numerical results in [141] have shown that the modification in L-BFGS is effective in practice. 3) Stochastic Quasi-Newton Method: In many large-scale machine learning models, it is necessary to use a stochastic approximation algorithm with each step of update based on a relatively small training subset [125] . Stochastic algorithms often obtain the best generalization performances in largescale learning systems [142] . The quasi-Newton method only uses the first-order gradient information to approximate the Hessian matrix. It is a natural idea to combine the quasi-Newton method with the stochastic method, so that it can perform on large-scale problems. Online-BFGS and online-LBFGS are two variants of BFGS [124] . Consider the minimization of a convex stochastic function, min θ∈R F (θ) = E[f (θ, ξ)], (59) where ξ is a random seed. We assume that ξ represents a sample (or a set of samples) consisting of an input-output pair (x, y). In machine learning x typically represents an input and y is the target output. f usually has the following form: f (θ; ξ) = f (θ; x i , y i ) = l(h(w; x i ); y i ), ( 60 ) where h is a prediction model parameterized by θ, and l is a loss function. We define f i (θ) = f (θ; x i , y i ), and use the empirical loss to define the objective, F (θ) = 1 N N i=1 f i (θ). (61) Typically, if a large amount of training data is used to train the machine learning models, a better choice is using minibatch stochastic gradient, ∇F St (θ t ) = 1 c i∈St ∇f i (θ t ), (62) where subset S t ⊂ {1, 2, 3 • • • N } is randomly selected. c is the cardinality of S t and c ≪ N . Let S H t ⊂ {1, 2, 3, • • • , N } be a randomly chosen subset of the training samples and the stochastic Hessian estimate can be ∇ 2 F St (θ t ) = 1 c h i∈S H t ∇ 2 f i (θ t ), (63) where c h is the cardinality of S H t . With given stochastic gradient, a direct approach to develop stochastic quasi-Newton method is to transform deterministic gradients into stochastic gradients throughout the iterations, such as online-BFGS and online-LBFGS [124] , which are two stochastic adaptations of the BFGS algorithms. Specifically, following the BFGS described in the previous section, s t , u t are modified as s t := θ t+1θ t and u t := ∇F St (θ t+1 ) -∇F St (θ t ). (64) One disadvantage of this method is that each iteration requires two gradient estimates. Besides this, a more worrying fact is that updating the inverse Hessian approximations in each step may not be reasonable [143] . Then the stochastic quasi-Newton (SQN) method was proposed, which is to use sub-sampled Hessian-vector products to update H t by the LBFGS according to [125] . Meanwhile, the authors proposed an effective approach that decouples the stochastic gradient and curvature estimate calculations to obtain a stable Hessian approximation. In particular, since ∇F (θ t+1 ) -∇F (θ t ) ≈ ∇ 2 F (θ t )(θ t+1 -θ t ), (65) u t can be rewritten as u t := ∇ 2 F S H t (θ t )s t . (66) Based on these techniques, an SQN Framework was proposed, and the detailed procedure is shown in Algorithm 5. Algorithm 5 SQN Framework [143] Input: θ 0 , V , m, η t Output: The solution θ * for t=1, 2, 3, 4,....., do s ′ t = H t g t using the two-loop recursion. s t = -η t s ′ t θ t+1 = θ t + s ′ t if update pairs then Compute s t and u t Add a new displacement pair {s t , u t } to V if |V | > m then Remove the eldest pair from V end if end if end for In the above algorithm, V = {s t , u t } is a collection of m displacement pairs, and g t is the current stochastic gradient ∇F St (θ t ). Meanwhile, the matrix-vector product H t g t can be computed by a two-loop recursion as described in the previous section. Recently, more and more work has achieved very good results in stochastic quasi-Newton. Specifically, a regularized stochastic BFGS method was proposed, which makes a corresponding analysis of the convergence of this optimization method [144] . Further, an online L-BFGS was presented in [145] . A linearly convergent method was proposed [126] , which combines the L-BFGS method in [125] with the variance reduction technique. Besides these, a variance reduced block L-BFGS method was proposed, which works by employing the actions of a subsampled Hessian on a set of random vectors [146] . To sum up, we have discussed the techniques of using stochastic methods in second-order optimization. The stochastic quasi-Newton method is a combination of the stochastic method and the quasi-Newton method, which makes the quasi-Newton method extend to large datasets. We have introduced the related work of the stochastic quasi-Newton method in recent years, which reflects the potential of the stochastic quasi-Newton method in machine learning applications. 4) Hessian-Free Optimization Method: The main idea of Hessian-free (HF) method is similar to Newton's method, which employs second-order gradient information. The difference is that the HF method is not necessary to directly calculate the Hessian matrix H. It estimates the product Hv by some techniques, and thus is called \"Hessian free\". Consider a local quadratic approximation Q θ (d t ) of the object F around parameter θ, F (θ t +d t ) ≈ Q θ (d t ) = F (θ t )+∇F (θ t ) ⊤ d t + 1 2 d ⊤ t B t d t , (67) where d t is the search direction. The HF method applies the conjugate gradient method to compute an approximate solution d t of the linear system, B t d t = -∇F (θ t ), (68) where B t = H(θ t ) is the Hessian matrix, but in practice B t is often defined as B t = H(θ t ) + λI, λ ≥ 0 [7] . The new update is then given by θ t+1 = θ t + η t d t , (69) where η t is the step size that ensures sufficient decrease in the objective function, usually obtained by a linear search. According to [7] , the basic framework of HF optimization is shown in Algorithm 6. Algorithm 6 Hessian-Free Optimization Method [7] Input: θ 0 , ∇f (θ 0 ), λ Output: The solution θ * t = 0 repeat g t = ∇f (θ t ) Compute λ by some methods B t (v) ≡ H(θ t )v + λv Compute the step size η t d t = CG(B t , -g t ) θ t+1 = θ t + η t d t t = t + 1 until satisfy convergence condition The advantage of using the conjugate gradient method is that it can calculate the Hessian-vector product without directly calculating the Hessian matrix. Because in the CGalgorithm, the Hessian matrix is paired with a vector, then we can compute the Hessian-vector product to avoid the calculation of the Hessian inverse matrix. There are many ways to calculate Hessian-vector products, one of which is calculated by a finite difference as [7] Hv = lim ε→+0 ∇f (θ + εv) -∇f (θ) ε . (70) Sub-sampled Hessian-Free Method HF is a well-known method, and has been studied for decades in the optimization literatures, but has shortcomings when applied to deep neural networks with large-scale data [7] . Therefore, a sub-sampled technique is employed in HF, resulting in an efficient HF method [7] , [147] . The cost in each iteration can be reduced by using only a small sample set S to calculate Hv. The objective function has the following form: min F (θ) = 1 N N i=1 f i (θ). (71) In the tth iteration, the stochastic gradient estimation can be written as ∇F St (θ t ) = 1 |S t | i∈St ∇f i (θ t ), (72) and the stochastic Hessian estimate is expressed as ∇ 2 F S H t (θ t ) = 1 |S H t | i∈S H t ∇ 2 f i (θ t ). ( 73 ) As described above, we can obtain the approximate solution of direction d t by employing the CG method to solve the linear system, ∇ 2 F S H t (θ t )d t = -∇F St (θ t ), (74) in which the stochastic gradient and stochastic Hessian matrix are used. The basic framework of sub-sampled HF algorithm is given in [147] . A natural question is how to determine the size of S H t . On one hand, S H t can be chosen small enough so that the total cost of CG iteration is not much greater than a gradient evaluation. On the other hand, S H t should be large enough to get useful curvature information from Hessian-vector product. How to balance the size of S H t is a challenge being studied [147] . 5) Natural Gradient: The natural gradient method can be potentially applied to any objective function which measures the performance of some statistical models [148] . It enjoys richer theoretical properties when applied to objective functions based on the KL divergence between the model's distribution and the target distribution, or certain approximation surrogates of these [149] . The traditional gradient descent algorithm is based on the Euclidean space. However, in many cases, the parameter space is not Euclidean, and it may have a Riemannian metric structure. In this case, the steepest direction of the objective function cannot be given by the ordinary gradient and should be given by the natural gradient [148] . We consider such a model distribution p(y|x, θ), and π(x, y) is an empirical distribution. We need to fit the parameters θ ∈ R N . Assume that x is an observation vector, and y is its associated label. It has the objective function, F (θ) = E (x,y)∼π [-log p(y|x, θ)], (75) and we need to solve the optimization problem, θ * = argmin θ F (θ). (76) According to [148] , the natural gradient can be transformed from a traditional gradient multiplied by a Fisher information matrix, i.e., ∇ N F = G -1 ∇F, ( 77 ) where F is the object function, ▽F is the traditional gradient, ▽ N F is the natural gradient, and G is the Fisher information matrix, with the following form: G = E x∼π E y∼p(y|x,θ) ( ∂p(y|x; θ) ∂θ )( ∂p(y|x; θ) ∂θ ) ⊤ . (78) The update formula with the natural gradient is θ t = θ t -η t ∇ N F. ( 79 ) We cannot ignore that the application of the natural gradient is very limited because of too much computation. It is expensive to estimate the Fisher information matrix and calculate its inverse matrix. To overcome this limitation, the truncated Newton's method was developed [7] , in which the inverse is calculated by an iterative procedure, thus avoiding the direct calculation of the inverse of the Fisher information matrix. In addition, the factorized natural gradient (FNG) [150] and Kronecker-factored approximate curvature (K-FAC) [151] methods were proposed to use the derivatives of probabilistic models to calculate the approximate natural gradient update. 6) Trust Region Method: The update process of most methods introduced above can be described as θ t + η t d t . The displacement of the point in the direction of d t can be written as s t . The typical trust region method (TRM) can be used for unconstrained nonlinear optimization problems [140] , [152] , [153] , in which the displacement s t is directly determined without the search direction d t . For the problem min f θ (x), the TRM [140] uses the secondorder Taylor expansion to approximate the objective function f θ (x), denoted as q t (s). Each search is done within the range of trust region with radius △ t . This problem can be described as    min q t (s) = f θ (x t ) + g ⊤ t s + 1 2 s ⊤ B t s, s.t. ||s t || ≤ △ t , (80) where g t is the approximate gradient of the objective function f (x) at the current iteration point x t , g t ≈ ∇f (x t ), B t is a symmetric matrix, which is the approximation of Hessian matrix ∇ 2 f θ (x t ), and △ t > 0 is the radius of the trust region. If the L 2 norm is used in the constraint function, it becomes the Levenberg-Marquardt algorithm [154] . If s t is the solution of the trust region subproblem (80), the displacement s t of each update is limited by the trust region radius △ t . The core part of the TRM is the update of △ t . In each update process, the similarity of the quadratic model q(s t ) and the objective function f θ (x) is measured, and △ t is updated dynamically. The actual amount of descent in the tth iteration is [140] △f t = f t -f (x t + s t ). (81) The predicted drop in the tth iteration is △q t = f t -q(s t ). (82) The ratio r t is defined to measure the approximate degree of both, r t = △f t △q t . ( 83 ) It indicates that the model is more realistic than expected when r t is close to 1, and then we should consider expanding △ t . At the same time, it indicates that the model predicts a large drop and the actual drop is small when r t is close to 0, and then we should reduce △ t . Moreover, if r t is between 0 and 1, we can leave △ t unchanged. The thresholds 0 and 1 are generally set as the left and right boundaries of r t [140] . 7) Summary: We summarize the mentioned high-order optimization methods in terms of properties, advantages and disadvantages in Table II . C. Derivative-Free Optimization For some optimization problems in practical applications, the derivative of the objective function may not exist or is not easy to calculate. The solution of finding the optimal point, in this case, is called derivative-free optimization, which is a discipline of mathematical optimization [155] , [156] , [157] . It can find the optimal solution without the gradient information. There are mainly two types of ideas for derivativefree optimization. One is to use heuristic algorithms. It is characterized by empirical rules and chooses methods that have already worked well, rather than derives solutions systematically. There are many types of heuristic optimization methods, including classical simulated annealing arithmetic, genetic algorithms, ant colony algorithms, and particle swarm optimization [158] , [159] , [160] . These heuristic methods usually yield approximate global optimal values, and theoretical support is weak. We do not focus on such techniques in this section. The other is to fit an appropriate function according to the samples of the objective function. This type of method usually attaches some constraints to the search space to derive the samples. Coordinate descent method is a typical derivativefree algorithm [161] , and it can be extended and applied to optimization algorithms for machine learning problems easily. In this section, we mainly introduce the coordinate descent method. The coordinate descent method is a derivative-free optimization algorithm for multi-variable functions. Its idea is that a one-dimensional search can be performed sequentially along each axis direction to obtain updated values for each dimension. This method is suitable for some problems in which the loss function is non-differentiable. The vanilla approach is to select a set of bases e 1 , e 2 , ..., e D in the linear space as the search directions and minimizes the value of the objective function in each direction. For the target function L(Θ), when Θ t is already obtained, the jth dimension of Θ t+1 is solved by [155] θ t+1 j = arg min θj∈R L(θ t+1 1 , ..., θ t+1 j-1 , θ j , θ t j+1 , ..., θ t D ). (84) Thus, L(Θ t+1 ) ≤ L(Θ t ) ≤ ... ≤ L(Θ 0 ) is guaranteed. The convergence of this method is similar to the gradient descent method. The order of update can be an arbitrary arrangement from e 1 to e D in each iteration. The descent direction can be generalized from the coordinate axis to the coordinate block [162] . The main difference between the coordinate descent and the gradient descent is that each update direction in the gradient descent method is determined by the gradient of the current position, which may not be parallel to any coordinate axis. In the coordinate descent method, the optimization direction is fixed from beginning to end. It does not need to calculate the gradient of the objective function. In each iteration, the update is only executed along the direction of one axis, and thus the calculation of the coordinate descent method is simple even for some complicated problems. For indivisible functions, the algorithm may not be able to find the optimal solution in a small number of iteration steps. An appropriate coordinate system can be used to accelerate the convergence. For example, the adaptive coordinate descent method takes principal component analysis to obtain a new coordinate system with as little correlation as possible between the coordinates [163] . The coordinate descent method still has limitations when performing on the non-smooth objective function, which may fall into a non-stationary point. TABLE II: Summary of High-Order Optimization Methods Method Properties Advantages Disadvantages Conjugate Gradient [127] It is an optimization method between the first-order and second-order gradient methods. It constructs a set of conjugated directions using the gradient of known points, and searches along the conjugated direction to find the minimum points of the objective function. CG method only calculates the first order gradient but has faster convergence than the steepest descent method. Compared with the first-order gradient method, the calculation of the conjugate gradient is more complex. Newton's Method [129] Newton's method calculates the inverse matrix of the Hessian matrix to obtain faster convergence than the first-order gradient descent method. Newton's method uses second-order gradient information which has faster convergence than the first-order gradient method. Newton's method has quadratic convergence under certain conditions. It needs long computing time and large storage space to calculate and store the inverse matrix of the Hessian matrix at each iteration. Quasi-Newton Method [93] Quasi-Newton method uses an approximate matrix to approximate the the Hessian matrix or its inverse matrix. Popular quasi-Newton methods include DFP, BFGS and LBFGS. Quasi-Newton method does not need to calculate the inverse matrix of the Hessian matrix, which reduces the computing time. In general cases, quasi-Newton method can achieve superlinear convergence. Quasi-Newton method needs a large storage space, which is not suitable for handling the optimization of large-scale problems. Sochastic Quasi-Newton Method [143] . Stochastic quasi-Newton method employs techniques of stochastic optimization. Representative methods are online-LBFGS [124] and SQN [125] . Stochastic quasi-Newton method can deal with large-scale machine learning problems. Compared with the stochastic gradient method, the calculation of stochastic quasi-Newton method is more complex. Hessian Free Method [7] HF method performs a suboptimization using the conjugate gradient, which avoids the expensive computation of inverse Hessian matrix. HF method can employ the secondorder gradient information but does not need to directly calculate Hessian matrices. Thus, it is suitable for high dimensional optimization. The cost of computation for the matrixvector product in HF method increases linearly with the increase of training data. It does not work well for largescale problems. Sub-sampled Hessian Free Method [147] Sup-sampled Hessian free method uses stochastic gradient and sub-sampled Hessian-vector during the process of updating. The sub-sampled HF method can deal with large-scale machine learning optimization problems. Compared with the stochastic gradient method, the calculation is more complex and needs more computing time in each iteration. Natural Gradient [148] The basic idea of the natural gradient is to construct the gradient descent algorithm in the predictive function space rather than the parametric space. The natural gradient uses the Riemann structure of the parametric space to adjust the update direction, which is more suitable for finding the extremum of the objective function. In the natural gradient method, the calculation of the Fisher information matrix is complex. D. Preconditioning in Optimization Preconditioning is a very important technique in optimization methods. Reasonable preconditioning can reduce the iteration number of optimization algorithms. For many important iterative methods, the convergence depends largely on the spectral properties of the coefficient matrix [164] . It can be simply considered that the pretreatment is to transform a difficult linear system Aθ = b into an equivalent system with the same solution but better spectral characteristics. For example, if M is a nonsingular approximation of the coefficient matrix A, the transformed system, M -1 Aθ = M -1 b, (85) will have the same solution as the system Aθ = b. But ( 85 ) may be easier to solve and the spectral properties of the coefficient matrix M -1 A may be more favorable. In most linear systems, e.g., Aθ = b, the matrix A is often complex and makes it hard to solve the system. Therefore, some transformation is needed to simplify this system. M is called the preconditioner. If the matrix after using preconditioner is obviously structured, or sparse, it will be beneficial to the calculation [165] . The conjugate gradient algorithm mentioned previously is the most commonly used optimization method with preconditioning technology, which speeds up the convergence. The algorithm is shown in Algorithm 7. E. Public Toolkits for Optimization Fundamental optimization methods are applied in machine learning problems extensively. There are many integrated powerful toolkits. We summarize the existing common optimization toolkits and present them in Table III . IV. DEVELOPMENTS AND APPLICATIONS FOR SELECTED MACHINE LEARNING FIELDS Optimization is one of the cores of machine learning. Many optimization methods are further developed in the face of different machine learning problems and specific application environments. The machine learning fields selected in this TABLE III: Available Toolkits for Optimization Toolkit Language Description CVX [166] Matlab CVX is a matlab-based modeling system for convex optimization but cannot handle large-scale problems. http://cvxr.com/cvx/download/ CVXPY [167] Python CVXPY is a python package developed by Stanford University Convex Optimization Group for solving convex optimization problems. http://www.cvxpy.org/ CVXOPT [168] Python CVXOPT can be used for handling convex optimization. It is developed by Martin Andersen, Joachim Dahl, and Lieven Vandenberghe. http://cvxopt.org/ APM [169] Python APM python is suitable for large-scale optimization and can solve the problems of linear programming, quadratic programming, integer programming, nonlinear optimization and so on. http://apmonitor.com/wiki/index.php/Main/PythonApp SPAMS [123] C++ SPAMS is an optimization toolbox for solving various sparse estimation problems, which is developed and maintained by Julien Mairal. Available interfaces include matlab, R, python and C++. http://spams-devel.gforge.inria.fr/ minConf Matlab minConf can be used for optimizing differentiable multivariate functions which subject to simple constraints on parameters. It is a set of matlab functions, in which there are many methods to choose from. https://www.cs.ubc.ca/ ∼ schmidtm/Software/minConf.html tf.train.optimizer [170] Python; C++; CUDA The basic optimization class, which is usually not called directly and its subclasses are often used. It includes classic optimization algorithms such as gradient descent and AdaGrad. https://www.tensorflow.org/api guides/python/train Algorithm 7 Preconditioned Conjugate Gradient Method [93] Input: A, θ 0 , M , b Output: The solution θ * f 0 = f (θ 0 ) g 0 = ∇f (θ 0 ) = Aθ 0 -b y 0 is the solution of M y = g 0 d 0 = -g 0 t = t while g t = 0 do η t = g ⊤ t yt d ⊤ t Adt θ t+1 = θ t + η t d t g t+1 = g t + η t Ad t y t+1 =solution of M y = g t β t+1 = g ⊤ t+1 yt+1 g ⊤ t dt d t+1 = -y t+1 + β t+1 d t t = t + 1 end while section mainly include deep neural networks, reinforcement learning, variational inference and Markov chain Monte Carlo. A. Optimization in Deep Neural Networks The deep neural network (DNN) is a hot topic in the machine learning community in recent years. There are many optimization methods for DNNs. In this section, we introduce them from two aspects, i.e., first-order optimization methods and high-order optimization methods. 1) First-Order Gradient Method in Deep Neural Networks: The stochastic gradient optimization method and its adaptive variants have been widely used in DNNs and have achieved good performance. SGD introduces the learning rate decay factor and AdaGrad accumulates all previous gradients so that their learning rates are continuously decreased and converge to zero. However, the learning rates of these two methods make the update slow in the later stage of optimization. AdaDelta, RMSProp, Adam and other methods use the exponential averaging to provide effective updates and simplify the calculation. These methods use exponential moving average to alleviate the problems caused by the rapid decay of the learning rate but limit the current learning rate to only relying on a few gradients [34] . Reddi et al. used a simple convex optimization example to demonstrate that the RMSProp and Adam algorithms could not converge [34] . Almost all the algorithms that rely on a fixed-size window of the past gradients will suffer from this problem, including AdaDelta and Nesterov-accelerated adaptive moment estimation (Nadam) [171] . It is better to rely on the long-term memory of past gradients rather than the exponential moving average of gradients to ensure convergence. A new version of Adam [34] , called AmsGrad, uses a simple correction method to ensure the convergence of the model while preserving the original computational performance and advantages. Compared with the Adam method, the AmsGrad makes the following changes to the first-order moment estimation and the second-order moment estimation:        m t = β 1t m t-1 + (1 -β 1t )g t , V t = β 2 V t-1 + (1 -β 2 )g 2 t , Vt = max( Vt-1 , V t ), (86) where β 1t is a non-constant which decreases with time, and β 2 is a constant learning rate. The correction is operated in the second-order moment V t , making Vt monotonous. Vt is substantially used in the iteration of the target function. The AmsGrad method takes the long-term memory of past gradients based on the Adam method, guarantees the convergence in the later stage, and works well in applications. Further, adjusting parameters β 1 , β 2 at the same time helps to converge to a certain extent. For example, β 1 can decay modestly as β 1t = β1 t , β 1t ≤ β 1 , for all t ∈ [T ]. β 2 can be set as β 2t = 1 -1 t , for all t ∈ [T ], as in AdamNC algorithm [34] . Another idea of combining SGD and Adam was proposed for solving the non-convergence problem of adaptive gradient algorithm [38] . Adaptive algorithms, such as Adam, converge fast and are suitable for processing sparse data. SGD with momentum can converge to more accurate results. The combination of SGD and Adam develops the advantages of both methods. Specifically, it first trains with Adam to quickly drop and then switches to SGD for precise optimization based on the previous parameters at an appropriate switch point. The strategy is named as switching from Adam to SGD (SWATS) [38] . There are two core problems in SWATS. One is when to switch from Adam to SGD, the other is how to adjust the learning rate after switching the optimization algorithm. The SWATS approach is described in detail below. The movement d Adam of the parameter at iteration t of the Adam is d Adam t = η Adam V t m t , (87) where η Adam is the learning rate of Adam [38] . The movement d SGD of the parameter at iteration t of the SGD is d SGD t = η SGD g t , (88) where η SGD is the learning rate of SGD and g t is the gradient of the current position [38] . The movement of SGD can be decomposed into the learning rates along Adam's direction and its orthogonal direction. If SGD is going to finish the trajectory but Adam has not finished due to the momentum after selecting the optimization direction, walking along Adam's direction is a good choice for SWATS. At the same time, SWATS also adjusts its optimized trajectory by moving in the orthogonal direction. Let P roj Adam d SGD t = d Adam t , (89) and derive solution η SGD t = (d Adam t ) T d Adam t (d Adam t ) T g t , (90) where P roj Adam means the projection in the direction of Adam. To reduce noise, a moving average can be used to correct the estimate of the learning rate, λ SGD t = β 2 λ SGD t-1 + (1 -β 2 )η SGD t , (91) λt SGD = λ SGD t 1 -β 2 , (92) where λ SGD t is the first moment of learning rate η SGD , and λt SGD is the learning rate of SGD after converting [38] . For switch point, a simple guideline | λt SGDλ SGD t | < ǫ is often used [38] . Although there is no rigorous mathematical proof for selecting this conversion criterion, it performs well across a variety of applications. For the mathematical proof of switch point, further research can be conducted. Although the SWATS is based on Adam, this switching method is also applicable to other adaptive methods, such as AdaGrad and RMSProp. The procedure is insensitive to hyper-parameters and can obtain an optimal solution comparable to SGD, but with a faster training speed in the case of deep networks. Recently some researchers are trying to explain and improve the adaptive methods [172] , [173] . Their strategies can also be combined with the above switching techniques to enhance the performance of the algorithm. General fully connected neural networks cannot process sequential data such as text and audio. Recurrent neural network (RNN) is a kind of neural networks that is more suitable for processing sequential data. It was generally considered that the use of first-order methods to optimize RNN was not effective, because the SGD and its variant methods were difficult to learn long-term dependencies in sequence problems [99] , [104] , [174] . In recent years, a well-designed method of random parameter initialization scheme using only SGD with momentum without curvature information has achieved good results in training RNNs [99] . In [104] , [175] , some techniques for improving the optimization in training RNNs are summarized such as the momentum methods and NAG. The first-order optimization methods have got development for training RNNs, but they still face the problem of slow convergence in deep RNNs. The high-order optimization methods employing curvature information can accelerate the convergence near the optimal value and is considered to be more effective in optimizing DNNs. 2) High-Order Gradient Method in Deep Neural Networks: We have described the first-order optimization method applied in DNNs. As most DNNs use large-scale data, different versions of stochastic gradient methods were developed and have got excellent performance and properties. For making full use of gradient information, the second-order method is gradually applied to DNNs. In this section, we mainly introduce the Hessian-free method in DNN. Hessian-free (HF) method has been studied for a long time in the field of optimization, but it is not directly suitable for dealing with neural networks [7] . As the objective function in DNN is not convex, the exact Hessian matrix may not be positive definite. Therefore, some modifications need to be made so that the HF method can be applied to neural networks [176] . The Generalized Gauss-Newton Matrix One solution is to use the generalized Gauss-Newton (GGN) matrix, which can be seen as an approximation of a Hessian matrix [177] . The GGN matrix is a provably positive semidefinite matrix, which avoids the trouble of negative curvature. There are at least two ways to derive the GGN matrix [176] . Both of them require that f (θ) can be expressed as a composition of two functions written as f (θ) = Q(F (θ)) where f (θ) is the object function and Q is convex. The GGN matrix G takes the following form, G = J ⊤ Q ′′ J, (93) where J is the Jacobian of F . Damping Methods Another modification to the HF method is to use different damping methods. For example, Tikhonov damping, one of the most famous damping methods, is implemented by introducing a quadratic penalty term into the quadratic model. A quadratic penalty term λ 2 d ⊤ d is added to the quadratic model, Q(θ) := Q(θ) + λ 2 d ⊤ d = f (θ t ) + ∇f (θ t ) ⊤ d + 1 2 d ⊤ Bd, (94) where B = H + λI, and λ > 0 determines the \"strength\" of the damping which is a scalar parameter. Thus, Bv is formulated as Bv = (H + λI)v = Hv + λv. However, the basic Tikhonov damping method is not good in training RNNs [178] . Due to the complex structure of RNNs, the local quadratic approximation in certain directions in the parameter space, even at very small distances, maybe highly imprecise. The Tikhonov damping method can only compensate for this by increasing punishment in all directions because the method lacks a selective mechanism [176] . Therefore, the structural damping was proposed, which makes the performance substantially better and more robust. The HF method with structural damping can effectively train RNNs [176] . Now we briefly introduce the HF method with structural damping. Let e(x, θ) mean the vector-value function of θ which can be interpreted as intermediate quantities during the calculation of f (x, θ), where f (x, θ) is the object function. For instance, e(x, θ) might contain the activation function of some layers of hidden units in neural networks (like RNNs). A structural damping can be defined as R(θ) = 1 |S| (x,y)∈S D(e(x, θ), e(x, θ t )), (95) where D is a distance function or a loss function. It can prevent a large change in e(x, θ) by penalizing the distance between e(x, θ) and e(x, θ t ). Then, the damped local objective can be written as Q θ (d) ′ = Q θ (d) + µR(d + θ t ) + λ 2 d ⊤ d, (96) where µ and λ are two parameters to be dynamically adjusted. d is the direction at the tth iteration. More details of the structural damping can refer to [176] . Besides, there are many second-order optimization methods employed in RNNs. For example, quasi-Newton based optimization and L-BFGS were proposed to train RNNs [179] , [180] . In order to make the damping method based on punishment work better, the damping parameters can be adjusted continuously. A Levenberg-Marquardt style heuristic method was used to adjust λ directly [7] . The Levenberg-Marquardt heuristic is described as follows: 1 ) If γ < 1 4 λ then λ ← 3 2 λ, 2) If γ > 3 4 λ then λ ← 2 3 λ, where γ is a \"reduction rate\" with the following form, γ = f (θ t-1 + d t ) -f (θ t-1 ) M t-1 (d t ) . (97) Sub-sampling As sub-sampling Hessian can be used to handle large-scale data, several variations of the sub-sampling methods were proposed [8] , [9] , [10] , which used either stochastic gradients or exact gradients. These approaches use B t = ∇ 2 St f (θ t ) as a Hessian approximation, where S t is a subset of samples. We need to compute the Hessian-vector product in some optimization methods. If we adopt the subsampling method, it also means that we can save a lot of computation in each iteration, such as the method proposed in [7] . Preconditioning Preconditioning can be used to simplify the optimization problems. For example, preconditioning can accelerate the CG method. It is found that diagonal matrices are particularly effective and one can use the following preconditioner [7] : M = diag( N i=1 ∇f i (θ) ⊙ ∇f i (θ)) + λI α , (98) where ⊙ denotes the element-wise product and the exponent α is chosen to be less than 1. B. Optimization in Reinforcement Learning Reinforcement learning (RL) is an important research field of machine learning and is also one of the most popular topics. Agents using deep reinforcement learning have achieved great success in learning complex behavior skills and solved challenging control tasks in high-dimensional primitive perceptual state space [181] , [182] , [183] . It interacts with the environment through the trial-and-error mechanism and learns optimal strategies by maximizing cumulative rewards [39] . We describe several concepts of reinforcement learning as follows: 1) Agent: making different actions according to the state of the external environment, and adjusting the strategy according to the reward of the external environment. 2) Environment: all things outside the agent that will be affected by the action of the agent. It can change the state and provide the reward to the agent. 3) State s: a description of the environment. 4) Action a: a description of the behavior of the agent. 5) Reward r t (s t-1 , a t-1 , s t ): the timely return value at time t. 6) Policy π(a|s): a function that the agent decides the action a according to the current state s. 7) State transition probability p(s ′ |s, a): the probability distribution that the environment will transfer to state s ′ at the next moment, after the agent selecting an action a based on the current state s. 8) p(s ′ , r|s, a): the probability that the agent transforms to state s ′ and obtains the reward r, where the agent is in state s and selecting the action a. Many reinforcement learning problems can be described by Markov decision process (MDP) < S, A, P, γ, r > [39] , in which S is state space, A is action space, P is state transition probability function, r is reward function and γ is the discount factor 0 < γ < 1. At each time, the agent accepts a state and selects the action from an action set according to the policy. The agent receives feedback from the environment and then moves to the next state. The goal of reinforcement learning is to find a strategy that allows us to get the maximum γ-discounted cumulative reward. The discounted return is calculated by G t = ∞ k=0 γ k r t+k . (99) People do not necessarily know the MDP behind the problem. From this point, reinforcement learning is divided into two categories. One is model-based reinforcement learning which knows the MDP of the whole model (including the transition probability P and reward function r), and the other is the model-free method in which the MDP is unknown. Systematic exploration is required in the latter methods. The most commonly used value function is the state value function, V π (s) = E π [G t |S t = s], (100) which is the expected return of executing policy π from state s. The state-action value function is also essential which is the expected return for selecting action a under state s and policy π, Q π (s, a) = E π [G t |S t = s, A t = a]. (101) The value function of the current state s can be calculated by the value function of the next state s ′ . The Bellman equations of V π (s) and Q π (s, a) describe the relation by V π (s) = a π(a|s) s ′ ,r p(s ′ , r|s, a)[r(s, a, s ′ ) + γV π (s ′ )], (102) Q π (s, a) = s ′ ,r p(s ′ , r|s, a)[r(s, a, s ′ ) + γ a ′ π(a ′ |s ′ )Q π (s ′ , a ′ )]. (103) There are many reinforcement learning methods based on value function. They are called value-based methods, which play a significant role in RL. For example, Q-learning [184] and SARSA [185] are two popular methods which use temporal difference algorithms. The policy-based approach is to optimize the policy π θ (a|s) directly and update the parameters θ by gradient descent [186] . The actor-critic algorithm is a reinforcement learning method combining policy gradient and temporal differential learning, which learns both a policy and a state value function. It estimates the parameters of two structures simultaneously. 1) The actor is a policy function, which is to learn a policy π θ (a|s) to obtain the highest possible return. 2) The critic refers to the learned value function V φ (s), which estimates the value function of the current policy, that is to evaluate the quality of the actor. In the actor-critic method, the critic solves a problem of prediction, while the actor pays attention to the control [187] . There is more information of actor-critic method in [88] , [187] The summary of the value-based method, the policy-based method, and the actor-critic method are as follows: 1) The value-based method: It needs to calculate value function, and usually gets a definite policy. 2) The policy-based method: It optimizes the policy π without selecting an action according to value function. 3) The actor-critic method: It combines the above two methods, and learns both the policy π and the state value function. Deep reinforcement learning (DRL) combines reinforcement learning and deep learning, which defines problems and optimizes goals in the framework of RL, and solves problems such as state representation and strategy representation using deep learning techniques. DRL has achieved great success in many challenging control tasks and uses DNNs to represent the control policy. For neural network training, a simple stochastic gradient algorithm or other first-order algorithms are usually chosen, but these algorithms are not efficient in exploring the weight space, which makes DRL methods often take several days to train [60] . So, a distributed method was proposed to solve this problem, in which parallel actor-learners have a stabilizing effect during training [182] . It executes multiple agents to interact with the environment simultaneously, which reduces the training time. But this method ignores the sampling efficiency. A scalable and sample-efficient natural gradient algorithm was proposed, which uses a Kronecker-factored approximation method to compute the natural policy gradient update, and employ the update to the actor and the critic (ACKTR) [60] . C. Optimization in Meta Learning Meta learning [45] , [46] is a popular research direction in the field of machine learning. It solves the problem of learning to learn. In the past cognition, the research of machine learning is to obtain a large amount of data in a specific task firstly and then use the data to train the model. In machine learning, adequate training data is the guarantee of achieving good performance. However, human beings can well process new tasks with only a few training samples, which are much more efficient than traditional machine learning methods. The key point could be that the human brain has learned \"how to learn\" and can make full use of past knowledge and experience to guide the learning of new tasks. Therefore, how to make machines have the ability to learn efficiently like human beings has become a frontier issue in machine learning. The goal of meta learning is to design a model that can training well in the new tasks using as few samples as possible without overfitting. The process of adapting to the new tasks is essentially a learning process in the meta-testing, but only with limited samples from new tasks. The application of meta learning methods in supervised learning can solve the few-shot learning problems [47] . As few-shot learning problems receive more and more attention, meta learning is also developing rapidly. In general, meta learning methods can be summarized into the following three types [48] : metric-based methods [49] , [50] , [51] , [52] , model-based methods [53] , [54] and optimization-based methods [55] , [56] , [47] . In this subsection, we focus on the optimization-based meta learning methods. In meta learning, there are usually some tasks with sufficient training samples and a new task with only a few training samples. The main idea can be described as follows: in the meta-train step, sample a task τ from the total task set T , which contains The process of sampling tasks and updating parameters are repeated multiple times. In the meta-test step, the trained metaoptimizer is used for learning a new task. Since the purpose of meta learning is to achieve fast learning, a key point is to make the gradient descent more accurately in the optimization. In some meta learning methods, the optimization process itself can be regarded as a learning problem to learn the prediction gradient rather than a determined gradient descent algorithm [188] . Neural networks with original gradient as input and prediction gradient as output is often used as a meta-optimizer [55] . The neural work is trained using the training and test samples from other tasks and used in the new task. The parameter update in the process of training is as follows: θ t+1 = θ t + N (g(θ t ), φ), ( 104 ) where θ t is the model parameter at the iteration t, and N is the meta-optimizer with parameter φ that learns how to predict the gradient. After training, the meta-optimizer N and its parameter φ are updated according to the loss value in the test samples. The experiments have confirmed that learning neural optimizers is advantageous compared to the most advanced adaptive stochastic gradient optimization methods used in deep learning [55] . Due to the similarity between the gradient update in backpropagation and the cell state update in the long short-term memory (LSTM), LSTM is often used as the meta-optimizer [55] , [56] . A model-agnostic meta learning algorithm (MAML) is another method for meta learning which was proposed to learn the parameters of any model subjected to gradient descent methods. It is applicable to different learning problems, including classification, regression and reinforcement learning [47] . The basic idea of the model-agnostic algorithm is to begin multiple tasks at the same time, and then get the synthetic gradient direction of different tasks, so as to learn a common base model. The main process can be described as follows: in the meta-train step, multiple tasks batch τ i , which contains (D train i , D test i ), are extracted from the total task set T . For all τ i , train and update the parameter θ ′ i with the train samples D train i : θ ′ i = θ -α ∂J τi (θ) ∂(θ) , (105) where α is the learning rate of training process and J τi (θ) is the loss function in task i with training samples D train i . After the training step, use the synthetic gradient direction of these parameters θ ′ i on the test samples D test i of the respective task to update parameter θ: θ = θ -β ∂ τi∼p(T ) J τi (θ ′ i ) ∂(θ) , ( 106 ) where β is the meta learning rate of the test process and J τi (θ) is the loss function in task i with test samples D test i . The metatrain step is repeated multiple times to optimize a good initial parameter θ. In the meta-test step, the trained parameter θ is used as the initial parameter such that the model has a maximal performance on the new task. MAML does not introduce additional parameters for meta learning, nor does it require a specific learner architecture. The development of the method is of great significance to the optimization-based meta learning methods. Recently, an expanded task-agnostic meta learning algorithm is proposed to enhance the generalization of metalearner towards a variety of tasks, which achieves outstanding performance on few-shot classification and reinforcement learning tasks [189] . D. Optimization in Variational Inference In the machine learning community, there are many attractive probabilistic models but with complex structures and intractable posteriors, and thus some approximate methods are used, such as variational inference and Markov chain Monte Carlo (MCMC) sampling. Variational inference, a common technique in machine learning, is widely used to approximate the posterior density of the Bayesian model, which transforms intricate inference problems into highdimensional optimization problems [190] , [191] . Compared with MCMC, the variational inference is faster and more suitable for dealing with large-scale data. Variational inference has been applied to large-scale machine learning tasks, such as large-scale document analysis, computer vision and computational neuroscience [192] . Variational inference often defines a flexible family of distributions indexed by free parameters on latent variables [190] , and then finds the variational parameters by solving an optimization problem. Now let us review the principle of variational inference [58] . Variational inference approximates the true posterior by attempting to minimize the Kullback-Leibler (KL) divergence between a potential factorized distribution and the true posterior. Let Z = {z i } represent the set of all latent variables and parameters in the model and X = {x i } be a set of all observed data. The joint likelihood of X and Z is p(Z, X) = p(Z)p(X|Z). In Bayesian models, the posterior distribution p(Z|X) should be computed to make further inference. What we need to do is to approximate p(Z|X) with the distribution q(Z) that belongs to a constrained family of distributions. The goal is to make the two distributions as similar as possible. Variational inference chooses KL divergence to measure the difference between the two distributions, that is to minimize the KL divergence of q(Z) and p(Z|X). Here is the formula for the KL divergence between q and p: KL[q(Z)||p(Z|X)] = E q log q(Z) p(Z|X) = E q [log q(Z)] -E q [log p(Z|X)] = E q [log q(Z)] -E q [log p(Z, X)] + log p(X) = -ELBO(q) + const, (107) where log p(X) is replaced by a constant because we are only interested in q. With the above formula, we can know KL divergence is difficult to optimize because it requires knowing the distribution that we are trying to approximate. An alternative method is to maximize the evidence lower bound (ELBO), a lower bound on the logarithm of the marginal probability of the observations. We can obtain ELBO's formula as ELBO(q) = E [log p(Z, X)] -E [log q(Z)] . (108) Variational inference can be treated as an optimization problem with the goal of minimizing the evidence lower bound. A direct method is to solve this optimization problem using the coordinate ascent, which is called coordinate ascent variational inference (CAVI). CAVI iteratively optimizes each factor of the mean-field variational density, while holding the others fixed [192] . Specifically, variational distribution q has the structure of the mean-field, i.e., q(Z) = M i=1 q i (z i ). With this assumption, we can bring the distribution q into the ELBO, by some derivation according to [57] , and obtain the following formula: q * i ∝ exp{E -i [log p(z i , Z -i , X)]}. (109) Then the CAVI algorithm can be given below in Algorithm 8. Algorithm 8 Coordinate Ascent Variational Inference [192] Input: p(X, Z), X Output: q(Z) = M i=1 q i (z i ) Initialize Variational factors q i (z i ) repeat for i=1,2,3....,M do q * i ∝ exp{E -i [log p(z i , Z -i , X)]} end for Compute ELBO(q): ELBO(q) = E[log p(Z, X)] -E log q(Z) until ELBO converges In traditional coordinate ascension algorithms, the efficiency of processing large data is very low, because each iteration needs to compute all the data, which is very time-consuming. Modern machine learning models often need to analyze and process large-scale data, which is difficult and costly. Stochastic optimization enables machine learning to be extended on massive data [193] . This reminds us of an attractive technique to handle large data sets: stochastic optimization [97] , [192] , [194] . By introducing stochastic optimization into variational inference, the stochastic variational inference (SVI) was proposed [58] , in which the exponential family is taken as a typical example. Gaussian process (GP) is an important machine learning method based on statistical learning and Bayesian theory. It is suitable for complex regression problems such as high dimensions, small samples, and nonlinearities. GP has the advantages of strong generalization ability, flexible nonparametric inference, and strong interpretability. However, the complexity and storage requirements of accurate solution for GP are high, which hinders the development of GP under large-scale data. The stochastic variational inference method introduced in this section can popularize variational inference on large-scale datasets, but it can only be applied to probabilistic models with factorized structures. For GPs whose observations are correlated with each other, the stochastic variational inference can be adapted by introducing the global inducing variables as variational variables [195] , [196] . Specifically, the observations are assumed to be conditionally independent given the inducing variables and the variational distribution for the inducing variables is assumed to have an explicit form. Thus, the resulting GP model can be factorized in a necessary manner, enabling the stochastic variational inference. This method can also be easily extended to models with non-Gaussian likelihood or latent variable models based on GPs. E. Optimization in Markov Chain Monte Carlo Markov chain Monte Carlo (MCMC) is a class of sampling algorithms to simulate complex distributions that are difficult to sample directly. It is a practical tool for Bayesian posterior inference. The traditional and common MCMC algorithms include Gibbs sampling, slice sampling, Hamiltonian Monte Carlo (HMC) [197] , [198] , Reimann manifold variants [199] , and so on. These sampling methods are limited by the computational cost and are difficult to extend to large-scale data.This section takes HMC as an example to introduce the optimization in MCMC. The bottleneck of the HMC is that the gradient calculation is costly on large data sets. We first introduce the derivation of HMC. Consider the random variable θ, which can be sampled from the posterior distribution, p(θ|D) ∝ exp(-U (θ)), where D is the set of observations, and U is the potential energy function with the following formula: U (θ) = -log p(θ|D) = - x∈D log p(x|θ) -log p(θ). (111) In HMC [197] , an independent auxiliary momentum variable r is introduced from Hamiltonian dynamic. The Hamiltonian function and the joint distribution of θ and r are described by H(θ, r) = U (θ) + 1 2 r T M -1 r = U (θ) + K(r), (112) p (θ, r) ∝ exp(-U (θ) - 1 2 r T M -1 r), (113) where M denotes the mass matrix, and K(r) is the kinetic energy function. The process of HMC sampling is derived by simulating the Hamiltonian dynamic system, dθ = M -1 rdt, dr = -∇U (θ)dt. (114) Hamiltonian dynamic describes the continuous motion of a particle. Hamiltonian equations are numerically approximated by the discretized leapfrog integrator for practical simulating [197] . The update equations are as follows [197] :    r i (t + ǫ 2 ) = r i (t) -ǫ 2 dr(t), θ i (t + ǫ) = θ i (t) + ǫdθ(t + ǫ 2 ), r i (t + ǫ) = r i (t + ǫ 2 ) -ǫ 2 dr(t + ǫ). (115) In the case of large datasets, the gradient of U (θ) needs to be calculated on the entire data set in each leapfrog iteration. In order to improve the efficiency, the stochastic gradient method was used to calculate ∇U (θ) with a mini-batch D sampled uniformly from D, which reduces the cost of calculation [61] . However, the gradient calculated in a mini-batch instead of the full dataset will cause noise. According to the central limit theorem, this noisy gradient can be approximated as ∇ Ũ (θ) ≈ ∇U (θ) + N (0, V (θ)), (116) where gradient noise obeys normal distribution whose covariance is V (θ). If we replace ∇U (θ) by ∇ Ũ (θ) directly, the Hamiltonian dynamics will be changed as dθ = M -1 rdt, dr = -∇U (θ)dt + N (0, 2B(θ)dt), (117) where B(θ) = 1 2 ǫV (θ) is the diffusion matrix [61] . Since the discretization of the dynamical system introduces noise, the Metropolis-Hastings (MH) correction step should be done after the leapfrog step. These MH steps require expensive calculations overall data in each iteration. Beyond that, there is an incorrect stationary distribution [200] in the stochastic gradient variant of HMC. Thus, Hamiltonian dynamic was further modified, which minimizes the effect of the additional noise, achieves the invariant distribution and eliminates MH steps [61] . Specifically, a friction term is added to the dynamical process of momentum update: dθ = M -1 rdt, dr = -∇U (θ)dt -BM -1 rdt + N (0, 2B(θ)dt). (118) The introduced friction term is helpful for decreasing total energy H(θ, r) and weakening the effects of noise in the momentum update phase. The dynamical system is also the type of second-order Langevin dynamics with friction in physics, which can explore efficiently and counteract the effect of the noisy gradients [61] and thus no MH correction is required. This second-order Langevin dynamic MCMC method, called SGHMC, is used to deal with sampling problems on large data sets [61] , [201] . Moreover, HMC is highly sensitive to hyper-parameters, such as the path length (step number) L and the step size ǫ. If the hyper-parameters are not set properly, the efficiency of the HMC will drop dramatically. There are some methods to optimize these two hyper-parameters instead of manually setting them. 1) Path Length L: The value of path length L has a great influence on the performance of HMC. If L is too small, the distance between the resulting sample points will be very close; if L is too large, the resulting sample points will loop back, resulting in wasted computation. In general, manually setting L cannot maximize the sampling efficiency of the HMC. Matthew et al. [202] proposed an extension of the HMC method called the No-U-Turn sampler (NUTS), which uses a recursive algorithm to generate a set of possible independent samples efficiently, and stops the simulation by discriminating the backtracking automatically. There is no need to set the step parameter L manually. In models with multiple discrete variables, the ability of NUTS to select the track length automatically allows it to generate more valid samples and perform more efficiently than the original HMC. 2) Adaptive Step Size ǫ: The performance of HMC is highly sensitive to the step size ǫ in leapfrog integrator. If ǫ is too small, the update will slow, and the calculation cost will be high; if ǫ is too large, the rejection rate will be high, resulting in useless updates. To set ǫ reasonably and adaptively, a vanishing adaptation of the dual averaging algorithm can be used in HMC [203] , [204] . Specifically, a statistic H t = δα t is adopted in dual averaging method, where δ is the desired average acceptance probability, and α t is the current Metropolis-Hasting acceptance probability for iteration t. The statistic H t 's expectation h(ǫ) is defined as h(ǫ) ≡ E t [H t |ǫ t ] ≡ lim T →∞ 1 T E[H t |ǫ t ], (119) where ǫ t is the step size for iteration t in the leapfrog integrator. To satisfy h(ǫ) ≡ E t [H t |ǫ t ] = 0, we can derive the update formula of ǫ, i.e., ǫ t+1 = ǫ tη t H t . Tuning ǫ by vanishing adaptation algorithm guarantees that the average acceptance probability of Metropolis verges to a fixed value. The hyper-parameters in the HMC include not only the step size ǫ and the length of iteration steps L, but also the mass M , etc. Optimizing these hyper-parameters can help improve sampling performance [199] , [205] , [206] . It is convenient and efficient to tune the hyper-parameters automatically without cumbersome adjustments based on data and variables in MCMC. These adaptive tuning methods can be applied to other MCMC algorithms to improve the performance of the samplers. In addition to second-order SGHMC, stochastic gradient Langevin dynamics (SGLD) [207] is a first-order Langevin dynamic technique combined with stochastic optimization. Efficient variants of both SGLD and SGHMC are still active [201] , [208] . V. CHALLENGES AND OPEN PROBLEMS With the rise of practical demand and the increase of the complexity of machine learning models, the optimization methods in machine learning still face challenges. In this part, we discuss open problems and challenges for some optimization methods in machine learning, which may offer suggestions or ideas for future research and promote the wider application of optimization methods in machine learning. A. Challenges in Deep Neural Networks There are still many challenges while optimizing DNNs. Here we mainly discuss two challenges with respect to data and model, respectively. One is insufficient data in training, and the other is a non-convex objective in DNNs. 1) Insufficient Data in Training Deep Neural Networks: In general, deep learning is based on big data sets and complex models. It requires a large number of training samples to achieve good training effects. But in some particular fields, finding a sufficient amount of training data is difficult. If we do not have enough data to estimate the parameters in the neural networks, it may lead to high variance and overfitting. There are some techniques in neural networks that can be used to reduce the variance. Adding L 2 regularization to the objective is a natural method to reduce the model complexity. Recently, a common method is dropout [62] . In the training process, each neuron is allowed to stop working with a probability of p, which can prevent the synergy between certain neurons. M subnets can be sampled like bagging by multiple puts and returns [209] . Each expected result at the output layer is calculated as o = E M [f (x; θ, M )] = M i=1 p(M i )f (x; θ, M i ), (120) where p(M i ) is the probability of the ith subnet. Dropout can prevent overfitting and improve the generalization ability of the network, but its disadvantage is increasing the training time as each training changes from the full network to a sub-network [210] . Not only overfitting but also some training details will affect the performance of the model due to the complexity of the DNNs. The improper selection of the learning rate and the number of iterations in the SGD will make the model unable to converge, which makes the accuracy of model fluctuate greatly. Besides, taking an inappropriate black box of neural network construction may result in training not being able to continue, so designing an appropriate neural network model is particularly important. These impacts are even greater when data are insufficient. The technology of transfer learning [211] can be applied to build networks in the scenario of insufficient data. Its idea is that the models trained from other data sources can be reused in similar target fields after certain modifications and improvements, which dramatically alleviates the problems caused by insufficient datasets. Moreover, the advantages brought by transfer learning are not limited to reducing the need for sufficient training data, but also can avoid overfitting effectively and achieve better performance in general. However, if target data is not as relevant to the original training data, the transferred model does not bring good performance. Meta learning methods can be used for systematically learning parameter initialization, which ensures that training begins with a suitable initial model. However, it is necessary to ensure the correlation between multiple tasks for meta-training and tasks for meta-testing. Under the premise of models with similar data sources for training, transfer learning and meta learning can overcome the difficulties caused by insufficient training data in new data sources, but these methods usually introduce a large number of parameters or complex parameter adjustment mechanisms, which need to be further improved for specific problems. Therefore, using insufficient data for training DNNs is still a challenge. 2) Non-convex Optimization in Deep Neural Network: Convex optimization has good properties and a comprehensive set of tools are open to solve the optimization problem. However, many machine learning problems are formulated as non-convex optimization problems. For example, almost all the optimization problems in DNNs are non-convex. Non-convex optimization is one of the difficulties in the optimization problem. Unlike convex optimization, there may be innumerable optimum solutions in its feasible domain in non-convex problems. The complexity of the algorithm for searching the global optimal value is NP-hard [109] . In recent years, non-convex optimization has gradually attracted the attention of researches. The methods for solving non-convex optimization problems can be roughly divided into two types. One is to transform the non-convex optimization into a convex optimization problem, and then use the convex optimization method. The other is to use some special optimization method for solving non-convex functions directly. There is some work on summarizing the optimization methods for solving non-convex functions from the perspective of machine learning [212] . 1) Relaxation method: Relax the problem to make it become a convex optimization problem. There are many relaxation techniques, for example, the branch-andbound method called αBB convex relaxation [213] , [214] , which uses a convex relaxation at each step to compute the lower bound in the region. The convex relaxation method has been used in many fields. In the field of computer vision, a convex relaxation method was proposed to calculate minimal partitions [215] . For unsupervised and semi-supervised learning, the convex relaxation method was used for solving semidefinite programming [216] . 2) Non-convex optimization methods: These methods include projection gradient descent [217] , [218] , alternating minimization [219] , [220] , [221] , expectation maximization algorithm [222] , [223] and stochastic optimization and its variants [37] . B. Difficulties in Sequential Models with Large-Scale Data When dealing with large-scale time series, the usual solutions are using stochastic optimization, processing data in mini-batches, or utilizing distributed computing to improve computational efficiency [224] . For a sequential model, segmenting the sequences can affect the dependencies between the data on the adjacent time indices. If sequence length is not an integral multiple of the mini-batch size, the general operation is to add some items sampled from the previous data into the last subsequence. This operation will introduce the wrong dependency in the training model. Therefore, the analysis of the difference between the approximated solution obtained and the exact solution is a direction worth exploring. Particularly, in RNNs, the problem of gradient vanishing and gradient explosion is also prone to occur. So far, it is generally solved by specific interaction modes of LSTM and GRU [225] or gradient clipping. Better appropriate solutions for dealing with problems in RNNs are still worth investigating. C. High-Order Methods for Stochastic Variational Inference The high-order optimization method utilizes curvature information and thus converges fast. Although computing and storing the Hessian matrices are difficult, with the development of research, the calculation of the Hessian matrix has made great progress [8] , [9] , [226] , and the second-order optimization method has become more and more attractive. Recently, stochastic methods have also been introduced into the second-order method, which extends the second order method to large-scale data [8] , [10] . We have introduced some work on stochastic variational inference. It introduces the stochastic method into variational inference, which is an interesting and meaningful combination. This makes variational inference be able to handle large-scale data. A natural idea is whether we can incorporate secondorder optimization methods (or higher-order) into stochastic variational inference, which is interesting and challenging. D. Stochastic Optimization in Conjugate Gradient Stochastic methods exhibit powerful capabilities when dealing with large-scale data, especially for first-order optimization [227] . Then the relevant experts and scholars also introduced this stochastic idea to the second-order optimization methods [124] , [125] , [228] and achieved good results. Conjugate gradient method is an elegant and attractive algorithm, which has the advantages of both the firstorder and second-order optimization methods. The standard form of a conjugate gradient is not suitable for a stochastic approximation. Through using the fast Hessiangradient product, the stochastic method is also introduced to conjugate gradient, in which some numerical results show the validity of the algorithm [227] . Another version of stochastic conjugate gradient method employs the variance reduction technique, and converges quickly with just a few iterations and requires less storage space during the running process [229] . The stochastic version of conjugate gradient is a potential optimization method and is still worth studying. VI. CONCLUSION This paper introduces and summarizes the frequently used optimization methods from the perspective of machine learning, and studies their applications in various fields of machine learning. Firstly, we describe the theoretical basis of optimization methods from the first-order, high-order, and derivative-free aspects, as well as the research progress in recent years. Then we describe the applications of the optimization methods in different machine learning scenarios and the approaches to improve their performance. Finally, we discuss some challenges and open problems in machine learning optimization methods. where Con x = Ax + By tb and Con y = Ax t+1 + Byb. For task τ , train and update the optimizer parameter θ with the training samples D train τ , update the meta-optimizer parameter φ with the test samples D test τ ."
}