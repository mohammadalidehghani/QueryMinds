{
  "title": "Learning Moore Machines from Input-Output Traces",
  "abstract": "The problem of learning automata from example traces (but no equivalence or membership queries) is fundamental in automata learning theory and practice. In this paper we study this problem for finite state machines with inputs and outputs, and in particular for Moore machines. We develop three algorithms for solving this problem: (1) the PTAP algorithm, which transforms a set of input-output traces into an incomplete Moore machine and then completes the machine with self-loops; (2) the PRPNI algorithm, which uses the well-known RPNI algorithm for automata learning to learn a product of automata encoding a Moore machine; and (3) the MooreMI algorithm, which directly learns a Moore machine using PTAP extended with state merging. We prove that MooreMI has the fundamental identification in the limit property. We also compare the algorithms experimentally in terms of the size of the learned machine and several notions of accuracy, introduced in this paper. Finally, we compare with OSTIA, an algorithm that learns a more general class of transducers, and find that OSTIA generally does not learn a Moore machine, even when fed with a characteristic sample.",
  "introduction": "Introduction An abundance of data from the internet and from other sources (e.g., sensors) is revolutionizing many sectors of science, technology, and ultimately our society. At the heart of this revolution lies machine learning, a broad spectrum of techniques to derive information from data. Traditionally, objects studied by machine learning include classifiers, decision trees, and neural networks, with applications to fields as diverse as artificial intelligence, marketing, finance, or medicine [38] . In the context of system design, an important problem, with numerous applications, is automatically generating models from data. There are many variants of this problem, depending on what types of models and data are considered, as well as other assumptions or restrictions. Examples include, but are by no means limited to, the classic field of system identification [35] , as well as more recent works on synthesizing programs, controllers, or other artifacts from examples [44, 21, 42, 41, 5] . In this paper we consider a basic problem, that of learning a Moore machine from a set of input-output traces. A Moore machine is a type of finite-state machine (FSM) with inputs and outputs, where the output always depends on the current state, but not on the current input [30] . Moore machines are typically deterministic and complete, meaning that for given state and input, the next state is always defined and is unique; and for given state, the output is also always uniquely defined. Such machines are useful in many applications, for instance, for representing digital circuits or controllers. In this paper we are interested in learning deterministic and complete Moore machines. We want to learn a Moore machine from a given set of input-output traces. One such trace is a sequence of inputs, ρ in , and the corresponding sequence of outputs, ρ out , that the machine must produce when fed with ρ in . As in standard machine learning methods, we call the set of traces given to the learning algorithm the training set. Obviously, we would like the learned machine M to be consistent w.r.t. the training set R, meaning that for every pair (ρ in , ρ out ) ∈ R, M must output ρ out when fed with ρ in . But in addition to consistency, we would like M to behave well w.r.t. several performance criteria, including complexity of the learning algorithm, size of the learned machine M (its number of states), and accuracy of M , which captures how well M performs on a testing set of traces, different from the training set. Even though this is a basic problem, it appears not to have received much attention in the literature. In fact, to the best of our knowledge, this is the first paper which formalizes and studies this problem. This is despite a large body of All algorithms developed in this paper belong in the heuristic category in the sense that we do not attempt to find a smallest machine. However, we would still like to learn a small machine. Thus, size is an important performance criterion, as explained in Section 5.1. Like RPNI and other algorithms, MooreMI is also a state-merging algorithm. [46] is close to our work, but the algorithm described there does not always yield a deterministic Moore machine, while our algorithms do. This is important because we want to learn systems like digital circuits, embedded controllers (e.g. modeled in Simulink), etc., and such systems are typically deterministic. The k-tails algorithm for finite state machine inference [9] may also result in non-deterministic machines. Moreover, this algorithm does not generally yield smallest machines, since the initial partition of the input words into equivalence classes (which then become the states of the learned machine) can be overly conservative . 4 The work in [29] deals with learning finite state machine abstractions of non-linear analog circuits. The algorithm described in [29] is very different from ours, and uses the circuit's number of inputs to determine a subset of the states in the learned abstraction. Also, identification in the limit is not considered in [29] . Learning from \"inexperienced teachers\", i.e. by using either (1) only equivalence queries or (2) equivalence plus membership queries that may be answered inconclusively, has been studied in [20, 34] . Related but different from our work are approaches which synthesize state machines from scenarios and requirements. Scenarios can be provided in various forms, e.g. message sequence charts [5] , event sequence charts [24] , or simply, input-output examples [47] . Requirements can be temporal logic formulas as in [5, 47] , or other types of constraints such as the scenario constraints used in [24] . In this paper we have examples, but no requirements. Also related but different from ours is work in the areas of invariant generation and specification mining, which extract properties of a program or system model, such as invariants [22, 13, 23] , temporal logic formulas [27, 33] or non-deterministic finite automata [6] . FSM learning is related to FSM testing [32] . In particular, notions similar to the nucleus of an FSM and to distinguishing suffixes of states, which are used to define characteristic samples, are also used in [12, 16] . The connection between conformance testing and regular inference is made explicit in [8] and [32] describes how an active learning algorithm can be used for fault detection. Reviewers of an earlier version of this paper pointed out the similarity of Moore and Mealy machines: a Moore machine is a special case of a Mealy machine where the output depends only on the state but not on the input; and a Mealy machine can be transformed into a Moore machine by delaying the output by one step. This similarity naturally raises the question to what extent methods to learn Mealy machines can be used to learn Moore machines (and vice versa). Answering this question is beyond the scope of the current paper. However, note that an algorithm that learns a Mealy machine cannot be used as a black box to learn Moore machines, for two reasons: first, the input-output traces for a Moore machine are not directly compatible with Mealy machines, and therefore need to be transformed somehow; second, the learned Mealy machine must also be transformed into a Moore machine. The exact form of such transformations and their correctness remain to be demonstrated. Such transformations may also incur performance penalties which make a learning method especially designed for Moore machines more attractive in practice.",
  "body": "Introduction An abundance of data from the internet and from other sources (e.g., sensors) is revolutionizing many sectors of science, technology, and ultimately our society. At the heart of this revolution lies machine learning, a broad spectrum of techniques to derive information from data. Traditionally, objects studied by machine learning include classifiers, decision trees, and neural networks, with applications to fields as diverse as artificial intelligence, marketing, finance, or medicine [38] . In the context of system design, an important problem, with numerous applications, is automatically generating models from data. There are many variants of this problem, depending on what types of models and data are considered, as well as other assumptions or restrictions. Examples include, but are by no means limited to, the classic field of system identification [35] , as well as more recent works on synthesizing programs, controllers, or other artifacts from examples [44, 21, 42, 41, 5] . In this paper we consider a basic problem, that of learning a Moore machine from a set of input-output traces. A Moore machine is a type of finite-state machine (FSM) with inputs and outputs, where the output always depends on the current state, but not on the current input [30] . Moore machines are typically deterministic and complete, meaning that for given state and input, the next state is always defined and is unique; and for given state, the output is also always uniquely defined. Such machines are useful in many applications, for instance, for representing digital circuits or controllers. In this paper we are interested in learning deterministic and complete Moore machines. We want to learn a Moore machine from a given set of input-output traces. One such trace is a sequence of inputs, ρ in , and the corresponding sequence of outputs, ρ out , that the machine must produce when fed with ρ in . As in standard machine learning methods, we call the set of traces given to the learning algorithm the training set. Obviously, we would like the learned machine M to be consistent w.r.t. the training set R, meaning that for every pair (ρ in , ρ out ) ∈ R, M must output ρ out when fed with ρ in . But in addition to consistency, we would like M to behave well w.r.t. several performance criteria, including complexity of the learning algorithm, size of the learned machine M (its number of states), and accuracy of M , which captures how well M performs on a testing set of traces, different from the training set. Even though this is a basic problem, it appears not to have received much attention in the literature. In fact, to the best of our knowledge, this is the first paper which formalizes and studies this problem. This is despite a large body of All algorithms developed in this paper belong in the heuristic category in the sense that we do not attempt to find a smallest machine. However, we would still like to learn a small machine. Thus, size is an important performance criterion, as explained in Section 5.1. Like RPNI and other algorithms, MooreMI is also a state-merging algorithm. [46] is close to our work, but the algorithm described there does not always yield a deterministic Moore machine, while our algorithms do. This is important because we want to learn systems like digital circuits, embedded controllers (e.g. modeled in Simulink), etc., and such systems are typically deterministic. The k-tails algorithm for finite state machine inference [9] may also result in non-deterministic machines. Moreover, this algorithm does not generally yield smallest machines, since the initial partition of the input words into equivalence classes (which then become the states of the learned machine) can be overly conservative . 4 The work in [29] deals with learning finite state machine abstractions of non-linear analog circuits. The algorithm described in [29] is very different from ours, and uses the circuit's number of inputs to determine a subset of the states in the learned abstraction. Also, identification in the limit is not considered in [29] . Learning from \"inexperienced teachers\", i.e. by using either (1) only equivalence queries or (2) equivalence plus membership queries that may be answered inconclusively, has been studied in [20, 34] . Related but different from our work are approaches which synthesize state machines from scenarios and requirements. Scenarios can be provided in various forms, e.g. message sequence charts [5] , event sequence charts [24] , or simply, input-output examples [47] . Requirements can be temporal logic formulas as in [5, 47] , or other types of constraints such as the scenario constraints used in [24] . In this paper we have examples, but no requirements. Also related but different from ours is work in the areas of invariant generation and specification mining, which extract properties of a program or system model, such as invariants [22, 13, 23] , temporal logic formulas [27, 33] or non-deterministic finite automata [6] . FSM learning is related to FSM testing [32] . In particular, notions similar to the nucleus of an FSM and to distinguishing suffixes of states, which are used to define characteristic samples, are also used in [12, 16] . The connection between conformance testing and regular inference is made explicit in [8] and [32] describes how an active learning algorithm can be used for fault detection. Reviewers of an earlier version of this paper pointed out the similarity of Moore and Mealy machines: a Moore machine is a special case of a Mealy machine where the output depends only on the state but not on the input; and a Mealy machine can be transformed into a Moore machine by delaying the output by one step. This similarity naturally raises the question to what extent methods to learn Mealy machines can be used to learn Moore machines (and vice versa). Answering this question is beyond the scope of the current paper. However, note that an algorithm that learns a Mealy machine cannot be used as a black box to learn Moore machines, for two reasons: first, the input-output traces for a Moore machine are not directly compatible with Mealy machines, and therefore need to be transformed somehow; second, the learned Mealy machine must also be transformed into a Moore machine. The exact form of such transformations and their correctness remain to be demonstrated. Such transformations may also incur performance penalties which make a learning method especially designed for Moore machines more attractive in practice. Preliminaries Finite state machines and automata A finite state machine (FSM) is a tuple M of the form M = (I, O, Q, q 0 , δ, λ), where:  - -I is a finite set of input symbols. -O is a finite set of output symbols. -Q is a finite set of states. -q 0 ∈ Q is the initial state. q 0 y 1 x 1 q 1 y 2 x 2 x 2 x 1 (a) Moore machine M1 on input-output sets I = {x1, x2} and O = {y1, y2}. q 0 q 1 x 1 /y 1 x 2 /y 1 x 2 /y 2 x 1 /y 2 ( δ : Q × I → Q is the transition function. λ is the output function, which can be of two types: • λ : Q → O, in which case the FSM is a Moore machine. • λ : Q × I → O, in which case the FSM is a Mealy machine. If both δ and λ are total functions, we say that the FSM is complete. If any of δ and λ is a partial function, we say that the FSM is incomplete. Examples of a Moore and a Mealy machine are given in Figure 1 . Both FSMs are complete. We also define δ * : Q × I * → Q as follows (X * denotes the set of all finite sequences over some set X; ∈ X * denotes the empty sequence over X; w • w denotes the concatenation of two sequences w, w ∈ X * ): for q ∈ Q, w ∈ I * , and a ∈ I: -δ * (q, ) = q. -δ * (q, w • a) = δ(δ * (q, w), a). We also define λ * : Q × I * → O * . The rest of this paper focuses on Moore machines, thus we define λ * only in the case where M is a Moore machine (the adaptation to a Mealy machine is straightforward): -λ * (q, ) = λ(q) -λ * (q, w • a) = λ * (q, w) • λ(δ * (q, w • a)) Two Moore machines M 1 , M 2 , with M i = (I i , O i , Q i , q 0 i , δ i , λ i ), are said to be equivalent iff I 1 = I 2 , O 1 = O 2 , and ∀w ∈ I * 1 : λ * 1 (q 0 1 , w) = λ * 2 (q 0 2 , w). A Moore machine M = (I, O, Q, q 0 , δ, λ) is minimal if for any other Moore machine M = (I , O , Q , q 0 , δ , λ ) such that M and M are equivalent, we have |Q| ≤ |Q |, where |X| denotes the size of a set X. Notice that in the case two Moore machines are minimal, testing equivalence is reduced to a graph isomorphism test. A deterministic finite automaton (DFA) is a tuple A = (Σ, Q, q 0 , δ, F ), where: -Σ (the alphabet) is a finite set of letters. -Q is a finite set of states. q 0 ∈ S is the initial state. - δ : Q × Σ → Q is the transition function. -F ⊆ Q is the set of accepting states. A DFA can be seen as a special case of a Moore machine, where the set of input symbols I is Σ, and the set of output symbols is binary, say O = {0, 1}, with 1 and 0 corresponding to accepting and non-accepting states, respectively. The concepts of complete and incomplete DFAs, as well as the definition of δ * , are similar to the corresponding ones for FSMs. Elements of Σ * are usually called words. A DFA A = (Σ, Q, q 0 , δ, F ) is said to accept a word w if δ * (q 0 , w) ∈ F . A non-deterministic finite automaton (NFA) is a tuple A = (Σ, Q, Q 0 , ∆, F ), where Σ, Q, and F are as in a DFA, and: - q 0 q 1 b a, b a (a) DFA A1 on Σ = {a, b}. q 0 q 1 a b a (b) NFA A2 on Σ = {a, b}. Q 0 ⊆ Q is the set of initial states. -∆ ⊆ Q × Σ × Q is the transition relation. Examples of a DFA and an NFA are given in Figure 2 . Accepting states are drawn with double circles. Given two NFAs, A 1 = (Σ, Q 1 , Q 1 0 , ∆ 1 , F 1 ) and A 2 = (Σ, Q 2 , Q 2 0 , ∆ 2 , F 2 ), their synchronous product is the NFA A = (Σ, Q 1 × Q 2 , Q 1 0 × Q 2 0 , ∆, F 1 × F 2 ) , where ((q 1 , q 2 ), a, (q 1 , q 2 )) ∈ ∆ iff (q 1 , a, q 1 ) ∈ ∆ 1 and (q 2 , a, q 2 ) ∈ ∆ 2 . The synchronous product of automata is used in several algorithms presented in the sequel. Input-output traces and examples Given sets of input and output symbols I and O, respectively, a Moore (I, O)-trace is a pair of finite sequences (x 1 x 2 • • • x n , y 0 y 1 • • • y n ), for some natural number n ≥ 0, such that x i ∈ I and y i ∈ O for all i ≤ n. That is, a Moore (I, O)-trace is a pair of a input sequence and an output sequence, such that the output sequence has length one more than the input sequence. Note that n may be 0, in which case the input sequence is empty (i.e., has length 0), and the output sequence contains just one output symbol. Given a Moore (I, O)-trace ρ = (x 1 x 2 • • • x n , y 0 y 1 • • • y n ) , and a Moore machine M = (I, O, Q, q 0 , δ, λ), we say that ρ is consistent with M if y 0 = λ(q 0 ) and for all i = 1, ..., n, y i = λ(q i ), where q i = δ(q i-1 , x i ). Similarly to the concept of a Moore (I, O)-trace we define a Moore (I, O)-example as a pair of a finite input symbol sequence and an output symbol: (x 1 x 2 • • • x n , y), where x i ∈ I, for i = 1, ..., n, and y ∈ O. We say that a Moore machine M = (I, O, Q, q 0 , δ, λ) is consistent with a Moore (I, O)-example ρ = (x 1 x 2 • • • x n , y) if λ(δ * (q 0 , x 1 x 2 • • • x n )) = y. Since a DFA can be seen as the special case of a Moore machine with a binary output alphabet, the concept of a Moore (I, O)-example is naturally carried over to DFAs, in the form of positive and negative examples. Specifically, a finite word w is a positive example for a DFA if it is accepted by the DFA, and a negative example if it is rejected. Viewing a DFA as a Moore machine with binary output, a positive example w corresponds to the Moore example (w, 1), while a negative example corresponds to the Moore example (w, 0). Prefix tree acceptors and prefix tree acceptor products q ab q aa q a q b q a a b b Fig. 3 : A PTA for S + = {b, aa, ab}. Given a finite and non-empty set of positive examples over a given alphabet Σ, S + ⊆ Σ * , we can construct, in a non-unique way, a tree-shaped, incomplete DFA, that accepts all words in S + , and rejects all others. Such a DFA is called a prefix tree acceptor [15] (PTA) for S + . For example, a PTA for S + = {b, aa, ab} is shown in Figure 3 . We extend the concept of PTA to Moore machines. Suppose that we have a set S IO of Moore (I, O)-examples. Let N = log 2 |O| be the number of bits necessary to represent an element of O. Then, given a function f that maps elements of O to bit tuples of length N , we can map S IO to N pairs of positive and negative example sets, {(S 1+ , S 1-), (S 2+ , S 2-), • • •, (S N + , S N -)}. In particular, for each pair (w, y) ∈ S IO , if the i-th element of f (y) is 1, then S i+ should contain w and S i-should not. Similarly, if the i-th element of f (y) is 0, then S i-should contain w and S i+ should not. q ab q aa q a q a a b (a) The PTA for S1+ = {ab}. q ab q aa q a q a a b (b) The PTA for S2+ = {aa}. Fig. 4 : A PTAP for S IO = {(b, 0), (aa, 1), (ab, 2)}, with I = {a, b}, O = {0, 1, 2}, and f = {0 → (0, 0), 1 → (0, 1), 2 → (1, 0)}. The positive and negative example sets are: S 1+ = {ab}, S 1-= {b, aa}, S 2+ = {aa}, S 2-= {b, ab}. We can subsequently construct a prefix tree acceptor product (PTAP), which is a collection of N PTAs, one for each positive example set, S i+ , for i = 1, • • • , N . An example of a PTAP consisting of two PTAs is given in Figure 4 . Characteristic samples An important concept in automata learning theory is that of a characteristic sample [15] . A characteristic sample for a DFA is a set of words that captures all information about that automaton's set of states and behavior. In this paper we extend the concept of characteristic sample to Moore machines. Characteristic samples for Moore machines Let M = (I, O, Q, q 0 , δ, λ) be a minimal Moore machine. Let < denote a total order on input words, i.e., on I * , such that w < w iff either |w| < |w |, or |w| = |w | but w comes before w in lexicographic order (|w| denotes the length of a word w). For example, b < aa and aaa < aba. Given a state q ∈ Q, we define the shortest prefix of q as the shortest input word which can be used to reach q: S P (q) = min < {w ∈ I * | δ * (q 0 , w) = q}. Notice that M is minimal, which implies that all its states are reachable (otherwise we could remove unreachable states). Therefore, S P (q) is well-defined for every state q of M . Next, we define the set of shortest prefixes of M , denoted S P (M ), as: S P (M ) = {S P (q) | q ∈ Q} We can now define the nucleus of M which contains the empty word and all one-letter extensions of words in S P (M ): N L (M ) = { } ∪ {w • a | w ∈ S P (M ), a ∈ I}. We also define the minimum distinguishing suffix for two different states q u and q v of M , as follows: M D (q u , q v ) = min < {w ∈ I * | λ * (q u , w) = λ * (q v , w)}. M D (q u , q v ) is guaranteed to exist for any two states q u , q v because M is minimal. Let W be a set of input words, W ⊆ I * . P ref (W ) denotes the set of all prefixes of all words in W : P ref (W ) = {x ∈ I * | ∃w ∈ W, y ∈ I * : x • y = w}. Definition 1. Let S IO be a set of Moore (I,O)-traces, and let S I be the corresponding set of input words: S I = {ρ I ∈ I * | (ρ I , ρ O ) ∈ S IO }. S IO is a characteristic sample for a Moore machine M iff: q 0 q 3 q 1 q 2 0 1 2 2 a 1. N L (M ) ⊆ P ref (S I ). 2. ∀u ∈ S P (M ) : ∀v ∈ N L (M ) : ∀w ∈ I * : δ * (q 0 , u) = δ * (q 0 , v) ∧ w = M D (δ * (q 0 , u), δ * (q 0 , v)) ⇒ {u • w, v • w} ⊆ P ref (S I ). For example, consider the Moore machine M 1 from Figure 1 . We have: S P (q 0 ) = , S P (q 1 ) = x 2 , S P (M 1 ) = { , x 2 }, and N L (M 1 ) = { , x 1 , x 2 , x 2 x 1 , x 2 x 2 }. The following set is a characteristic sample for M 1 : S IO = { (x 1 , y 1 y 1 ), (x 2 x 1 , y 1 y 2 y 1 ), (x 2 x 2 , y 1 y 2 y 2 ) }. While it is intuitive that a characteristic sample should contain input words that in a sense cover all states and transitions of M (Condition 1 of Definition 1), it may not be obvious why Condition 2 of Definition 1 is necessary. This becomes clear if we look at machines having the same output on several states. For example, consider the Moore machine M in Figure 5a . The set of (I, O)-traces S 1 IO = {(aa, 020), (ba, 012), (bb, 012), (aba, 0222), (abb, 0222)} satisfies Condition 1 but not Condition 2 (because S P (q 2 ) = a, ba ∈ N L (M ), δ * (q 0 , ba) = q 3 , M D (q 2 , q 3 ) = a, but no input word in S 1 IO has baa as a prefix), and therefore is not a characteristic sample of the machine of Figure 5a . If we use S 1 IO to learn a Moore machine, we obtain the machine in Figure 5b (this machine was produced by our MooreMI algorithm, described in Section 5.2). Clearly, the two machines of Figure 5 are not equivalent. For instance, the input word baa results in different outputs when fed to the two machines. The reason why the learning algorithm produces the wrong machine is that the set S 1 IO does not contain enough information to clearly distinguish between states q 2 and q 3 . Instead, consider the set S 2 IO = {(aa, 020), (baa, 0122), (bba, 0122), (abaa, 02220), (abba, 02220)}. S 2 IO satisfies both Conditions 1 and 2, and therefore is a characteristic sample. Given S 2 IO as input, our MooreMI algorithm is able to learn the correct machine, i.e., the machine of Figure 5a . In this case, the minimum distinguishing suffix of states q 2 and q 3 is simply the letter a, since δ(q 2 , a) = q 0 , δ(q 3 , a) = q 2 and λ(q 0 ) = 0 = 2 = λ(q 2 ). Notice that S 2 IO can be constructed from S 1  IO by extending with the letter a the input words of the latter that land on q 2 or q 3 . The intuition, then, behind Condition 2 is that states in M that have the same outputs cannot be distinguished by just those (outputs); additional suffixes that differentiate them are required. Computation, minimality, size, and other properties of characteristic samples It is easy to see that adding more traces to a characteristic sample preserves the characteristic sample property, i.e., if S IO is a characteristic sample for a Moore machine M and S IO ⊇ S IO , then S IO is also a characteristic sample for M . Also, arbitrarily extending the input word of an existing (I, O)-trace in S IO and accordingly extending the corresponding output word, again yields a new characteristic sample for M . The questions are raised, then, whether there exist characteristic samples that are minimal in some sense, how many elements they consist of, what are the lengths of their elements, and how can we construct them. In the following, we outline a simple procedure that, given a minimal Moore machine M , returns a characteristic sample S IO that is minimal in the sense that removing any (I, O)-trace from it or dropping any number of letters at the end of an input word in it (and accordingly adjusting the corresponding output word) will result in a set that is not a characteristic sample. By doing so, we also constructively establish the existence of at least one characteristic sample for any minimal Moore machine M . Let M = (I, O, Q, q 0 , δ, λ) be a minimal Moore machine, S I an initially empty set of input words and S IO the set of (I, O)-traces formed by the elements of S I and the corresponding output words. We compute S P (M ) and N L (M ), and add the elements of the latter to S I . Then, for each pair of words (u, v) ∈ S P (M ) × N L (M ) leading to different states q u = δ * (q 0 , u), q v = δ * (q 0 , v), we compute M D (q u , q v ) and add it to S I . Now, S IO already is a characteristic sample. However, it may contain redundant elements that can safely be removed. We can do this by simply considering each element of S I and removing it if it is a prefix of another element (this step can be sped up by choosing an appropriate data structure to represent S I , e.g. using a trie, we would simply just keep the words represented by the leaf nodes). Note that since the prefix relation on words is a partial order, and therefore transitive, the order in which we remove the redundant elements does not affect the final result. It is easy to see now that, after this step, (1) no element of S I is the prefix of another, (2) S IO is still a characteristic sample, and (3) removing any element from S I or dropping any number of letters at the and of it, will result in S IO not being a characteristic sample. By definition, there is a 1 -1 correspondence between the elements of S P (M ) and the states of M . Therefore, |S P (M )| = |Q|. It follows that |N L (M )| ≤ |S P (M )| • |I| + 1 = |Q| • |I| + 1 and, consequently, |S IO | = |S I | ≤ |N L (M )| + |S P (M )| • |N L (M )| = (|Q| • |I| + 1) • (|Q| + 1). In other words, the size of S IO is O(|Q| 2 |I|). We now provide bounds on the lengths of the elements of S IO . The lengths of shortest prefixes are bounded by the longest non-looping path in M , which in turn is bounded by |Q|. It follows that the nucleus element lengths are bounded by |Q| + 1. Let now q u and q v be different states of M and consider M 1 = (I, O, Q, q u , δ, λ) and M 2 = (I, O, Q, q v , δ, λ), i.e. M 1 and M 2 have q u and q v as initial states, respectively, but are otherwise identical to M . Finding a (minimum) distinguishing suffix of q u and q v is now reduced to finding a (minimum) input word that leads to different output words when transduced by M 1 and M 2 . To find such a word, we first construct a DFA A = (I, Q × Q, (q u , q v ), δ A , F ), where ∀(q 1 , q 2 ) ∈ Q × Q : ∀a ∈ I : δ A ((q 1 , q 2 ), a) = (δ(q 1 , a), δ(q 2 , a)) and F = {(q 1 , q 2 ) ∈ Q × Q | λ(q 1 ) = λ(q 2 )}. A word accepted by this DFA is a distinguishing suffix of q u and q v , and it is easy to see that we only need to test words of length up to |Q × Q| in order to find one. We can conclude from the above that the sum of lengths of elements in S IO is O(|Q| 4 |I|). 5 Learning Moore machines from Input-Output Traces Problem definition The problem of learning Moore machines from input-output traces (LMoMIO) is defined as follows. Given an input alphabet I, an output alphabet O, and a set R train of Moore (I, O)-traces, called the training set, we want to synthesize automatically a deterministic, complete Moore machine M = (I, O, Q, q 0 , δ, λ), such that M is consistent with R train , i.e., ∀ (ρ I , ρ O ) ∈ R train : λ * (ρ I ) = ρ O . (R train is assumed to be itself consistent, in the sense it does not contain two different pairs with the same input word.) In addition to consistency, we would like to evaluate our learning technique w.r.t. various performance criteria, including: -Size of M , in terms of number of states. Note that, contrary to the exact identification problem [19] , we do not require M to be the smallest (in terms of number of states) machine consistent with R train . -Accuracy of M , which, informally speaking, is a measure of how well M performs on a set of traces, R test , different from the training set. R test is called the test set. Accuracy is a standard criterion in machine learning. -Complexity (e.g., running time) of the learning algorithm itself. In the rest of this paper, we present three learning algorithms which solve the LMoMIO problem, and evaluate them w.r.t. the above criteria. Complexity of the algorithm and size of the learned machine are standard notions. Accuracy is standard in machine learning topics such as classification, but not in automata learning. Thus, we elaborate on this concept next. There are more than one ways to measure the accuracy of a learned Moore machine M against a test set R test . We call an accuracy evaluation policy (AEP) any function that, given a Moore (I, O)-trace (ρ I , ρ O ) and a Moore machine M = (I, O, Q, q 0 , δ, λ), will return a real number in [0, 1]. We will call that number the accuracy of M on (ρ I , ρ O ). In this paper, we use three AEPs which we call strong, medium, and weak, defined below. Let (ρ I , ρ O ) = (x 1 x 2 • • • x n , y 0 y 1 • • • y n ) and z 0 z 1 • • • z n = λ * (q 0 , ρ I ). -Strong: if λ * (q 0 , ρ I ) = ρ O then 1 else 0. -Medium: 1 n+1 • |{i | y 0 y 1 • • • y i = z 0 z 1 • • • z i }|. -Weak: 1 n+1 • |{i | y i = z i }|. The strong AEP says that the output of the learned machine M must be identical to the output in the test set. The medium AEP returns the proportion of the largest output prefix that matches. The weak AEP returns the number of output symbols that match. For example, if the correct output is 0012 and M returns 0022 then the strong accuracy is 0, the medium accuracy is 2  4 , and the weak accuracy is 3  4 . Ideally, we want the learned machine to achieve a high accuracy with respect to the strong AEP. However, the medium and weak AEPs are also useful, because they allow to distinguish, say, a machine which is \"almost right\" (i.e., outputs the right sequence except for a few symbols) from a machine which is always or almost always wrong. Given an accuracy evaluation policy f and a test set R test , we define the accuracy of M on R test as the averaged accuracy of M over all traces in R test , i.e., (ρ I ,ρ O )∈Rtest f ((ρ I , ρ O ), M ) |R test | . It is often the case that the test set R test contains traces generated by a \"black box\", for which we are trying to learn a model. Suppose this black box corresponds to an unknown machine M ? . Then, ideally, we would like the learned machine M to be equivalent to M ? . In that case, no matter what test set is generated by M ? , the learned machine M will always achieve 100% accuracy. Of course, achieving this ideal depends on the training set: if the latter is \"poor\" then it does not contain enough information to identify the original machine M ? . A standard requirement in automata learning theory states that when the training set is a characteristic sample of M ? , then the learning algorithm should be able to produce a machine which is equivalent to M ? . We call this the characteristic sample requirement (CSR). CSR is important, as it ensures identification in the limit, a key concept in automata learning theory [18] . In what follows, we show that among the algorithms that will be presented in §5.2, only MooreMI satisfies CSR. Before proceeding, we remark that a given Moore (I, O)-trace (ρ I , ρ O ) = (x 1 x 2 • • • x n , y 0 y 1 • • • y n ) can be represented as a set of n+1 Moore (I, O)-examples, specifically {( , y 0 ), (x 1 , y 1 ), (x 1 x 2 , y 2 ), • • •, (x 1 x 2 • • • x n , y n )}. Because of this observation, in all approaches discussed below, there is a preprocessing step to convert the training set, first into an equivalent set of Moore (I, O)-examples, and second, into an equivalent set of N pairs of positive and negative example sets (the latter conversion was described in §3.3). Algorithms to solve the LMoMIO problem The PTAP algorithm This algorithm is a rather straightforward one. The set of Moore (I, O)-examples obtained after the preprocessing step described above is used to construct a PTAP, as described in §3.3. Recall that a PTAP is a collection of N PTAs having the same state-transition structure. The synchronous product of these N PTAs is then formed, completed, and returned as the result of the algorithm. Note that a PTA is a special case of an NFA: the PTA is deterministic, but it is generally incomplete. The synchronous product of PTAs is therefore the same as the synchronous product of NFAs. The product of PTAs is deterministic, but also generally incomplete, and therefore needs to be completed in order to yield a complete DFA. Completion in this case consists in adding self-loops to states that are missing outgoing transitions for some input symbols. The added self-loops are labeled with the missing input symbols. Although the PTAP algorithm is relatively easy to implement and runs efficiently, it has several drawbacks. First, since no state minimization is attempted, the resulting Moore machine can be unnecessarily large. Second, and most importantly, the produced machines generally have poor accuracy since completion is done in a trivial manner. The PRPNI algorithm Again, consider the N pairs of positive and negative example sets obtained after the preprocessing step. The PRPNI algorithm starts by executing the RPNI DFA learning algorithm [39] on each pair, thus obtaining N learned DFAs. Then, the synchronous product of these DFAs is formed, completed, and returned as the algorithm result. As in the case of the PTAP algorithm, the synchronous product of the DFAs in the PRPNI algorithm is deterministic but generally not complete. The completion step of the PRPNI algorithm is more intricate than the completion step of the PTAP algorithm. The reason is that the synchronous product of the learned DFAs may contain reachable states whose bit encoding does not correspond to any valid output in O. For example, suppose O = {0, 1, 2}, so that we need 2 bits to encode it, and thus N = 2 and we use RPNI to learn 2 DFAs. Suppose the encoding is 0 → 00, 1 → 01, 2 → 10. This means that the code 11 does not correspond to any valid output in O. However, it can still be the case that in the product of the two DFAs there is a reachable state with the output 11, i.e., where both DFAs are in an accepting state. Note that this problem does not arise in the PTAP algorithm, because all PTAs there are guaranteed to have the same state-transition structure, which is also the structure of their synchronous product. To solve this invalid-code problem, we assign all invalid codes to an arbitrary valid output. In our implementation, we use the lexicographic minimum. In the above example, the code 11 will be assigned to the output 0. Compared to the PTAP algorithm, the PRPNI algorithm has the advantage of being able to learn a minimal Moore machine when provided with enough (I, O)-traces. However, it can also perform worse in terms of both running time and size (number of states) of the learned machine, due to potential state explosion while forming the DFA product. The PTAP algorithm does not have this problem because, as explained above, the structure, and therefore also the number of states, of the product is identical to those of the component PTAs. The MooreMI algorithm As we saw above, both the PTAP and PRPNI algorithms have several drawbacks. In this section we propose a novel algorithm, called, MooreMI, which remedies these. Moreover, we shall prove that MooreMI satisfies CSR. The MooreMI algorithm begins by building a PTAP represented as N PTAs, as in the PTAP algorithm. Then, a merging phase follows, where a merge operation is accepted only if all resulting DFAs are consistent with their respective negative example sets. In addition, a merge operation is either performed on all DFAs at once or not at all. Finally, the synchronous product of the N learned DFAs is formed, completed by adding self loops for any missing input symbols, as in the PTAP algorithm, and returned. The pseudocode of the algorithm is given below. The main MooreMI procedure calls the merge function as a subroutine. merge computes the result of merging the given red and blue states of the given DFA component. It also performs additional potentially necessary state merges to preserve determinism. After the initial preprocessing step (line 6), the algorithm builds a prefix tree acceptor product (line 10) and then repeatedly attempts to merge states in it, in a specific order (line 16). While not appearing in the original RPNI algorithm, the convention of marking states as red or blue was introduced later in [31] . States marked as red represent states that have been processed and will be part of the resulting machine. States marked as blue are immediate successors of red states and represent states that are currently being processed. Initially, the set of red states only contains the initial state q , and the set of blue states contains the one-letter successors of q (lines 13, 14). Unmarked states will eventually become blue (lines 38, 43) , and then either merged with red ones (lines 27, 36) or become red states themselves (line 42). Most of the auxiliary functions whose implementations are not shown in the pseudocode have self explanatory names. For instance, the push and pop functions push and pop, respectively, elements to / from a stack, and the functions in lines 53, 54 compute the unique parent of and corresponding input symbol leading to the given blue state (uniqueness of both is guaranteed by the tree-shaped nature of the initial PTA). The function pick next, however, deserves some additional explanation. Notice first that after the prefix tree acceptor product is constructed and before the merging phase of the algorithm begins, each state can reached by a unique input word which is used to identify that state. For example, the state reached by the word abba is referred to as state q abba . The word used to identify a state may change during merging operations. The total order on words < defined in §4.1 can now naturally be extended on states of the learned machine as follows: q u < q v ⇐⇒ u < v, in which case we say that q u is smaller than q v . The pick next function simply returns the smallest state of the blue set, according to the order we just defined. MooreMI is able to learn minimal Moore machines, while avoiding the state explosion and invalid code issues of PRPNI. To see this, notice first that, at every point of the algorithm, the N learned DFAs are identical in terms of states and transitions, modulo the marking of their states as final. Indeed, this invariant holds by construction for the N initial prefix tree acceptors, and the additional merge constraints make sure it is maintained throughout the algorithm. Therefore, the product formed at the end of the algorithm can be obtained by simply \"overlaying\" the N DFAs on top of one another, as in the PTAP approach, which implies no state explosion. The absence of invalid output codes is also easy to see. Invalid codes generally are results of problematic state tuples in the DFA product, that cannot appear in MooreMI due to the additional merge constraints. Indeed, if a state tuple occurs in the final product, it must also occur in the initial prefix tree acceptor product, and if it occurs there, its code cannot be invalid. Properties of the algorithms All three algorithms described above satisfy consistency w.r.t. the input training set. For PTAP and PRPNI, this is a direct consequence of the properties of PTAs, of the basic RPNI algorithm, and of the synchronous product. The proof for MooreMI is somewhat more involved, therefore the result for MooreMI is stated as a theorem: Theorem 1 (Consistency). The output of the MooreMI algorithm is a complete Moore machine, consistent with the training set. Formally, let S IO be the set of Moore (I, O)-traces used as input for the algorithm, and let M = (I, O, Q, q 0 , δ, λ) be the resulting Moore machine. Then, δ and λ are total functions and ∀ (ρ I , ρ O ) ∈ S IO : λ * (q 0 , ρ I ) = ρ O . Proof. The fact that δ and λ are total is guaranteed by the final step of the algorithm (line 49). Consistency with the training set can be proved inductively. Let N denote the number of DFAs learned by the algorithm, which is equal to the number of bits required to represent an element of O. By definition, the Moore machine implicitly defined (by means of a synchronous product) by the N prefix tree acceptors initially built by the algorithm is consistent with the training set. Assume that, before a merge operation is performed, the Moore machine implicitly defined by the (possibly incomplete) DFAs learned so far is consistent with the training set. It suffices to show that the result of the next merge operation also has this property. Suppose it does not. This means that there exists a (ρ I , ρ O ) ∈ S IO , such that λ * (q 0 , ρ I ) = ρ O , which implies that in at least one of the learned DFAs, at least one state was added to the corresponding set of final states, while it should not have been (note that performing a merge operation on a DFA always yields a result accepting a superset of the language accepted prior to the merge). In other words, there is at least one learned DFA that is not consistent with its corresponding projection of the training set. However, due to the additional merge constraints that were introduced, this cannot happen, since all DFAs must be compatible with a merge in order for it to take place (line 29). We now show that MooreMI satisfies the characteristic sample requirement, i.e., if it is fed with a characteristic sample for a machine M , then it learns a machine equivalent to M . If M is minimal then the learned machine will in fact be isomorphic to M . We first introduce some auxiliary definitions and notation, and make some observations which are important for the proof of the result. Let M = (I, O, Q m , q 0 m , δ m , λ m ) be the minimal Moore machine from which we derive a characteristic sample, then given as input to the MooreMI algorithm. Let M A = (I, O, Q A , q , δ A , λ A ) be the machine produced by the algorithm. We will use plain Q and δ to denote the state set and possibly partial transition function of the learned machine in an intermediate step of the algorithm. It can be seen in the pseudocode of the merge function (line 66) that when two states q u , q v are merged in order to preserve determinism, the input word used to identify the resulting state is min < {u, v}, where < is the total order defined in §4.1. When we say that q u is smaller than q v or q v bigger than q u , we will mean u = min < {u, v}. We remark that when a blue state is merged with a red one, the latter is always smaller. This is a direct consequence of the tree-shaped nature of the initial prefix tree acceptor product, the fact that blue states are one-letter successors of red ones, and the specific order in which blue states are considered during the merging phase. By saying that a state q u ∈ Q corresponds to a shortest prefix of M , we mean that u ∈ S P (M ). By saying that a state q v ∈ Q corresponds to an element in N L (M ), we mean that the state q v can be reached from q using an element in N L (M ). red and blue refer to the sets of red and blue states, as in the pseudocode of MooreMI. Given a red state q u , we will use M erged(q u ) to denote the set of states that have been merged with / into q u . In the following, we assume that the training set used as input to the MooreMI algorithm is a characteristic sample for a minimal Moore machine M . Lemma 1. (a) Each red state corresponds to an element of S P (M ) and as a consequence, to a state in M . (b) Each blue state corresponds to an element of N L (M ). (c) ∀q u ∈ red : ∀q v ∈ M erged(q u ) : δ * m (q 0 m , v) = δ * m (q 0 m , u). Proof. By induction. Initially, red = {q }, blue ⊆ {q a | a ∈ I}, and (a), (b), (c) all hold trivially. We assume they hold for the current sets of red, blue and unmarked states and will show they still hold after all possible operations performed by the algorithm: (1) If a state q v ∈ blue is merged into a state q u ∈ red, then (a) trivially holds: The red state set remains the same, and the successors of q v are marked blue. Since they now are successors of a state corresponding to a shortest prefix (the red state q u ), they correspond to elements in the nucleus of M , so (b) holds too. Suppose now that (c) does not hold, i.e. it is δ * m (q 0 m , v) = δ * m (q 0 m , u). Since, by the induction hypothesis, u ∈ S P (M ) and q v corresponds to an element in N L (M ), by the characteristic sample definition, there exist (I, O)-traces that distinguish q v and q u and prohibit their merge. But q v and q u were successfully merged, therefore δ * m (q 0 m , v) = δ * m (q 0 m , u) and (c) holds. (2) If a state q v ∈ blue is promoted to a red state, then it is distinct from all other red states. Moreover, since (i) the algorithm considers blue states in a specific order and (ii) whenever we perform a merge between two states q x and q y to preserve determinism the result is identified as q min<(x,y) , q v is the smallest state distinct from the existing red states, therefore it corresponds to a shortest prefix. Its successors are now marked blue and since q v corresponds to a shortest prefix, they correspond to states in N L (M ). Also, since the newly promoted red state is a shortest prefix distinct from the previous ones, it corresponds to a unique, different state in M . The above imply that (a) and (b) hold. Moreover, (c) trivially holds too. (3) Regarding the additional state merges possibly required to maintain determinism after (1) , they can occur between a red and a blue state, in which case the same as in (1) hold, between a blue state and a state that is either blue or unmarked, in which case we have what we want by the induction hypothesis, and between two unmarked states, in which case we do not need to show anything. However, we should mention here that for every pair of states being merged to preserve determinism, the two states involved necessarily represent the same state in M . Suppose, without loss of generality that after merging states q u and q v as in (1), states q ua = δ * (q u , a) and q va = δ * (q v , a) need to also be merged to preserve determinism. If q ua and q va do not represent the same state in M , their minimum distinguishing suffix w = M D (q ua , q va ) exists. But then, a • w is a distinguishing suffix for q u and q v , which means that q u and q v represent different states in M . However, this cannot be, because, since by the induction hypothesis u ∈ S P (M ) and q v corresponds to an element in N L (M ), by the characteristic sample definition, if q u and q v were different states, (I, O)-traces prohibiting their merge would be present in the algorithm input. Therefore, q ua and q va represent the same state in M . The same argument can now be made if e.g. states q uab and q vab need to be merged to preserve determinism after q ua and q va are merged, and so on. Lemma 2. |Q m | ≤ |Q A |. Proof. Suppose that |Q m | > |Q A |, i.e. there exists q ∈ Q m such that there is no equivalent of q in Q A . However, by the definition of the characteristic sample, the shortest prefix of q appears in the algorithm input, and, according to Lemma 1, it must eventually form a red state on its own. Therefore, there is no such state as q, and |Q m | ≤ |Q A | holds. Corollary 1. The previous lemmas imply the existence of a bijection f iso : Q A → Q m such that f iso (q u ) = δ * m (q 0 m , u). Lemma 3. ∀q u ∈ Q A : λ A (q u ) = λ m (f iso (q u )). Proof. We have shown that q u ∈ Q A corresponds to a unique state in M , specifically δ * m (q 0 m , u). We have also shown that the algorithm is consistent with the training examples. This implies λ A (q u ) = λ m (δ * m (q 0 m , u)). Now, since, by definition, f iso (q u ) = δ * m (q 0 m , u), we have what we wanted. Lemma 4. ∀q u ∈ Q A : ∀a ∈ I : δ m (f iso (q u ), a) = f iso (δ A (q u , a)). Proof. Let δ A (q u , a) = δ * A (q , u • a) = q v ∈ Q A . By definition, we have f iso (q u ) = δ * m (q 0 m , u) and f iso (q v ) = δ * m (q 0 m , v). In addition, δ * m (f iso (q u ), a) = δ m (δ * m (q 0 m , u), a) = δ * m (q 0 m , u•a). But δ * A (q , u•a) = q v = δ * A (q , v), therefore, from Lemma 1 (c) we have δ * m (q 0 m , u • a) = δ * m (q 0 m , v). Finally, δ m (f iso (q u ), a) = δ m (q 0 m , u • a) = δ m (q 0 m , v) = f iso (q v ) = f iso (δ A (q u , a)), as we wanted. Theorem 2 (Characteristic sample requirement). If the input to MooreMI is a characteristic sample of a minimal Moore machine M , then the algorithm returns a machine M A that is isomorphic to M . Proof. Follows from Corollary 1, Lemmas 3, 4 and the observation that f iso (q ) = q 0 m . The bijection f iso constitutes a witness isomorphism between M and M A . Finally, we show that the MooreMI algorithm achieves identification in the limit. Theorem 3 (Identification in the limit). Let M = (I, O, Q, q 0 , δ, λ) be a minimal Moore machine. Let (ρ 1 I , ρ 1 O ), (ρ 2 I , ρ 2 O ), • • • be an infinite sequence of (I, O)-traces generated from M , such that ∀ρ ∈ I * : ∃i : ρ = ρ i I (i.e., every input word appears at least once in the sequence). Then there exists index k such that for all n ≥ k, the MooreMI algorithm learns a machine equivalent to M when given as input the training set {(ρ 1 I , ρ 1 O ), (ρ 2 I , ρ 2 O ), • • • , (ρ n I , ρ n O )}. Proof. Let S n IO = {(ρ 1 I , ρ 1 O ), (ρ 2 I , ρ 2 O ), • • • , (ρ n I , ρ n O )}, for any index n. Since M is a minimal Moore machine, there exists at least one characteristic sample S IO = {(r 1 I , r 1 O ), (r 2 I , r 2 O ), • • • , (r N I , r N O )} for it. By the hypothe- sis, ∀j ∈ {1, • • • , N } : ∃i j such that ρ ij I = r j I . Let then k = max j∈{1,•••,N } i j . It is easy to see now that S k IO = {(ρ 1 I , ρ 1 O ), (ρ 2 I , ρ 2 O ), • • • , (ρ k I , ρ k O ) } is a characteristic sample (as a superset of S IO ). From the properties of characteristic samples it also follows that for any n ≥ k, S n IO is also a characteristic sample (since in that case S n IO ⊇ S k IO ). Finally, from Theorem 2, when MooreMI is given S n IO , for any n ≥ k, as input, it will output a Moore machine isomorphic, and therefore equivalent, to M . Performance optimizations Compared to the pseudocode our implementation includes several optimizations. First, to limit the amount of copying involved in performing a merge operation, we perform the required state merges in-place, and at the same time record the actions needed to undo them in case the merge is not accepted. Second, the merge function needs to know the unique (due to the tree-shaped nature of PTAs) parent of the blue state passed to it as an argument. The naive way of doing this, simply iterating over the states until we reach the parent, can seriously harm performance. Instead, in our implementation, we build during PTA construction, and maintain throughout the algorithm, a mapping of states to their parents, and consult this when needed. Third, in the negative examples consistency test, many of the acceptance checks involved are redundant. For example, suppose that starting from the initial state it is only possible to reach red states (i.e. not blue or unmarked ones) within n steps (transitions). Then, there is no need to include negative examples of length less than n in the consistency test. Our implementation optimizes such cases by integrating the consistency test with the merge operation. In particular, we construct the initial PTAs based not only on positive but also on negative examples, and mark states not only as accepting but also as rejecting when appropriate, as described in [14] . Then, during the merge operation, if an attempt to merge an accepting state with a rejecting one occurs, the merge is rejected. Complexity analysis In order to build a prefix tree acceptor we need to consider all prefixes of words in the set of positive examples S + . This yields a complexity of O( w∈S+ |w|), where |w| indicates the length of the word w. A prefix tree acceptor product is represented by N prefix tree acceptors that have the same state-transition structure, where N is the number of bits required to represent an output letter. Therefore, constructing a prefix tree acceptor product having 2 N -1 < |O| ≤ 2 N distinct output symbols, requires O(N • w∈S all + |w|) work, where S all + denotes the union of the N positive example sets, S i+ (we need to consider all for each PTA, because we want the PTAs to have the same state-transition structure). During the main loop of the basic RPNI algorithm, at most |Q P T A | 2 merge operations are attempted, where Q P T A denotes the set of states in the PTA. Each merge operation (including all additional state merges required to maintain determinism) requires O(|Q P T A |) work. After every merge operation, a compatibility check is performed to determine whether it should be accepted or not, requiring O( w∈S-|w|) work. Bearing in mind that |Q P T A | is bounded by w∈S+ |w|, all this amounts for a total work in the order of O(( w∈S+ |w|) 2 • ( w∈S+ |w| + w∈S-|w|)). In the PRPNI algorithm, the basic RPNI loop is repeated N times in sequence, which amounts for a total complexity of O(  The table also shows that PTAP and PRPNI generate much larger machines than the correct ones. This in turn explains why MooreMI performs better in terms of running time than the other two algorithms, which spend a lot of time completing the large number of generated states. 6.2 Comparison with OSTIA q 0 q 1 q 2 a/ , b/ a/02 a/0 b/220 b/0122 OSTIA [40] is a well-known algorithm that learns onward subsequential transducers, a class of transducers more general than Moore and Mealy machines. Then, a question arising naturally is whether it is possible to use OSTIA for learning Moore machines. In particular, we would like to know what happens when the input to OSTIA is a set of Moore (I,O)-traces: will OSTIA learn a Moore machine? The answer here is negative, as indicated by an experiment we performed. We constructed a characteristic sample for the Moore machine in Figure 5a and ran the OSTIA algorithm on it (we used the open source implementation described in [3] ). The resulting machine is depicted in Figure 6 . Notice that there are transitions whose corresponding outputs are words of length more than 1 (e.g., transition label b/0122), or even the empty word (output of initial state q 0 ). We conclude that in general OSTIA cannot learn Moore machines, even when the training set is a set of Moore traces, and is also a characteristic sample. Conclusion & Future Work We formalized the problem of learning Moore machines for input-output traces and developed three algorithms to solve this problem. We showed that the most advanced of these algorithms, MooreMI, has desirable theoretical properties: in particular it satisfies the characteristic sample requirement and achieves identification in the limit. We also compared the algorithms experimentally and showed that MooreMI is also superior in practice. Future work includes: (1) studying learning for Mealy and other types of state machines; (2) developing incremental versions of the learning algorithms presented here; (3) further implementation and experimentation; and (4) application of the methods presented here for learning models of various types of black-box systems. b) Mealy machine M2 on input-output sets I = {x1, x2} and O = {y1, y2}. Fig. 1 : 1 Fig. 1: Examples of finite state machines. Fig. 2 : 2 Fig. 2: Examples of finite state automata. Target minimal Moore machine. Moore machine learned by our MooreMI algorithm if we use a set of traces that does not satisfy Condition 2 of Definition 1. Fig. 5 : 5 Fig. 5: Example illustrating the need for Condition 2 of Definition 1. 1 6 : 8 N 40 ∩if q 2 ∈ 68402 def MooreMI ( trace set , Σ I , Σ O ): = preprocess moore traces(trace set ) 7 := ceil( log 2 ( | Σ O | ) ) 9 10 DFA list := build pref ix tree acceptor product( 11 list of pos example sets , Σ I , Σ O ) 12 13 red = { q } 14 blue = { q a for a in Σ I } ∩ DFA list [0].Q 15 16 while blue = ∅: 17 18 q blue = pick next(blue) 19 blue := blue -{q blue} 20 21 merge accepted := false 22 23 for q red ∈ red: 24 25 for i ∈ {0, ... , N -1}: 26 new DFA list [i] := 27 merge(DFA list [i], q red , q blue ) 28 29 if ∀ i ∈ {0, ... , Nblue ∪ ( { one-letter 39 successors of red states } DFA list [0].Q ) DFA.F : 73 DFA.F := DFA.F ∪ {q 1} 74 75 for a ∈ DFA.Σ : 76 if is def ined(DFA.δ(q 2 , a)): 77 if is def ined(DFA.δ(q 1 , a) N i=1 ( i=1 w∈Si+ |w|) 2 • ( w∈Si+ |w| + w∈Si-|w|)). In the MooreMI approach, N DFAs are learned in parallel, and the total work done is O(N • ( w∈S all + |w|) 2 • ( w∈S all + |w| + w∈S all -|w|)), where S all -, similarly to S all + , denotes the union of the N negative example sets, S i-. Note here that since the sets S i+ (resp. S i-) are not disjoint in general, w∈S all + |w| (resp. w∈S all -|w|) is bounded byN i=1 w∈Si+ |w| (resp. N i=1 w∈Si-|w|). Forming the DFA product to obtain a Moore machine requires O(N • |Q P T A |) work for the PTAP and MooreMI algorithms, but O(N • N i=1 |Q i P T A |) work for the PRPNI approach. Similarly, completing the resulting Moore ma- Fig. 6 : 6 Fig. 6: The transducer learned by OSTIA given a characteristic sample for the Moore machine in Figure 5a as input. Table 1 : 1 50 (resp. 150) states tab: average training set size: 1305 (resp. 4540), average input word length in training set: 3.5 (resp. 4).But as it can be seen from the table, neither PTAP nor PRPNI learn the correct machines, even though the training set is a characteristic sample. 50 states 150 states Algo Time States Accuracy (%) Strong Medium Weak Time States Accuracy (%) Strong Medium Weak 1 0.973 2113 0 32.44 35.39 8.329 7135 0 28.28 31.13 2 12.753 8925 0 33.82 36.57 60 Timeout - - - 3 0.348 50 100 100 100 2.545 150 100 100 100 set). The term smallest automaton is used in the exact identification problem, instead of the more well-known term minimal automaton. Among equivalent machines, one with the fewest states is called minimal. Among machines which are all consistent with a set of traces but not necessarily equivalent, one with the fewest states is called smallest. We have implemented the k-tails algorithm and applied it on the characteristic sample for the Moore machine in Figure 5a, described in Section 4.1. Using k = 0, we get a non-deterministic machine of 3 states. Using any k > 0, we get a deterministic machine of 8 states. This excessive number of states is due to the way the k-tails equivalence relation is defined. In particular, in order for two input words to be considered equivalent, they must have successors in the training set with the same letters. This implies that a word with no successors in the training set can never be equivalent with a word with some successors, even if both words represent the same state in the target machine."
}