{
  "title": "",
  "abstract": "",
  "introduction": "1",
  "body": "1 Bayesian Decision Theory During the next few lectures we will be looking at the inference from training data problem as a random process modeled by the joint probability distribution over input (measurements) and output (say class labels) variables. In general, estimating the underlying distribution is a daunting and unwieldy task, but there are a number of constraints or \"tricks of the trade\" so to speak that under certain conditions make this task manageable and fairly effective. To make things simple, we will assume a discrete world, i.e., that the values of our random variables take on a finite number of values. Consider for example two random variables X taking on k possible values x 1 , ..., x k and H taking on two values h 1 , h 2 . The values of X could stand for a Body Mass Index (BMI) measurement weight/height 2 of a person and H stands for the two possibilities h 1 standing for the \"person being over-weight\" and h 2 as the possibility \"person of normal weight\". Given a BMI measurement we would like to estimate the probability of the person being over-weight. The joint probability P (X, H) is a two dimensional array (2-way array) with 2k entries (cells). Each training example (x i , h j ) falls into one of those cells, therefore P (X = x i , H = h j ) = P (x i , h j ) holds the ratio between the number of hits into cell (i, j) and the total number of training examples (assuming the training data arrive i.i.d.). As a result ij P (x i , h j ) = 1. The projections of the array onto its vertical and horizontal axes by summing over columns or over rows is called marginalization and produces P (h j ) = i P (x i , h j ) the sum over the j'th row is the probability P (H = h j ), i.e., the probability of a person being over-weight (or not) before we see any measurement -these are called priors. Likewise, P (x i ) = j P (x i , h j ) is the probability P (X = x i ) which is the probability of receiving such a BMI measurement to begin with -this is often called evidence. Note h 1 2 5 4 2 1 h 2 0 0 3 3 2 x 1 x 2 x 3 x 4 x 5 Fig. 1 .1. Joint probability P (X, H) where X ranges over 5 discrete values and H over two values. Each entry contains the number of hits for the cell (x i , h j ). The joint probability P (x i , h j ) is the number of hits divided by the total number of hits (22) . See text for more details. that, by definition, j P (h j ) = i P (x i ) = 1. In Fig. 1 .1 we have that P (h 1 ) = 14/22, P (h 2 ) = 8/22 that is there is a higher prior probability of a person being over-weight than being of normal weight. Also P (x 3 ) = 7/22 is the highest meaning that we encounter BMI = x 3 with the highest probability. The conditional probability P (h j | x i ) = P (x i , h j )/P (x i ) is the ratio between the number of hits in cell (i, j) and the number of hits in the i'th column, i.e., the probability that the outcome is H = h j given the measurement X = x i . In Fig. 1 .1 we have P (h 2 | x 3 ) = 3/7. Note that j P (h j | x i ) = j P (x i , h j ) P (x i ) = 1 P (x i ) j P (x i , h j ) = P (x i )/P (x i ) = 1. Likewise, the conditional probability P (x i | h j ) = P (x i , h j )/P (h j ) is the number of hits in cell (i, j) normalized by the number of hits in the j'th row and represents the probability of receiving BMI = x i given the class label H = h j (over-weight or not) of the person. In Fig. 1 .1 we have P (x 3 | h 2 ) = 3/8 which is the probability of receiving BMI = x 3 given that the person is known to be of normal weight. Note that i P (x i | h j ) = 1. The Bayes formula arises from: P (x i | h j )P (h j ) = P (x i , h j ) = P (h j | x i )P (x i ), from which we get: P (h j | x i ) = P (x i | h j )P (h j ) P (x i ) . The left hand side P (h j | x i ) is called the posterior probability and P (x i | h j ) is called the class conditional likelihood . The Bayes formula provides a way to estimate the posterior probability from the prior, evidence and class likelihood. It is useful in cases where it is natural to compute (or collect data of) the class likelihood, yet it is not quite simple to compute directly the posterior. For example, given a measurement \"12\" we would like to estimate the probability that the measurement came from tossing a pair of dice or from spinning a roulette table. If x = 12 is our measurement, and h 1 stands for \"pair of dice\" and h 2 for \"roulette\" then it is natural to compute the class conditional: P (\"12\" | \"pair of dice\") = 1/36 and P (\"12\" | \"roulette\") = 1/38. Computing the posterior directly is much more difficult. As another example, consider medical diagnosis. Once it is known that a patient suffers from some disease h j , it is natural to evaluate the probabilities P (x i | h j ) of the emerging symptoms x i . As a result, in many inference problems it is natural to use the class conditionals as the basic building blocks and use the Bayes formula to invert those to obtain the posteriors. The Bayes rule can often lead to unintuitive results -the one in particular is known as \"base rate fallacy\" which shows how an nonuniform prior can influence the mapping from likelihoods to posteriors. On an intuitive basis, people tend to ignore priors and equate likelihoods to posteriors. The following example is typical: consider the \"Cancer test kit\" problem † which has the following features: given that the subject has Cancer \"C\", the probability of the test kit producing a positive decision \"+\" is P (+ | C) = 0.98 (which means that P (-| C) = 0.02) and the probability of the kit producing a negative decision \"-\" given that the subject is healthy \"H\" is P (-| H) = 0.97 (which means also that P (+ | H) = 0.03). The prior probability of Cancer in the population is P (C) = 0.01. These numbers appear at first glance as quite reasonable, i.e, there is a probability of 98% that the test kit will produce the correct indication given that the subject has Cancer. What we are actually interested in is the probability that the subject has Cancer given that the test kit generated a positive decision, i. which means that there is a 26.6% chance that the subject has Cancer given that the test kit produced a positive response -by all means a very poor performance. If we draw the posteriors P (h 1 |x) and P (h 2 | x) using the probability distribution array in Fig. 1 .1 we will see that P (h 1 |x) > P (h 2 | x) for all values of X smaller than a value which is in between x 3 and x 4 . Therefore the decision which will minimize the probability of misclassification would be to choose the class with the maximal posterior: h * = argmax j P (h j | x), which is known as the Maximal A Posteriori (MAP) decision principle. Since P (x) is simply a normalization factor, the MAP principle is equivalent to: h * = argmax j P (x | h j )P (h j ). In the case where information about the prior P (h) is not known or it is known that the prior is uniform, the we obtain the Maximum Likelihood (ML) principle: h * = argmax j P (x | h j ). The MAP principle is a particular case of a more general principle, known as \"proper Bayes\", where a loss is incorporated into the decision process. Let l(h i , h j ) be the loss incurred by deciding on class h i when in fact h j is the correct class. For example, the \"0/1\" loss function is: l(h i , h j ) = 1 i = j 0 i = j The least-squares loss function is: l(h i , h j ) = h i -h j 2 typically used when the outcomes are vectors in some high dimensional space rather than class labels. We define the expected risk : R(h i | x) = j l(h i , h j )P (h j | x). The proper Bayes decision policy is to minimize the expected risk: h * = argmin j R(h j | x). The MAP policy arises in the case l(h i , h j ) is the 0/1 loss function: R(h i | x) = j =i P (h j | x) = 1 -P (h i | x), Thus, argmin j R(h j | x) = argmax j P (h j | x). Independence Constraints At this point we may pause and ask what have we obtained? well, not much. Clearly, the inference problem is captured by the joint probability distribution and we do not need all these formulas to see this. How do we obtain the necessary data to fill in the probability distribution array to begin with? Clearly without additional simplifying constraints the task is not practical as the size of these kind of arrays are exponential in the number of variables. There are three families of simplifying constraints used in the literature: • statistical independence constraints, • parametric form of the class likelihood P (x i | h j ) where the inference becomes a density estimation problem, • structural assumptions -latent (hidden) variables, graphical models. Today we will focus on the first of these simplifying constraints -statistical independence properties. Consider two random variables X and Y . The variables are statistically independent X⊥Y if P (X | Y ) = P (X) meaning that information about the value of Y does not add anything about X. The independence condition is equivalent to the constraint: P (X, Y ) = P (X)P (Y ). This can be easily proven: if X⊥Y then P (X, Y ) = P (X | Y )P (Y ) = P (X)P (Y ). On the other hand, if P (X, Y ) = P (X)P (Y ) then P (X | Y ) = P (X, Y ) P (Y ) = P (X)P (Y ) P (Y ) = P (X). Let the values of X range over x 1 , ..., x k and the values of Y range over y 1 , ..., y l . The associated k × l 2-way array, P (X = x i , Y = y j ) is represented by the outer product P (x i , y j ) = P (x i )P (y j ) of two vectors P (X) = (P (x 1 ), ..., P (x k )) and P (Y ) = (P (y 1 ), ..., P (y l )). In other words, the 2-way array viewed as a matrix is of rank 1 and is determined by k + l (minus 2 because the sum of each vector is 1) parameters rather than kl (minus 1) parameters. Likewise, if X 1 ⊥X 2 ⊥....⊥X n are n statistically independent random variables where X i ranges over k i discrete and distinct values, then the n-way array P (X 1 , ..., X n ) = P (X 1 ) • ... • P (X n ) is an outer-product of n vectors and is therefore determined by k 1 + ... + k n (minus n) parameters instead of k 1 k 2 ...k n (minus 1) parameters †. Viewed as a tensor, the joint probabil- † I am a bit over simplifying things because we are ignoring here the fact that the entries of the array should be non-negative. This means that there are additional non-linear constraints which effectively reduce the number of parameters -but nevertheless it stays exponential. ity is a rank 1 tensor. The main point is that the statistical independence assumption reduced the representation of the multivariate joint distribution from exponential to linear size. Since our variables are typically divided to measurement variables and an output/class variable H (or in general H 1 , ..., H l ), it is useful to introduce another, weaker form, of independence known as conditional independence. Variables X, Y are conditionally independent given H, denoted by X⊥Y | H, iff P (X | Y, H) = P (X | H) meaning that given H, the value of Y does not add any information about X. This is equivalent to the condition P (X, Y | H) = P (X | H)P (Y | H). The proof goes as follows: • If P (X | Y, H) = P (X | H), then P (X, Y | H) = P (X, Y, H) P (H) = P (X | Y, H)P (Y, H) P (H) = P (X | Y, H)P (Y | H)P (H) P (H) = P (X | H)P (Y | H) • If P (X, Y | H) = P (X | H)P (Y | H), then P (X | Y, H) = P (X, Y, H) P (Y, H) = P (X, Y | H) P (Y | H) = P (X | H). Consider as an example, Joe and Mo live on opposite sides of the city. Joe goes to work by train and Mo by car. Let X be the event \"Joe is late to work\" and Y be the event \"Mo is late for work\". Clearly X and Y are not independent because there could be other factors. For example, a train strike will cause Joe to be late, but because of the strike there would be extra traffic (people using their car instead of the train) thus causing Mo to be pate as well. Therefore, a third variable H standing for the event \"train strike\" would decouple X and Y . From a computational standpoint, the conditional independence assumption has a similar effect to the unconditional independence. Let X range over k distinct value, Y range over r distinct values and H range over s distinct values. Then P (X, Y, H) is a 3-way array of size k × r × s. Given that X⊥Y | H means that P (X, Y | H = h i ), a 2-way \"slice\" of the 3-way array along the H axis is represented by the outer-product of two vectors P (X | H = h i )P (Y | H = h i ). As a result the 3-way array is represented by s(k + r -2) parameters instead of skr -1. Likewise, if X 1 ⊥....⊥X n | H then the n-way array P (X 1 , ..., X n | H = h i ) (which is a slice along the H axis of the (n + 1)-array P (X 1 , ..., X n , H)) is represented by an outer-product of n vectors, i.e., by k 1 + .. + k n -n parameters. Example: Coin Toss We will use the ML principle to estimate the bias of a coin. Let X be a random variable taking the value {0, 1} and H would be our hypothesis taking a real value in [0, 1] standing for the coin's bias. If the coin's bias is q then P (X = 0 | H = q) = q and P (X = 1 | H = q) = 1 -q. We receive m i.i.d. examples x 1 , ..., x m where x i ∈ {0, 1}. We wish to determine the value of q. Given that x 1 ⊥...⊥x m | H, the ML problem we must solve is: q * = argmax q P (x 1 , ..., x m | H = q) = m i=1 P (x i | q) = argmax q i log P (x i | q). Let 0 ≤ λ ≤ m stand for the number of '0' instances, i.e., λ = |{x i = 0 | i = 1, ..., m}|. Therefore our ML problem becomes: q * = argmax q {λ log q + (n -λ) log(1 -q)} Taking the partial derivative with respect to q and setting it to zero: ∂ ∂q [λ log q + (n -λ) log(1 -q)] = λ q * - n -λ 1 -q * = 0, produces the result: q * = λ n . Example: Gaussian Density Estimation So far we considered constraints induced by conditional independent statements among the random variables as a means to reduce the space and time complexity of the multivariate distribution array. Another approach would be to assume some form of parametric form governing the entries of the array -the most popular assumption is Gaussian distribution P (X 1 , ..., X n ) ∼ N (µ, E) with mean vector µ and covariance matrix E. The parameters of the density function are denoted by θ = (µ, E) and for every vector x ∈ R n we have: P (x | θ) = 1 (2π) n/2 |E| 1/2 exp -1 2 (x-µ) E -1 (x-µ) . Assume we are given an i.i.d sample of k points S = {x 1 , ..., x k }, x i ∈ R n , and we would like to find the Bayes optimal θ: θ * = argmax θ P (S | θ), by maximizing the likelihood (here we are assuming that the the priors P (θ) are equal, thus the maximum likelihood and the MAP would produce the same result). Because the sample was drawn i.i.d. we can assume that: P (S | θ) = k i=1 P (x i | θ). Let L(θ) = log P (S | θ) = i log P (x i | θ) and since Log is monotonously increasing we have that θ * = argmax θ L(θ). The parameter estimation would be recovered by taking derivatives with respect to θ, i.e., ∇ θ L = 0. We have: L(θ) = - 1 2 log |E| - k i=1 n 2 log(2π) - i 1 2 (x i -µ) E -1 (x i -µ). (1.1) We will start with a simple scenario where E = σ 2 I, i.e., all the covariances are zero and all the variances are equal to σ 2 . Thus, E -1 = σ -2 I and |E| = σ 2n . After substitution (and removal of items which do not depend on θ) we have: L(θ) = -nk log σ - 1 2 i x i -µ 2 σ 2 . The partial derivative with respect to µ: ∂L ∂µ = σ -2 i (µ -x i ) = 0 from which we obtain: µ = 1 k k i=1 x i . The partial derivative with respect to σ is: ∂L ∂σ = nk σ -σ -3 i x i -µ 2 = 0, from which we obtain: σ 2 = 1 kn k i=1 x i -µ 2 . Note that the reason for dividing by n is due to the fact that σ 2 1 = ... = σ 2 n = σ 2 , so that: 1 k k i=1 x i -µ 2 = n j=1 σ 2 j = nσ 2 . In the general case, E is a full rank symmetric matrix, then the derivative of eqn. (1.1) with respect to µ is: ∂L ∂µ = E -1 i (µ -x i ) = 0, and since E -1 is full rank we obtain µ = (1/k) i x i . For the derivative with respect to E we note two auxiliary items: ∂|E| ∂E = |E|E -1 , ∂ ∂E trace(AE -1 ) = -(E -1 AE -1 ) . Using the fact that x y = trace(xy ) we can transform z E -1 z to trace(zz E -1 ) for any vector z. Given that E -1 is symmetric, then: ∂ ∂E trace(zz E -1 ) = -E -1 zz E -1 . Substituting z = x -µ we obtain: ∂L ∂E = -kE -1 + E -1 i (x i -µ)(x i -µ) E -1 = 0, from which we obtain: E = 1 k k i=1 (x i -µ)(x i -µ) . Incremental Bayes Classifier Consider another application of conditional dependence which is the Bayes incremental rule. Suppose we have processed n examples X (n) = {X 1 , ..., X n } and computed somehow P (H | X (n) ). We are given a new measurement X and wish to compute (update) the posterior P (H | X (n) , X). We will use the chain rule †: P (X | Y, Z) = P (X, Y, Z) P (Y, Z ) = P (Z | X, Y )P (X | Y )P (Y ) P (Z | Y )P (Y ) = P (Z | X, Y )P (X | Y ) P (Z | Y ) to obtain: P (H | X (n) , X) = P (X | X (n) , H)P (H | X (n) ) P (X | X (n) ) from conditional independence, P (X | X (n) , H) = P (X | H). The term P (X | X (n) ) can expanded as follows: † this is based on the rule P (X 1 , ..., Xn) = P (X 1 | X 2 , ..., Xn)P (X 2 | X 3 , ..., Xn) • • • P (X n-1 | Xn)P (Xn) P (X | X (n) ) = i P (X, X (n) | H = h i )P (H = h i ) P (X (n) ) = i P (X | H = h i )P (X (n) | H = h i )P (H = h i ) P (X (n) ) = i P (X | H = h i )P (H = h i | X (n) ) After substitution we obtain: P (H = h i | X (n) , X) = P (X | H = h i )P (H = h i | X (n) ) j P (X | H = h j )P (H = h j | X (n) ) . The old posterior P (H | X (n) ) is now the prior for the updated formula. Consider the following example †: We have a coin which could be either fair or biased towards Head at a probability of 0.6. Let H = h 1 be the event that the coin is fair, and H = h 2 that the coin is biased. We start with prior probabilities P (h 1 ) = 0.75 and P (h 2 ) = 0.25 (we have a higher initial belief that the coin is fair). Suppose our first coin toss is a Head, i.e., X 1 = \"0\". Then, P (h 1 | x 1 ) = P (x 1 | h 1 )P (h 1 ) P (x 1 ) = 0.5 * 0.75 0.5 * 0.75 + 0.6 * 0.25 = 0.714 and P (h 2 | x 1 ) = 0.286. Our posterior belief that the coin is fair has gone down after a Head toss. Assume we have another measurement X 2 = \"0\", then: P (h 1 | x 1 , x 2 ) = P (x 2 | h 1 )P (h 1 | x 1 ) normalization = 0 .5 * 0.714 0.5 * 0.714 + 0.6 * 0.286 = 0.675, and P (h 2 | x 1 , x 2 ) = 0.325, thus our belief that the coin is fair continues to go down after Head tosses. Bayes Classifier for 2-class Normal Distributions For the last topic in this lecture consider the 2-class inference problem. We will encountered this problem in this course in the context of SVM and LDA. In the Bayes framework, if H = {h 1 , h 2 } denotes the \"class member\" variable with two possible outcomes, then the MAP decision policy calls for making the decision based on data x: h * = argmax h 1 ,h 2 {P (h 1 | x), P (h 2 | x)} , or in other words the class h 1 would be chosen if P (h 1 | x) > P (h 2 | x). The decision surface (as a function of x) is therefore described by: P (h 1 | x) -P (h 2 | x) = 0. The questions we ask here is what would the Bayes optimal decision surface be like if we assume that the two classes are normally distributed with different means and the same covariance matrix? What we will see is that under the condition of equal priors P (h 1 ) = P (h 2 ) the decision surface is a hyperplane -and not only that, it is the same hyperplane produced by LDA. Claim 1 If P (h 1 ) = P (h 2 ) and P (x | h 1 ) ∼ N (µ 1 , E) and P (x | h 1 ) ∼ N (µ 2 , E), the the Bayes optimal decision surface is a hyperplane w (xµ) = 0 where µ = (µ 1 + µ 2 )/2 and w = E -1 (µ 1 -µ 2 ). In other words, the decision surface is described by: x E -1 (µ 1 -µ 2 ) - 1 2 (µ 1 + µ 2 )E -1 (µ 1 -µ 2 ) = 0. (1.2) Proof: The decision surface is described by P (h 1 | x) -P (h 2 | x) = 0 which is equivalent to the statement that the ratio of the posteriors is 1, or equivalently that the log of the ratio is zero, and using Bayes formula we obtain: 0 = log P (x | h 1 )P (h 1 ) P (x | h 2 )P (h 2 ) = log P (x | h 1 ) P (x | h 2 ) . In other words, the decision surface is described by log P (x | h 1 )-log P (x | h 2 ) = - 1 2 (x-µ 1 ) E -1 (x-µ 1 )+ 1 2 (x-µ 2 ) E -1 (x-µ 2 ) = 0. After expanding the two terms we obtain eqn. (1.2). In the previous lecture we defined the principle of Maximum Likelihood (ML): suppose we have random variables X 1 , ..., X n form a random sample from a discrete distribution whose joint probability distribution is P (x | φ) where x = (x 1 , ..., x n ) is a vector in the sample and φ is a parameter from some parameter space (which could be a discrete set of values -say class membership). When P (x | φ) is considered as a function of φ it is called the likelihood function. The ML principle is to select the value of φ that maximizes the likelihood function over the observations (training set) x 1 , ..., x m . If the observations are sampled i.i.d. (a common, not always valid, assumption), then the ML principle is to maximize: φ * = argmax φ m i=1 P (x i | φ) = argmax log m i=1 P (x i | φ) = argmax m i=1 log P (x i | φ) which due to the product nature of the problem it becomes more convenient to maximize the log likelihood. We will take a closer look today at the ML principle by introducing a key element known as the relative entropy measure between distributions. ML and Empirical Distribution The ML principle states that the empirical distribution of an i.i.d. sequence of examples is the closest possible (in terms of relative entropy which would be defined later) to the true distribution. To make this statement clear let X be a set of symbols {a 1 , ..., a n } and let P (a | θ) be the probability (belonging to a parametric family with parameter θ) of drawing a symbol a ∈ X . Let x 1 , ..., x m be a sequence of symbols drawn i.i.d. according to P . The occurrence frequency f (a) measures the number of draws of the symbol a: f (a) = |{i : x i = a}|, and let the empirical distribution be defined by P (a) = 1 α∈X f (α) f (a) = 1 f 1 f (a) = (1/m)f (a). The joint probability P (x 1 , ..., x m | φ) is equal to the product i P (x i | φ) which according to the definitions above is equal to: P (x 1 , ..., x m | φ) = m i=1 p(x i | θ) = a∈X P (a | φ) f (a) . The ML principle is therefore equivalent to the optimization problem: max P ∈Q a∈X P (a | φ) f (a) (2.1) where Q = {q ∈ R n : q ≥ 0, i q i = 1} denote the set of n-dimensional probability vectors (\"probability simplex\"). Let p i stand for P (a i | φ) and f i stand for f (a i ). Since argmax x z(x) = argmax x ln z(x) and given that ln i p f i i = i f i ln p i the solution to this problem can be found by setting the partial derivative of the Lagrangian to zero: L(p, λ, µ) = n i=1 f i ln p i -λ( i p i -1) - i µ i p i , where λ is the Lagrange multiplier associated with the equality constraint i p i -1 = 0 and µ i ≥ 0 are the Lagrange multipliers associated with the inequality constraints p i ≥ 0. We also have the complementary slackness condition that sets µ i = 0 if p i > 0. After setting the partial derivative with respect to p i to zero we get: p i = 1 λ + µ i f i . Assume for now that f i > 0 for i = 1, ..., n. Then from complementary slackness we must have µ i = 0 (because p i > 0). We are left therefore with the result p i = (1/λ)f i . Following the constraint i p 1 = 1 we obtain λ = i f i . As a result we obtain: P (a | φ) = P (a). In case f i = 0 we could use the convention 0 ln 0 = 0 and from continuity arrive to p i = 0. We have arrived to the following theorem: Theorem 1 The empirical distribution estimate P is the unique Maximum Likelihood estimate of the probability model Q on the occurrence frequency f (). This seems like an obvious result but it actually runs deep because the result holds for a very particular (and non-intuitive at first glance) distance measure between non-negative vectors. Let dist(f, p) be some distance measure between the two vectors. The result above states that: P = argmin p dist(f, p) s.t. p ≥ 0, i p i = 1, (2.2) for some (family?) of distance measures dist(). It turns out that there is only one † such distance measure, known as the relative-entropy, which satisfies the ML result stated above. Relative Entropy The relative-entropy (RE) measure D(x||y) between two non-negative vectors x, y ∈ R n is defined as: D(x||y) = n i=1 x i ln x i y i - i x i + i y i . In the definition we use the convention that 0 ln 0 0 = 0 and based on continuity that 0 ln 0 y = 0 and x ln x 0 = ∞. When x, y are also probability vectors, i.e., belong to Q, then D(x||y) = i x i ln x i y i is also known as the Kullback-Leibler divergence. The RE measure is not a distance metric as it is not symmetric, D(x||y) = D(y||x), and does not satisfy the triangle inequality. Nevertheless, it has several interesting properties which make it a fundamental measure in statistical inference. The relative entropy is always non-negative and is zero if and only if x = y. This comes about from the log-sum inequality: i x i ln x i y i ≥ ( i x i ) ln i x i i y i Thus, D(x||y) ≥ ( i x i ) ln i x i i y i - i x i + i y i = x ln x ȳ -x + ȳ † not exactly -the picture is a bit more complex. Csiszar's 1972 measures: dist(p, f) = P i f i φ(p i /f i ) will satisfy eqn. 2.2 provided that φ -1 is an exponential. However, dist(f, p) (parameters positions are switched) will not do it, whereas the relative entropy will satisfy eqn. 2.2 regardless of the order of the parameters p, f. But a ln(a/b) ≥ a -b for a, b ≥ 0 iff ln(a/b) ≥ 1 -(b/a) which follows from the inequality ln(x + 1) > x/(x + 1) (which holds for x > -1 and x = 0). We can state the following theorem: Theorem 2 Let f ≥ 0 be the occurrence frequency on a training sample. P ∈ Q is a ML estimate iff P = argmin p D(f||p) s.t. p ≥ 0, i p i = 1. Proof: D(f||p) = - i f i ln p i + i f i ln f i - i f i + 1, and argmin p D(f||p) = argmax p i f i ln p i = argmax p ln i p f i i . There are two (related) interesting points to make here. First, from the proof of Thm. 1 we observe that the non-negativity constraint p ≥ 0 need not be enforced -as long as f ≥ 0 (which holds by definition) the closest p to f under the constraint i p i = 1 must come out non-negative. Second, the fact that the closest point p to f comes out as a scaling of f (which is by definition the empirical distribution P ) arises because of the relative-entropy measure. For example, if we had used a least-squares distance measure fp 2 the result would not be a scaling of f. In other words, we are looking for a projection of the vector f onto the probability simplex, i.e., the intersection of the hyperplane x 1 = 1 and the non-negative orthant x ≥ 0. Under relative-entropy the projection is simply a scaling of f (and this is why we do not need to enforce non-negativity). Under least-sqaures, a projection onto the hyper-plane x 1 = 1 could take us out of the nonnegative orthant (see Fig. 2 .1 for illustration). So, relative-entropy is special in that regard -it not only provides the ML estimate, but also simplifies the optimization process † (something which would be more noticeable when we handle a latent class model next lecture). Maximum Entropy and Duality ML/MaxEnt The relative-entropy measure is not symmetric thus we expect different outcomes of the optimization min x D(x||y) compared to min y D(x||y). The lat-f p p 2 Fig. 2 .1. Projection of a non-neagtaive vector f onto the hyperplane i x i -1 = 0. Under relative-entropy the projection P is a scaling of f (and thus lives in the probability simplex). Under least-squares the projection p 2 lives outside of the probability simplex, i.e., could have negative coordinates. ter of the two, i.e., min P ∈Q D(P 0 ||P ), where P 0 is some empirical evidence and Q is some model, provides the ML estimation. For example, in the next lecture we will consider Q the set of low-rank joint distributions (called latent class model) and see how the ML (via relative-entropy minimization) solution can be found. Let H(p) =i p i ln p i denote the entropy function. With regard to min x D(x||y) we can state the following observation: Claim 2 argmin p∈Q D(p|| 1 n 1) = argmax p∈Q H(p). Proof: D(p|| 1 n 1) = i p i ln p i + ( i p i ) ln(n) = ln(n) -H(p), which follows from the condition i p i = 1. In other words, the closest distribution to uniform is achieved by maximizing the entropy. To make this interesting we need to add constraints. Consider a linear constraint on p such as i α i p i = β. To be concrete, con-sider a die with six faces thrown many times and we wish to estimate the probabilities p 1 , ..., p 6 given only the average i ip i . Say, the average is 3.5 which is what one would expect from an unbiased die. The Laplace's principle of insufficient reasoning calls for assuming uniformity unless there is additional information (a controversial assumption in some cases). In other words, if we have no information except that each p i ≥ 0 and that i p i = 1 we should choose the uniform distribution since we have no reason to choose any other distribution. Thus, employing Laplace's principle we would say that if the average is 3.5 then the most \"likely\" distribution is the uniform. What if β = 4.2? This kind of problem can be stated as an optimization problem: max p H(p) s.t., i p i = 1, i α i p i = β, where α i = i and β = 4.2. We have now two constraints and with the aid of Lagrange multipliers we can arrive to the result: p i = exp -(1-λ) exp µα i . Note that because of the exponential p i ≥ 0 and again \"non-negativity comes for free\" †. Following the constraint i p i = 1 we get exp -(1-λ) = 1/ i exp µα i from which obtain: p i = 1 Z exp µα i , where Z (a function of µ) is a normalization factor and µ needs to be set by using β (see later). There is nothing special about the uniform distribution, thus we could be seeking a probability vector p as close as possible to some prior probability p 0 under the constraints above: min p D(p||p 0 ) s.t., i p i = 1, i α i p i = β, with the result: p i = 1 Z p 0i exp µα i . We could also consider adding more linear constraints on p of the form: i f ij p i = b j , j = 1, ..., k. The result would be: p i = 1 Z p 0i exp P k j=1 µ j f ij . Probability distributions of this form are called Gibbs Distributions. In † Any measure of the class dist(p, p 0 ) = P i p 0i φ(p i /p 0i ) minimized under linear constraints will satisfy the result of p i ≥ 0 provided that φ -1 is an exponential. practical applications the linear constraints on p could arise from average information about the system such as temperature of a fluid (where p i are the probabilities of the particles moving at various velocities), rainfall data or general environmental data (where p i represent the probability of finding animal colonies at discrete locations in a 3D map). A constraint of the form i f ij p i = b j states that the expectation E p [f j ] should be equal to the empirical distribution β = E P [f j ] where P is either uniform or given as input. Let P = {p ∈ R n : p ≥ 0, i p i = 1, E p [f j ] = E p[f j ], j = 1, ..., k}, and Q = {q ∈ R n ; q is a Gibbs distribution} We could therefore consider looking for the ML solution for the parameters µ 1 , ..., µ k of the Gibbs distribution: min q∈Q D(p||q), where if p is uniform then min D(p||q) can be replaced by max i ln q i (because D((1/n)1||x) = -ln(n) -i ln x i ). As it turns out, the MaxEnt and ML are duals of each other and the intersection of the two sets P ∩ Q contains only a single point which solves both problems. Theorem 3 The following are equivalent: • MaxEnt: q * = argmin p∈P D(p||p 0 ) • ML: q * = argmin q∈Q D(p||q) • q * ∈ P ∩ Q In practice, the duality theorem is used to recover the parameters of the Gibbs distribution using the ML route (second line in the theorem above) -the algorithm for doing so is known as the iterative scaling algorithm (which we will not get into). In Lecture 2 we saw that the Maximum Likelihood (ML) principle over i.i.d. data is achieved by minimizing the relative entropy between a model Q and the occurrence-frequency of the training data. Specifically, let x 1 , .., x m be i.i.d. where each x i ∈ X d is a d-tupple of symbols taken from an alphabet X having n different letters {a 1 , ..., a n }. Let P be the empirical joint distribution, i.e., an array with d dimensions where each axis has n entries, i.e., each entry Pi 1 ,...,i d , where i j = 1, ..., n, represents the (normalized) co-occurrence of the d-tupe a i 1 , ..., a i d in the training set x 1 , ..., x m . We wish to find a joint distribution P * (also a d-array) which belongs to some model family of distributions Q closest as possible to P in relative-entropy: P * = argmin P ∈Q D( P ||P ). In this lecture we will focus on a model of distributions Q which represents mixtures of simple distributions H-known as latent class models. A latent class model arises when the joint probability P (X 1 , ..., X d ) we observe (i.e., from which P is generated by observing samples x 1 , ..., x m ) is in fact a marginal of P (X 1 , ..., X d , Y ) where Y is a \"hidden\" (or \"latent\") random variable which has k different discrete values α 1 , .., α k . Then, P (X 1 , ..., X d ) = k j=1 P (X 1 , ..., X d | Y = α j )P (Y = α j ). The idea is that given the value of the hidden variable H the problem of recovering the model P (X 1 , ..., X d | Y = α j ), which belongs to some family of joint distributions H, is a relatively simple problem. To make this idea clearer we consider the following example: Assume we have two coins. The first coin has a probability of heads (\"0\") equal to p and the second coin has a probability of heads equal to q. At each trial we choose to toss coin 1 with probability λ and coin 2 with probability 1 -λ. Once a coin has been chosen it is tossed 3 times, producing an observation x ∈ {0, 1} 3 . We are given a set of such observations D = {x 1 , ..., x m } where each observation x i is a triplet of coin tosses (the same coin). Given D, we can construct the empirical distribution P which is a 2 × 2 × 2 array defined as: Pi 1 ,i 2 ,i 3 = 1 m |{x i = {i 1 , i 2 , i 3 }, i = 1, ..., m}|. Let y i ∈ {1, 2} be a random variable associated with the observation x i such that y i = 1 if x i was generated by coin 1 and y i = 2 if x i was generated by coin 2. If we knew the values of y i then our task would be simply to estimate two separate Bernoulli distributions by separating the triplets generated from coin 1 from those generated by coin 2. Since y i is not known, we have the marginal: P (x = (x 1 , x 2 , x 3 )) = P (x = (x 1 , x 2 , x 3 ) | y = 1)P (y = 1) + P (x = (x 1 , x 2 , x 3 ) | y = 2)P (y = 2) = λp n i (1 -p) (3-n i ) + (1 -λ)q n i (1 -q) (3-n i ) , (3.1) where (x 1 , x 2 , x 3 ) ∈ {0, 1} 3 is a triplet coin toss and 0 ≤ n i ≤ 3 is the number of heads (\"0\") in the triplet of tosses. In other words, the likelihood P (x) of triplet of tosses x = (x 1 , x 2 , x 3 ) is a linear combination (\"mixture\") of two Bernoulli distributions. Let H stand for Bernoulli distributions: H = {u ⊗d : u ≥ 0, n i=1 u i = 1} where u ⊗d stands for the outer-product of u ∈ R n with itself d times, i.e., an n-way array indexed by i 1 , ..., i d , where i j ∈ {1, ..., n}, and whose value there is equal to u i 1 • • • u i d . The model family Q is a mixture of Bernoulli distributions: Q = { k j=1 λ j P j : λ ≥ 0, j λ j = 1, P j ∈ H}, where specifically for our coin-toss example becomes: Q = {λ p 1 -p ⊗3 + (1 -λ) q 1 -q ⊗3 : λ, p, q ∈ [0, 1]} We see therefore that the eight entries of P * ∈ Q which minimizes D( P ||P ) over the set Q is determined by three parameters λ, p, q. For the coin-toss example this looks like: argmin 0≤λ,p,q≤1 D P || λ p 1 -p ⊗3 + (1 -λ) q 1 -q ⊗3 = argmax 0≤λ,p,q≤1 1 i 1 =0 1 i 2 =0 1 i 3 =0 Pi 1 i 2 i 3 log λp n i 123 (1 -p) (3-n i 123 ) + (1 -λ)q n i 123 (1 -q) (3-n i 123 ) where n i 123 = i 1 + i 2 + i 3 . Trying to work out an algorithm for minimizing the unknown parameters λ, p, q would be somewhat \"unpleasant\" (and even more so for other families of distributions H) because of the log-over-a-sum present in the optimization function -if we could somehow turn this into a sum-over-log our task would be much easier. We would then be able to turn the problem into a succession of problems over H rather than a single problem over Q = j λ j H. Another point worth attention is the nonnegativity of the output variables -simply minimizing the relative-entropy measure under the constraints of the class model Q would not guarantee a non-negative solution. As we shall see, breaking down the problem into a successions of problems over H would give us the \"non-negativity for free\" feature. The technique for turning the log-over-sum into a sum-over-log as part of finding the ML solution for a mixture model is known as the Expectation-Maximization (EM) algorithm introduced by Dempster, Laird and Rubin in 1977. It is based on two ideas: (i) introduce auxiliary variables, and (ii) use of Jensen's inequality. The EM Algorithm: General Let D = {x 1 , ..., x m } represent the training data where x i ∈ X is taken from some instance space X which we leave unspecified. For now, we leave matters to be as general as possible and specifically we do not make independence assumptions on the data generation process. The ML problem is to find a setting of parameters θ which maximizes the likelihood P (x 1 , ..., x m | θ), namely, we wish to maximize P (D | θ) over parameters θ, which is equivalent to maximizing the log-likelihood: θ * = argmax θ log P (D | θ) = log   y P (D, y | θ)   , where y represents the hidden variables. We will denote L(θ) = log P (D | θ). Let q(y | D, θ) be some (arbitrary) distribution of the hidden variables y conditioned on the parameters θ and the input sample D, i.e., y q(y | D, θ) = 1. We define a lower bound on L(θ) as follows: L(θ) = log   y P (D, y | θ)   (3.2) = log   y q(y | D, θ) P (D, y | θ) q(y | D, θ)   (3.3) ≥ y q(y | D, θ) log P (D, y | θ) q(y | D, θ) (3.4) = Q(q, θ). (3.5) The inequality comes from Jensen's inequality log j α j a j ≥ j α j log a j when j α j = 1. What we have obtained is an \"auxiliary\" function Q(q, θ) satisfying L(θ) ≥ Q(q, θ), for all distributions q(y | D, θ). The maximization of Q(q, θ) proceeds by interleaving the variables q and θ as we separately ascend on each set of variables. At the (t + 1) iteration we fix the current value of θ to be θ (t)  of the t'th iteration and maximize Q(q, θ (t) ) over q, and then maximize Q(q (t+1) , θ) over θ: q (t+1) = argmax q Q(q, θ (t) ) (3.6) θ (t+1) = argmax θ Q(q (t+1) , θ). (3.7) The strategy of the EM algorithm is to maximize the lower bound Q(q, θ) with the hope that if we ascend on the lower bound function we will also ascend with respect to L(θ). The claim below guarantees that an ascend on Q will also generate an ascend on L: Claim 3 (Jordan-Bishop) The optimal q(y | D, θ (t) ) at each step is P (y | D, θ (t) ). Proof: We will show that Q(P (y | D, θ (t) ), θ (t) ) = L(θ (t) ) which proves the claim since L(θ) ≥ Q(q, θ) for all q, θ, thus the best q-distribution we can hope to find is one that makes the lower-bound meet L(θ) at θ = θ (t) . Q(P (y | D, θ (t) ), θ (t) ) = y P (y | D, θ (t) ) log P (D, y | θ (t) ) P (y | D, θ (t) ) = y P (y | D, θ (t) ) log P (y | D, θ (t) )P (D | θ (t) ) P (y | D, θ (t) ) = log P (D | θ (t) ) y P (y | D, θ (t) ) = L(θ (t) ) The proof provides also the validity for the approach of ascending along the lower bound Q(q, θ) because at the point θ (t) the two functions coincide, i.e., the lower bound function at θ = θ (t) is equal to L(θ (t) ) therefore if we continue and ascend along Q(•) we are guaranteed to ascend along L(θ) as well † -therefore, convergence is guaranteed. It can also be shown (but omitted here) that the point of convergence is a stationary point of L(θ) (was shown originally by C.F. Jeff Wu in 1983 years after EM was introduced in 1977) under fairly general conditions. The second step of maximizing over θ then becomes: (3.8) θ (t+1) = argmax This defines the EM algorithm. Often the \"Expectation\" step is described as taking the expectation of: E y∼P (y | D,θ (t) ) [log P (D, y | θ)] , followed by a Maximization step of finding θ that maximizes the expectation -hence the term EM for this algorithm. Eqn. 3.8 describes a principle but not an algorithm because in general, without making assumptions on the statistical relationship between the data points and the hidden variable the problem presented in eqn. 3.8 is unwieldy. We will reduce eqn. 3.8 to something more manageable by making the i.i.d. assumption. This is detailed in the following section. EM with i.i.d. Data The EM optimization presented in eqn. 3.8 can be simplified if we assume the data points (and the hidden variable values) are i.i.d. P (D | θ) = n i=1 P (x i | θ), P (D, y | θ) = n i=1 P (x i , y i | θ), and P (y | D, θ) = n i=1 P (y i | x i , θ). For any α(y i ) we have: y α(y i )P (y | D, θ) = y 1 • • • yn α(y i )P (y 1 | x 1 , θ) • • • P (y n | x n , θ) = y i α(y i )P (y i | x i , θ) this is because y j P (y j | x j , θ) = 1. Substituting the simplifications above into eqn. 3.8 we obtain: θ (t+1) = argmax θ k j=1 m i=1 P (y i = α j | x i , θ (t) ) log P (x i , y i = α j | θ) (3.9) where y i ∈ {α 1 , ..., α k }. Back to the Coins Example We will apply the EM scheme to our running example of mixture of Bernoulli distributions. We wish to compute Q(θ, θ (t) ) = y P (y | D, θ (t) ) log P (D, y | θ) = n i=1 2 j=1 P (y i = j | x i , θ (t) ) log P (x i , y i = j | θ), and then maximize Q() with respect to p, q, λ. Q(θ, θ ) = n i=1 P (y i = 1 | x i , θ ) log P (x i | y i = 1, θ)P (y i = 1 | θ) + n i=1 P (y i = 2 | x i , θ ) log P (x i | y i = 2, θ)P (y i = 2 | θ) = i µ i log(λp n i (1 -p) (3-n i ) ) + (1 -µ i ) log((1 -λ)q n i (1 -q) (3-n i ) ) where θ stands for θ (t) and µ i = P (y i = 1 | x i , θ ). The values of µ i are known since θ = (λ o , p o , q o ) are given from the previous iteration. The Bayes formula is used to compute µ i : µ i = P (y i = 1 | x i , θ ) = P (x i | y i = 1, θ )P (y i = 1 | θ ) P (x i | θ ) = λ o p n i o (1 -p o ) (3-n i ) λ o p n i o (1 -p o ) (3-n i ) + (1 -λ o )q n i o (1 -q o ) (3-n i ) We wish to compute: max p,q,λ Q(θ, θ ). The partial derivative with respect to λ is: ∂Q ∂λ = i µ i 1 λ - i (1 -µ i ) 1 1 -λ = 0, from which we obtain the update formula of λ given µ i : λ = 1 k n i=1 µ i . The partial derivative with respect to p is: ∂Q ∂p = i µ i n i p - i µ i (3 -n i ) 1 -p = 0, from which we obtain the update formula: p = 1 i µ i i n i 3 µ i . Likewise the update rule for q is: q = 1 i (1 -µ i ) i n i 3 (1 -µ i ). To conclude, we start with some initial \"guess\" of the values of p, q, λ, compute the values of µ i and update iteratively the values of p, q, λ where at the end of each iteration the new values of µ i are computed. Gaussian Mixture The Gaussian mixture model assumes that P (x) where x ∈ R d is a linear combination of Gaussian distributions P (x) = k j=1 P (x | y = j)P (y = j) where P (x | y = j) = 1 (2π) d/2 σ d j exp - x-c j 2 2σ 2 j , is Normally distributed with mean c j and covariance matrix σ 2 j I. Let D = {x 1 , ..., x m } be the i.i.d sample data and we wish to solve for the mean and covariances of the individual Gaussians (the \"factors\") and the mixing coefficients λ j = P (y = j). In order to make clear where the parameters are located we will write P (x | φ j ) instead of P (x | y = j) where φ j = (c j , σ 2 j ) are the mean and variance of the j'th factor. We denote by θ the collection of mixing coefficients λ j and φ j , j = 1, ..., k. Let w j i be auxiliary variables per point x i and per factor y = j standing for: w j i = P (y i = j | x i , θ). The EM step (eqn. 3.9) is: θ (t+1) = argmax θ={λ,φ} k j=1 m i=1 w j i (t) log (λ j P (x i | φ j )) s.t. j λ j = 1. (3.10) Note the constraint j λ j = 1. The update formula for w j i is done through the use of Bayes formula: w j i (t) = P (y i = j | θ (t) )P (x i | y i = j, θ (t) ) P (x i | θ (t) ) = 1 Z i λ (t) j P (x i | φ (t) ), where Z i is a scaling factor so that j w j i = 1. The update formula for λ j , c j , σ j follow by taking partial derivatives of eqn. (3.10) and setting them to zero. Taking partial derivatives with respect to λ j , c j and σ j we obtain the update rules: λ j = 1 m m i=1 w j i c j = 1 i w j i m i=1 w j i x i , σ 2 j = 1 d i w j i m i=1 w j i x i -c j 2 . In other words, the observations x i are weighted by w j i before a Gaussian is fitted (k times, one for each factor). Application Examples Gaussian Mixture and Clustering The Gaussian mixture model is classically used for clustering applications. In a clustering application one receives a sample of points x 1 , ..., x m where each point resides in R d . The task of the learner (in this case \"unsupervised\" learning) is to group the m points into k sets. Let y i ∈ {1, ..., k} where i = 1, ..., m stands for the required labeling. The clustering solution is an assignment of values to y 1 , ..., y m according to some clustering criteria. In the Gaussian mixture model points are clustered together if they arise from the same Gaussian distribution. The EM algorithm provides a probabilistic assignment P (y i = j | x i ) which we denoted above as w j i . Multinomial Mixture and \"bag of words\" Application The multinomial mixture (the coins example we toyed with) is typically used for representing \"count\" data, such as when representing text documents as high-dimensional vectors. A vector representation of a text document associates a word from a fixed vocabulary to a coordinate entry of the vector. The value of the entry represents the number of times that particular word appeared in the document. If we ignore the order in which the words appeared and count only their frequency, a set of documents d 1 , ..., d m and a set of words w 1 , ...., w n could be jointly represented by a co-occurence n × m matrix G where G ij contains the number of times word w i appeared in document d j . If we scale G such that ij G ij = 1 then we have a distribution P (w, d). This kind of representation of a set of documents is called \"bag of words\". For purposes of search and filtering it is desired to reveal additional information about words and documents such as to which \"topic\" a document belongs to or to which topics a word is associated with. This is similar to a clustering task where documents associated with the same topic are to be clustered together. This can be achieved by considering the topics as the value of a latent variable y: P (w, d) = y P (w, d | y)P (y) = y P (w | y)P (d | y)P (y), where we made the assumption that w⊥d | y (i.e., words and documents are conditionally independent given the topic). The conditional independent assumption gives rise to the multinomial mixture model. To be more specific, ley y ∈ {1, ..., k} denote the k possible topics and let λ j = P (y = j) (note that j λ j = 1), then the latent class model becomes: P (w, d) = k j=1 λ j P (w | y = j)P (d | y = j). Note that P (w | y = j) is a vector which we denote as u j ∈ R n and P (d | y = j) is also a vector we denote by v j ∈ R m . The term P (w | y = j)P (d | y = j) stands for the outer-product u j v j of the two vectors, i.e., is a rank-1 n × m matrix. The Maximum-Likelihood estimation problem is therefore to find vectors u 1 , ..., u k and v 1 , ..., v k and scalars λ 1 , ..., λ k such that the empirical distribution represented by the unit scaled matrix G is as close as possible (in relative-entropy measure) to the low-rank matrix j λ j u j v j subject to the constraints of non-negativity and j λ j = 1, u j and v j are unit-scaled as well (1 u j = 1 v j = 1). Let x i = (w(i), d(i)) stand for the i'th example i = 1, ..., q where an example is a pair of word and document where w(i) ∈ {1, ..., n} is the index to the word alphabet and d(i) ∈ {1, ..., m} is the index to the document. The EM algorithm involves the following optimization step: θ (t+1) = argmax θ q i=1 k j=1 P (y i = j | x i , θ (t) ) log P (x i , y i = j | θ) = argmax θ q i=1 k j=1 w (t) ij log λ j u j,w(i) v j,d(i) s.t. 1 λ = 1 u j = 1 v j = 1 An update rule for u jr (the r'th entry of u j ) is derived below: the derivative of the Lagrangian is: ∂ ∂u jr q i=1 w (t) ij log u j,w(i) -µu jr = ∂ ∂u jr   N (r) log u jr w(i)=r w (t) ij -µu jr   = N (r) w(i)=r w (t) ij u jr -µ = 0 where N (r) stands for the frequency of the word w r in all the documents d 1 , ..., d m . Note that N (r) is the result of summing-up the r'th row of G and that the vector N (1), ..., N (n) is the marginal P (w) = d P (w, d). Given the constraint 1 u j = 1 we obtain the update rule: u jr ← N (r) w(i)=r w (t) ij n s=1 N (s) w(i)=s w (t) ij . Update rules for the remaining unknowns are similarly derived. Once EM has converged, then w(i)=r w * ij is the probability of the word w r to belong to the j'th topic and d(i)=s w * ij is the probability that the s'th document comes from the j'th topic. Support Vector Machines and Kernel Functions In this lecture we begin the exploration of the 2-class hyperplane separation problem. We are given a training set of instances x i ∈ R n , i = 1, ..., m, and class labels y i = ±1 (i.e., the training set is made up of \"positive\" and \"negative\" examples). We wish to find a hyperplane direction w ∈ R n and an offset scalar b such that w • x i -b > 0 for positive examples and w • x i -b < 0 for negative examples -which together means that the margins y i (w • x i -b) > 0 are positive. Assuming that such a hyperplane exists, clearly it is not unique. We therefore need to introduce another constraint so that we could find the most \"sensible\" solution among all (infinitley many) possible hyperplanes which separate the training data. Another issue is that the framework is very limited in the sense that for most real-world classification problems it is somewhat unlikely that there would exist a linear separating function to begin with. We therefore need to find a way to extend the framework to include non-linear decision boundaries at a reasonable cost. These two issues will be the focus of this lecture. Regarding the first issue, since there is more than one separating hyperplane (assuming the training data is linearly separable) then the question we need to ask ourselves is among all those solutions which of them has the best \"generalization\" properties? In other words, our goal in constructing a learning machine is not necessarily to do very well (or perfect) on the training data, because the training data is merely a sample of the instance space, and not necessarily a \"representative\" sample -it is simply a sample. Therefore, doing well on the sample (the training data) does not necessarily guarantee (or even imply) that we will do well on the entire instance space. The goal of constructing a learning machine is to maximize the performance on the test data (the instances we haven't seen), which in turn means that we wish to generalize \"good\" classification performance on the training set onto the entire instance space. A related issue to generalization is that the distribution used to generate the training data is unknown. Unlike the statistical inference material we had so far, this time we will not attempt to estimate the distribution. The reason one can derive optimal learning algorithms yet bypass the need for estimating distributions would be explained later in the course when PAClearning will be introduced. For now we will focus only on the algorithmic aspect of the learning problem. The idea is to consider a subset C γ of all hyperplanes which have a fixed margin γ where the margin is defined as the distance of the closest training point to the hyperplane: γ = min i y i (w x i -b) w . The Support Vector Machine (SVM), first introduced by Vapnik and his colleagues in 1992, seeks a separating hyperplane which simultaneously minimizes the empirical error and maximizes the margin. The idea of maximizing the margin is intuitively appealing because a decision boundary which lies close to some of the training instances is less likely to generalize well because the learning machine will be susceptible to small perturbations of those instance vectors. A formal motivation for this approach is deferred to the PAC-learning material we will introduce later in the course. Large Margin Classifier as a Quadratic Linear Programming We would first like to set up the linear separating hyperplane as an optimization problem which is both consistent with the training data and maximizes the margin induce by the separating hyperplane over all possible consistent hyperplanes. Formally speaking, the distance between a point x and the hyperplane is defined by | w • x -b | √ w • w . Since we are allowed to scale the parameters w, b at will (note that if w • x -b > 0 so is (λw) • x -(λb) > 0 for all λ > 0) we can set the distance between the boundary points to the hyperplane to be 1/ √ w • w by scaling w, b such the point(s) with smallest margin (closest to the hyperplane) will be normalized: | w • x -b |= 1, therefore the margin is simply 2/ √ w • w (see Fig. 5.1). Note that argmax w 2/ √ w • w is equivalent to argmax w 2/(w • w) which in turn is equivalent to argmin w 1 2 w • w. Since all positive points and negative points should be farther away from the boundary points we also have the separability constraints w • x -b ≥ 1 when x is a positive instance and w • x -b ≤ -1 when x is a negative instance. Both separability constraints can be combined: y(w • x -b) ≥ 1. Taken together, we have defined the following optimization problem: min w,b 1 2 w • w (4.1) subject to y i (w • x i -b) -1 ≥ 0 i = 1, ..., m (4.2) This type of optimization problem has a quadratic criteria function and linear inequalities and is known in the literature as a Quadratic Linear Programming (QP) type of problem. This particular QP, however, requires that the training data are linearly separable -a condition which may be unrealistic. We can relax this condition by introducing the concept of a \"soft margin\" in which the separability holds approximately with some error: min w,b, i 1 2 w • w + ν l i=1 i (4.3) subject to y i (w • x i -b) ≥ 1 -i i = 1, ..., m i ≥ 0 Where ν is some pre-defined weighting factor. The (non-negative) variables i allow data points to be miss-classified thereby creating an approximate separation. Specifically, if x i is a positive instance (y i = 1) then the \"soft\" constraint becomes: w • x i -b ≥ 1 -i , where if i = 0 we are back to the original constraint where x i is either a boundary point or laying further away in the half space assigned to positive instances. When i > 0 the point x i can reside inside the margin or even in the half space assigned to negative instances. Likewise, if x i is a negative instance (y i = -1) then the soft constraint becomes: The criterion function penalizes (the L 1 -norm) for non-vanishing i thus the overall system will seek a solution with few as possible \"margin errors\" (see Fig. 5 .1). Typically, when possible, an L 1 norm is preferable as the L 2 norm overly weighs high magnitude outliers which in some cases can dominate the energy function. Another note to make here is that strictly speaking the \"right thing\" to do is to penalize the margin errors based on the L 0 norm 0 0 = |{i : i > 0}|, i.e., the number of non-zero entries, and drop the balancing parameter ν. This is because it does not matter how far away a point is from the hyperplane -all what matters is whether a point is classified correctly or not (see the definition of empirical error in Lecture 4). The problem with that is that the optimization problem would no longer be convex and non-convex problems are notoriously difficult to solve. Moreover, the class of convex optimization problems (as the one described in Eqn. 4.3) can be solved in polynomial time complexity. w • x i -b ≤ -1 + i . ) , ( b w maximize the margin | | 2 w 0 > i ! 0 > i µ 0 = j µ So far we have described the problem formulation which when solved would provide a solution with \"sensible\" generalization properties. Although we can proceed using an off-the-shelf QLP solver, we will first pursue the \"dual\" problem. The dual form will highlight some key properties of the approach and will enable us to extend the framework to handle non-linear decision surfaces at a very little cost. In the appendix we take a brief tour on the basic principles associated with constrained optimization, the Karush-Kuhn-Tucker (KKT) theorem and the dual form. Those are recommended to read before moving to the next section. The Support Vector Machine We return now to the primal problem (eqn. 6.3) representing the maximal margin separating hyperplane with margin errors: min w,b, i 1 2 w • w + ν l i=1 i subject to y i (w • x i -b) ≥ 1 -i i = 1, ..., m i ≥ 0 We will now derive the Lagrangian Dual of this problem. By doing so a new key property will emerge facilitated by the fact that the criteria function θ(µ) (note there are no equality constraints thus there is no need for λ) involves only inner-products of the training instance vectors x i . This property will form the key of mapping the original input space of dimension n to a higher dimensional space thereby allowing for non-linear decision surfaces for separating the training data. Note that with this particular problem the strong duality conditions are satisfied because the criteria function and the inequality constraints form a convex set. The Lagrangian takes the following form: L(w, b, i , µ) = 1 2 w • w + ν m i=1 i - m i=1 µ i [y i (w • x i -b) -1 + i ] - m i=1 δ i i Recall that θ(µ) = min w,b, L(w, b, , µ, δ). Since the minimum is obtained at the vanishing partial derivatives of the Lagrangian with respect to w, b, the next step would be to evaluate those constraints and substitute them back into L() to obtain θ(µ): ∂L ∂w = w - i µ i y i x i = 0 (4.4) ∂L ∂b = i µ i y i = 0 (4.5) ∂L ∂ i = ν -µ i -δ i = 0 (4.6) From the first constraint (4.4) we obtain w = i µ i y i x i , that is, w is described by a linear combination of a subset of the training instances. The reason that not all instances participate in the linear superposition is due to the KKT conditions: µ i = 0 when y i (w • x i -b) > 1, i.e. , the instance x i is classified correctly and is not a boundary point, and conversely, µ i > 0 when y i (w • x i -b) = 1 -i , i.e. , when x i is a boundary point or when x i is a margin error ( i > 0) -note that for a margin error instance the value of i would be the smallest possible required to reach an equality in the constraint because the criteria function penalizes large values of i . The boundary points (and the margin errors) are called support vectors thus w is defined by the support vectors only. The third constraint (4.6) is equivalent to the constraint: 0 ≤ µ i ≤ ν i = 1, ..., l, since δ i ≥ 0. Also note that if i > 0, i.e., point x i is a margin-error point, then by KKT conditions we must have δ i = 0. As a result µ i = ν. Therefore based on the values of µ i alone we can make the following classifications: • 0 < µ i < ν: point x i is on the margin and is not a margin-error. • µ i = ν: points x i is a margin-error point. • µ i = 0: point x i is not on the margin. Substituting these results/constraints back into the Lagrangian L() we obtain the dual problem: max µ 1 ,...,µm θ(µ) = m i=1 µ i - 1 2 i,j µ i µ j y i y j x i • x j (4.7) subject to 0 ≤ µ i ≤ ν i = 1, ..., m m i=1 y i µ i = 0 The criterion function θ(µ) can be written in a more compact manner as follows: Let M be a l × l matrix whose entries are M ij = y i y j x i • x j then θ(µ) = µ 1 -1 2 µ M µ where 1 is the vector of (1, ..., 1) and µ is the vector (µ 1 , ..., µ m ) and µ is the transpose (row vector). Note that M is positive definite, i.e., x M x > 0 for all vectors x = 0 -a property which will be important later. The key feature of the dual problem is not so much that it is simpler than the primal (in fact it isn't since the primal has no equality constraints) or that it has a more \"elegant\" feel, the key feature is that the problem is completely described by the inner products of the training instances x i , i = 1, ..., m. This fact will be shown to be a crucial ingredient in the so called \"kernel trick\" for the computation of inner-products in high dimensional spaces using simple functions defined on pairs of training instances. The Kernel Trick We ended with the dual formulation of the SVM problem and noticed that the input data vectors x i are represented by the Gram matrix M . In other words, only inner-products of the input vectors play a role in the dual formulation -there is no explicit use of x i or any other function of x i besides inner-products. This observation suggests the use of what is known as the \"kernel trick\" to replace the inner-products by non-linear functions. The common principle of kernel methods is to construct nonlinear variants of linear algorithms by substituting inner-products by nonlinear kernel functions. Under certain conditions this process can be interpreted as mapping of the original measurement vectors (so called \"input space\") onto some higher dimensional space (possibly infinitely high) commonly referred to as the \"feature space\". Mathematically, the kernel approach is defined as follows: let x 1 , ..., x l be vectors in the input space, say R n , and consider a mapping φ(x) : R n → F where F is an inner-product space. The kernel-trick is to calculate the inner-product in F using a kernel function k : R n × R n → R, k(x i , x j ) = φ(x i ) φ(x j ), while avoiding explicit mappings (evaluation of) φ(). Common choices of kernel selection include the d'th order polynomial kernels k(x i , x j ) = (x i x j + θ) d and the Gaussian RBF kernels k(x i , x j ) = exp(-1 2σ 2 x i -x j 2 ). If an algorithm can be restated such that the input vectors appear in terms of inner-products only, one can substitute the innerproducts by such a kernel function. The resulting kernel algorithm can be interpreted as running the original algorithm on the space F of mapped objects φ(x). We know that M of the dual form is positive semi-definite because M can be written is M = Q Q where Q = [y 1 x 1 , ..., y l x l ]. Therefore x M x = Qx 2 ≥ 0 for all choices of x (which means that the eigenvalues of M are non-negative). If the entries of M are to be replaced with y i y j k(x i , x j ) then the condition we must enforce on the function k() is that it is a positive definite kernel function. A positive definite function is defined such that for any set of vectors x 1 , ..., x q and for any values of q the matrix K whose entries are K ij = k(x i , x j ) is positive semi-definite. Formally, the conditions for admissible kernels k() are known as Mercer's conditions summarized below: Theorem 4 (Mercer's Conditions) Let k(x, y) be symmetric and continuous. The following conditions are equivalent: (i) k(x, y) = ∞ i=1 α i φ i (x)φ i (y) = φ(x) φ(y) for any uniformly converg- ing series α i > 0. (ii) for all ψ() satisfying x ψ 2 (x)dx < ∞, then x y k(x, y)ψ(x)ψ(y)dxdy ≥ 0 (iii) for all {x i } q i=1 and for all q, the matrix K ij = k(x i , x j ) is positive semi-definite. Perhaps the non-obvious condition is No. 1 which allows for the feature map φ() to have infinitely many coordinates (a vector in Hilbert space). For example, as we shall see below, the kernel exp(- 1 2σ 2 x i -x j 2 ) is an innerproduct of two vectors with infinitely many coordinates. We will consider next a number of popular kernels. The Homogeneous Polynomial Kernel Let x, y ∈ R k and define k(x, y) = (x y) d where d > 0 is a natural number. Then, the corresponding feature map φ(x) has k+d-1 d = O(k d ) coordinates which take the value: φ(x) = d n 1 , ..., n k x n 1 1 • • • x n k k n i ≥0, P i n i =d where d n 1 ,...,n k = d!/(n 1 ! • • • n k !) is the multinomial coefficient (number of ways to distribute d balls into k bins where the j'th bin hold exactly n j ≥ 0 balls): (x 1 + ... + x k ) d = n i ≥0, P i n i =d d n 1 , ..., n k x n 1 1 • • • x n k k . The dimension of the vector space φ(x) where x ∈ R k can be measured using the following combinatorial problem: how many arrangements of k -1 partitions to be placed among d items? the answer is k+d-1 k-1 = k+d-1 d = O(k d ). For example, k = d = 2 gives us : (x y) 2 = x 2 1 y 2 1 + 2x 1 x 2 y 1 y 2 + x 2 2 y 2 2 = φ(x) φ(y), where φ(x) = (x 2 1 , x 2 2 , √ 2x 1 x 2 ). The non-homogeneous Polynomial Kernel The feature map φ(x) contains all monomials whose power is lesser or equal to d, i.e., i n i ≤ d. This can be acheived by increasing the dimension to k + 1 where n k+1 is used to fill the gap between k i=1 n i < d and d. Therefore the dimension of φ(x) where x ∈ R k would be k+d d . We have: (x y + θ) d = (x 1 y 1 + ... + x k y k + √ θ √ θ) d = n i ≥0, P k+1 i=1 n i =d d n 1 , ..., n k+1 x n 1 1 y n 1 1 • • • x n k 1 y n k 1 • θ n k+1 /2 θ n k+1 /2 Therefore, the entries of the vector φ(x) take the values: φ(x) = d n 1 , ..., n k+1 x n 1 1 • • • x n k k • θ n k+1 /2 n i ≥0, P k+1 i=1 n i =d For example, k = d = 2 gives us : (x y + θ) 2 = x 2 1 y 2 1 + 2x 1 x 2 y 1 y 2 + x 2 2 y 2 2 + 2θx 1 y 1 + 2θx 2 y 2 + θ = φ(x) φ(y), where φ(x) = (x 2 1 , x 2 2 , √ 2x 1 x 2 , √ 2θx 1 , √ 2θx 2 , √ θ). In this example, φ() is a mapping from R 2 to R 6 and hyperplanes φ(w) φ(x)-b = 0 in R 6 correspond to conics in R 2 : (w 2 1 )x 2 1 + (w 2 2 )x 2 + (2w 1 w 2 )x 1 x 2 + (2θw 1 )x 1 + (2θw 2 )x 2 + (θ -b) = 0 Assume we would like to find a separating conic (Parabola, Hyperbola, Ellipse) function rather than a line in R 2 . The discussion so far suggests we construct the Gram matrix M in the dual form with the d = 2 polynomial kernel k(x, y) = (x y+θ) 2 for some parameter θ of our choosing. The extra effort we will need to invest is negligible -simply replace every occurrence x i x j with (x i x j + θ) 2 . The RBF Kernel The function k(x, y) = e -x-y 2 /2σ 2 known as a Radial Basis Function (RBF) is a kernel function but with an infinite expansion. Without loss of generality let σ = 1, then we have: e -x-y 2 /2 = e -x 2 /2 e -y 2 /2 e x y = ∞ j=0 (x y) j j! e -x 2 /2 e -y 2 /2 = ∞ j=0   e -x 2 2j √ j! 1/j e -y 2 2j √ j! 1/j x y   j = ∞ j=0 P i n i =j e -x 2 2j √ j! 1/j j n 1 , ..., n k 1/2 x n 1 1 • • • x n k k e -y 2 2j √ j! 1/j j n 1 , ..., n k 1/2 y n 1 1 • • • y n k k From which we can see that the entries of the feature map φ(x) are: φ(x) =   e -x 2 2j √ j! 1/j j n 1 , ..., n k 1/2 x n 1 1 • • • x n k k   j=0,..,∞, P k i=1 n i =j Classifying New Instances By adopting some kernel k() we are in fact mapping x → φ(x), thus we then proceed to solve for φ(w) and b using some QLP solver. The QLP solution of the dual form will yield the solution for the Lagrange multipliers µ 1 , ..., µ m . We saw from eqn. (4.4) that we can express φ(w) as a function of the (mapped) examples: φ(w) = i µ i y i φ(x i ). Rather than explicitly representing φ(w) -a task which may be prohibitly expensive since in general the dimension of the feature space of a polynomial mapping is k+d d -we store all the support vectors (those input vectors with corresponding µ i > 0) and use them for the evaluation of test examples: f (x) = sign(φ(w) φ(x) -b) = sign( i µ i y i φ(x i ) φ(x) -b) = sign( i µ i y i k(x i , x) -b). We see that the kernel trick enabled us to look for a non-linear separating surface by making an implicit mapping of the input space onto a higher dimensional feature space using the same dual form of the SVM formulationthe only change required was in the way the Gram matrix was constructed. The price paid for this convenience is to carry all the support vectors at the time of classification f (x). A couple of notes may be worthwhile at this point. The constant b can be recovered from any of the support vectors. Say, x + is a positive support vector (but not a margin error, i.e., µ i < ν). Then φ(w) φ(x + ) -b = 1 from which b can be recovered. The second note is that the number of support vectors is typically around 10% of the number of training examples (empirically). Thus the computational load during evaluation of f (x) may be relatively high. Approximations have been proposed in the literature by looking for a reduced number of support vectors (not necessarily aligned with the training set) -but this is beyond the scope of this course. The kernel trick gained its popularity with the introduction of the SVM but since then has taken a life of its own and has been applied to principal component analysis (PCA), ridge regression, canonical correlation analysis (CCA), QR factorization and the list goes on. We will meet again with the kernel trick later on. Spectral Analysis I: PCA, LDA, CCA In this lecture (and the following one) we will focus on spectral methods for learning. Today we will focus on dimensionality reduction using Principle Component Analysis (PCA), multi-class learning using Linear Discriminant Analysis (LDA) and Canonical Correlation Analysis (CCA). In the next lecture we will focus on spectral clustering methods. Dimensionality reduction appears when the dimension of the input vector is very large (imagine pixels in an image, for example) while the coordinate measurements are highly inter-dependent (again, imagine the redundancy present among neighboring pixels in an image). High dimensional data impose computational efficiency challenges and often translate to poor generalization abilities of the learning engine (see lectures on PAC). A dimensionality reduction can also be viewed as a feature extraction process where one takes as input a large feature set (the original measurements) and creates from them a much smaller number of new features which are then fed into the learning engine. In this lecture we will focus on feature extraction from a very specific (and constrained) stanpoint. We would be looking for a mixing (linear combination) of the input coordinates such that we obtain a linear projection from R n to R q for some q < n. In doing so we wish to reduce the redundancy while preserving as much as possible the variance of the data. From a statistical standpoint this is achieved by transforming to a new set of variables, called principal components, which are uncorrelated so that the first few retain most of the variation present in all of the original coordinates. For example, in an image processing application the input images are highly redundant where neighboring pixel values are highly correlated. The purpose of feature extraction would be to transform the input image into a vector of output components with the least redundancy possible. Form a geometric standpoint, this is achieved by finding the \"closest\" (in least squares sense) linear q-dimensional susbspace to the m sample points S. The new subspace is a lower dimensional \"best approximation\" to the sample S. These two, equivalent, perspectives on data compression (dimensionality reduction) form the central idea of principal component analysis (PCA) which probably the oldest (going back to Pearson 1901) and best known of the techniques of multivariate analysis in statistics. The computation of PCA is very simple and the definition is straightforward, but has a wide variety of different applications, a number of different derivations, quite a number of different terminologies (especially outside the statistical literature) and is the basis for quite a number of variations on the basic technique. We then extend the variance preserving approach for data representation for labeled data sets. We will describe the linear classifier approach (separating hyperplane) form the point of view of looking for a hyperplane such that when the data is projected onto it the separation is maximized (the distance between the class means is maximal) and the data within each class is compact (the variance/spread is minimized). The solution is also produced, just like PCA, by a spectral analysis of the data. This approach goes under the name of Fisher's Linear Discriminant Analysis (LDA) . What is common between PCA and LDA is (i) the use of spectral matrix analysis -i.e., what can you do with eigenvalues and eigenvectors of matrices representing subspaces of the data? (ii) these techniques produce optimal results for normally distributed data and are very easy to implement. There is a large variety of uses of spectral analysis in statistical and learning literature including spectral clustering, Multi Dimensional Scaling (MDS) and data modeling in general. Another point to note is that this is the first time in the course where the type of data distribution plays a role in the analysis -the two techniques are defined for any distribution but are optimal only under the Gaussian distribution. We will also describe a non-linear extension of PCA known as Kernel-PCA, but the focus would be mostly on PCA itself and its analysis from a couple of vantage points: (i) PCA as an optimal reconstruction after a dimension reduction, i.e., data compression, and (ii) PCA for redundancy reduction (decorrelation) of the output components. PCA: Statistical Perspective Let x 1 , ..., x m ∈ R n be our sample data S of vectors in R n , arranged as columns of a matrix A. It will be convenient to assume that the data is centered, i.e., x i = 0. If the data is not centered we can always center it by computing the mean vector µ = (1/m) i x i and replace the original data sample with the new sample x i -µ. In a statistical sense, the coordinates of the vector x ∈ R n are considered as random variables, thus a row in the matrix A is the sample of values of a particular random variable, drawn from some unknown probability distribution, associated with the row position. We wish to find vectors u 1 , ..., u q (arranged as columns of a matrix U ), where q ≤ min(n, m), such that the new feature measurements y = U x (who are the result of linear combinations u 1 x, ..., u q x of the original feature measurements x) have certain desirable properties. The idea property to seek from the new coordinates y is statistical independence, i.e., P (y 1 , .., y q ) = P (y 1 ) • • • P (y q ) which would mean that we have removed the redundancy of the original data x in the best possible manner. This goal, however, is too much to ask from a linear transformation and instead we would ask for a weaker property to hold: that the pairwise covariance cov(y i , y j ) = 0 vanishes, i.e., that the covariance matrix on the new coordinates is diagonal. A diagonal covariance insures some redundancy removal, but not as good as statistical independence. However, when the data is Normally distributed P (x) ∼ N (µ, Σ) with mean µ and covariance Σ, then the transformation which diagonalizes the covariance matrix also guarantees statistical independence. Among all transformations that de-correlate the data we will seek the one that maximizes the spread (variance) of the sample data after being projected onto the new axes vectors. Maximizing the Variance of Output Coordinates The property we would like to maximize is that the projection of the sample data on the new axes is as spread as possible. To start this analysis, assume q = 1, i.e., the n components of the input vector x are reduced to a single output component y = u x. We are looking for a single vector u ∈ R n whose direction maximizes the variance of the output component y. Formally, we are looking for a unit vector u which maximizes i (u x i ) 2 (see Appendix A for basic statistical definitions and note that E[y] = 0 because i u x i = u i ( i x i ) = 0). In other words, the projected points onto the axis represented by the vector u are as spread as possible (in a least squares sense). In vector notation, the optimization problem takes the following form: max u 1 2 u A 2 subject to 1 2 u u = 1 The Lagrangian of the problem is: L(u, λ) = 1 2 u AA u -λ( 1 2 u u -1) By taking the partial derivative ∂L/∂u = 0 we obtain the following necessary condition (see Appendix B): AA u = λu, which tells us that u is an eigenvector of the n × n (symmetric and positive definite) matrix AA . There are n eigenvectors associated with AA and we can easily convince ourselves that we are looking for the one associated with the maximal eigenvalue: substitute λu instead of AA u in the criterion function u AA u to obtain λ(u u) = λ and since the eigenvalues must be positive (since AA is positive definite), then the optimum is obtained for the maximal eigenvalue. The leading eigenvector u of AA is called the first principal axis of the data sample represented by the columns of the matrix A, and y = u x is called the first principal component of the data sample. For convenience, we denote u 1 = u and λ 1 = λ as the leading eigenvector and eigenvalue of AA . Next, we look for y 2 = u 2 x which is uncorrelated with y 1 = u 1 x and which has maximum variance (and so on for u 3 , ..., u q ). Two random variables are uncorrelated if their covariance vanishes. By definition of covariance (see Appendix A) we obtain: Cov(y 1 y 2 ) = i (u 1 x i )(u 2 x i ) = u 1 ( i x i x i )u 2 = u 1 AA u 2 = u 2 AA u 1 = λ 1 u 1 u 2 = 0 We can therefore use the condition u 1 u 2 = 0 to specify zero correlation between y 1 , y 2 . The functional to be optimized becomes: max u 2 1 2 u 2 A 2 subject to 1 2 u 2 u 2 = 1, u 1 u 2 = 0, with the Lagrangian being: L(u 2 , λ, δ) = 1 2 u 2 AA u 2 -λ( 1 2 u 2 u 2 -1) -δu 1 u 2 . By taking the partial derivative with respect to u 2 we obtain the necessary condition: AA u 2 -λu 2 -δu 1 = 0. Multiply the equation by u 1 from the left: u 1 AA u 2 -λu 1 u 2 -δu 1 u 1 = 0, and noting from above that u 1 AA u 2 = u 1 u 2 = 0 we obtain δ = 0. As a result we obtain: AA u 2 = λu 2 , so once more we have that λ, u 2 form an eigenvalue/eigenvector pair of AA . As before, λ should be as large as possible from the remaining spectral decomposition. By induction, it can be shown that the remaining principal vectors u 3 , ..., u q are the decreasing order eigenvactors of AA and the variance of the i'th principal component y i = u i x is λ i . Taken together, the PCA is the solution of the following optimization problem: max u 1 ,...,uq 1 2 i u i A 2 subject to u i u i = 1, u i u j = 0, i = j = 1, ..., q. It will be useful for later to write the optimization function in a more concise manner as follows. Let U be the n × q matrix whose columns are u i and D = diag(λ 1 , ..., λ q ) is an q×q diagonal matrix and λ 1 ≥ λ 2 ≥ ... ≥ λ q . Then from above we have that U U = I and AA U = U D. Using the fact that trace(xy ) = x y, trace(AB) = trace(BA) and trace(A+B) = trace(A)+ trace(B) we can convert i u i A 2 to trace(U AA U ) as follows: i u i AA u i = i trace(A u i u i A) = trace(A ( i u i u i )A) = trace(A U U A) = trace(U AA U ) Thus, PCA becomes the solution of the following optimization function: max U ∈R n×q trace(U AA U ) subject to U U = I. (5.1) The solution, as saw above, is that U = [u 1 , ..., u q ] consists of the decreasing order eigenvectors of AA . At the optimum, trace(U AA U ) is equal to trace(D) which is equal to the sum of eigenvalues λ 1 + ... + λ q . It is worthwhile noting that when q = n, U U = U U = I, and the PCA transform is a change of basis in R n known as Karhunen-Loeve transform. To conclude, the PCA transform looks for q orthogonal direction vectors (called the principal axes) such that the projection of input sample vectors onto the principal directions has the maximal spread, or equivalently that the variance of the output coordinates y = U x is maximal. The principal directions are the leading (with respect to descending eigenvalues) q eigenvectors of the matrix AA . When q = n, the principal directions form a basis of R n with the property of de-correlating the data and maximizing the variance of the coordinates of the sample input vectors. Decorrelation: Diagonalization of the Covariance Matrix In the previous section we saw that PCA generates a new coordinate system y = U x where the coordinates y 1 , ..., y q of x in the new system are uncorrelated. This means that the covariance matrix over the principle components should be diagonal. In this section we will explore this perspective in more detail. The covariance matrix Σ x of the sample data x 1 , ..., x m with zero mean is (1/m) i x i x i = (1/m)AA , therefore the matrix AA we derived above is a scaled version of the covariance of the sample data (see Appendix A). The scale factor 1/m was unimportant in the process above because the eigenvectors are of unit norm, thus any scale of AA would produce the same set of eigenvectors. The off-diagonal entries of the covariance matrix Σ x represent the correlation (a measure of statistical dependence) between the i'th and j'th component vectors, i.e., the entries of the input vectors x. The existence of correlations among the components (features) of the input signal is a sign of redundancy, therefore from the point of view of transforming the input representation into one which is less redundant, we would like to find a transformation y = U x with an output representation y which is associated with a diagonal covariance matrix Σ y , i.e., the components of y are uncorrelated. Formally, Σ y = (1/m) i y i y i = (1/m)U AA U , therefore we wish to find an n × q matrix for which U AA U is diagonal. If in addition, we would require that the variance of the output coordinates is maximized, i.e., trace(U AA U ) is maximal (but then we need to constrain the length of the column vectors of U , i.e., set u i = 1) then we would get a unique solution for U where the columns are orthonormal and are defined as the first q eigenvectors of the covariance matrix Σ x . This is exactly the optimization problem defined by eqn. (5.1). We see therefore that PCA \"decorrelates\" the input data. Decorrelation and statistical independence are not the same thing. If the coordinates are statistically independent then the covariance matrix is diagonal †, but it does not follow that uncorrelated variables must be statistically independentcovariance is just one measure of dependence. In fact, the covariance is a measure of pairwise dependency only. However, it is a fact that uncorrelated † σxy = P x P y (x -µx)(y -µy)p(x, y) = P x P y (x -µx)(y -µy)p(x)(p(y) = ( P x (x - µx)p(x))( P y (y -µy)p(y)) = 0 variables are statistically independent if they have a multivariate normal distribution (a Gaussian). In other words, if the sample data x are drawn from a probability distribution p(x) which has Gaussian form, the PCA transforms the sample data into a statistically independent set of variables y = U x. The details are explained below. Recall that a multivariate normal distribution of the random variables x = (x 1 , ..., x n ) is defined as p(x) ≈ N (µ, Σ): p(x) = 1 (2π) n/2 |Σ| 1/2 e -1 2 (x-µ) Σ -1 (x-µ) . Also recall that a linear combination of the variables produces also a normal distribution N (U µ, U ΣU ): Σ y = y (y -µ y )(y -µ y ) = x (U x -U µ x )(U x -U µ x ) = U Σ x U, therefore choose U such that Σ y = U ΣU is a diagonal matrix Σ y = diag(σ 2 1 , ..., σ 2 n ). We have in that case: p(x) = 1 (2π) n/2 i σ i e -1 2 P i \" x i -µ i σ i \" 2 which can be written as a product of univariate normal distributions p x i (x i ): p(x) = n i=1 1 (2π) 1/2 σ i e -1 2 \" x i -µ i σ i \" 2 = n i=1 p x i (x i ), which proves the assertion that decorrelated normally distributed variables are statistically independent. PCA: Optimal Reconstruction A different, yet equivalent, perspective on the PCA transformation is as an optimal reconstruction (in a least squares sense) after a dimension reduction. We are given a sample data as before x 1 , ..., x m and we are looking for a small number of orthonormal principal vectors u 1 , ..., u q where q < min(n, k) which define a q-dimensional linear subspace of R n which best approximate the original input vectors in a least squares sense. In other words, the projection xi of the sample points x i onto the q-dimensional subspace should minimize i x i -xi 2 over all possible q-dimensional subspaces of R n . Let U be the subspace spanned by the principal vectors (columns of U ) and let P be the n × n projection matrix mapping a point x ∈ R n onto its projection x ∈ U. From the definition of projection, the vector xx must be orthogonal to the subspace U. Let y = (y 1 , ..., y q ) be the coordinates of x with respect to the principal vectors, i.e., U y = x. Then, from orthogonality we have that (x -U y) U w = 0 for all vectors w ∈ R n . Since this is true for all w then U U y -U x = 0. Therefore, y = (U U ) -1 U x and as a result the projection matrix P becomes: P = U (U U ) -1 U , satisfying P x = x. In the case the columns of U are orthonormal, U U = I, we have P = U U . We are ready now to describe the optimization problem on U : we wish to find an orthonormal set of principal vectors, U U = I, such that i x i -U U x i 2 is minimized. Note that i x i -U U x i 2 = A -U U A 2 F where B 2 F = i,j b 2 ij is the square Frobenious norm of a matrix. The optimal reconstruction problem therefore becomes: min U A -U U A 2 F subject to U U = I. We will show now that: argmin U A -U U A 2 F = argmax U trace(U AA U ), which shows that the optimal reconstruction problem is solved by PCA (recall Eqn. 5.1). From the identity B 2 F = trace(BB ), we have: A -U U A 2 F = trace((A -U U A)(A -U U A) ). Expanding the right hand side gives us: trace((A -U U A)(A -U U A) ) = trace(AA ) -trace(AA U U ) -trace(U U AA ) + trace(U U AA U U ) The second and third term are equal (commutativity of trace) and is also equal to the 4th term due to commutativity of the trace and U U = I. Taken together: A -U U A 2 F = trace(AA ) -trace(U AA U ). To conclude, we have proven that by taking the first q eigenvectors of AA we obtain a linear subspace which is as close as possible (in a least squares sense) to the original sample data. Hence, PCA can be viewed as a vehicle for optimal reconstruction after dimension reduction. The optimization problem whose solution is the leading q eigenvectors of AA is described in eqn. 5.1: max U ∈R n×q trace(U AA U ) subject to U U = I. The Case n >> m Consider the situation where n, the dimension of the input vectors, is relatively large compared to the number of sample vectors m. For example, consider input vectors representing 50 × 50 sized images of faces, i.e., n = 2500, where m = 100. In other words, we are looking for a small number of \"face templates\" (known as \"eigenfaces\") which approximate well the original set of 100 face images. In this case, AA is very large, 2500×2500, yet the number of non-vanishing eigenvalues cannot be higher than 100. Given that the eigendecomposition process is O(2500 3 ), the computational burden would be very high. However, it is possible to perform an eigendecomposition on A A (a 100 × 100 matrix) instead, as shown next. Let the columns of Q be the first q < m eigenvectors of A A, i.e., A AQ = QD where D is diagonal containing the corresponding eigenvalues. After pre-multiplying both sides by A we obtain: AA (AQ) = (AQ)D, from which we conclude that AQ contains the first q eigenvectors (but unnormalized) of AA . We have therefore that U = AQD -1 2 because: U U = D -1 2 Q A AQD -1 2 = D -1 2 DD -1 2 = I, where we used the fact that Q A AQ = D. Note that eigenvalues of A A and AA are the same (because AA (AQD -1 2 ) = (AQD -1 2 )D). Kernel PCA We can take the case n >> m described in the previous section one step further and consider such large values of n which are practically uncomputable -a situation which results when mapping the original input vectors to a high dimensional space: φ(x) where φ : R n → F for which dim(F) >> n. For example, φ(x) representing the d'th order monomials of the coordinates of x, i.e., dim(F) = n+d-1 d which is exponential in d. The mappings of interest are those which are paired with a non-linear kernel function: k(x, x ) = φ(x) φ(x ). Performing PCA on A = [φ(x 1 ), ..., φ(x m )] is equivalent to finding the non-linear surface in R n (the nature of the non-linearity depends on the choice of φ()) which best approximates the original sample data x 1 , ..., x m . The problem is that AA is not computable -however A A is computable because (A A) ij = k(x i , x j ). From the previous section, U = AQD -1 2 = AV contains the first q eigenvectors of AA (where Q and D are computable). Since A itself is not computable we cannot represent U explicitly, but we can project a new vector φ(x) onto the principal directions u 1 , ..., u q and obtain the principal components, i.e., the output vector y = U φ(x), as follows. y = U φ(x) = V A φ(x) = V       k(x 1 , x) . . . k(x m , x)       . Given the principal components (entries of y = U φ(x) of φ(x)) we can measure, for example, the distance between φ(x) and the projection φ(x) = U U φ(x) = U y onto the linear subspace spanned by u 1 , ..., u q (without the need to explicitly compute the principal axes u i ), as follows. φ(x) -φ(x) 2 = φ(x) φ(x) + φ(x) φ(x) -2φ(x) φ(x) = k(x, x) + y U U y -2φ(x) (U U φ(x)) = k(x, x) -y y -2y y = k(x, x) -y 2 Fisher's LDA: Basic Idea We now extend the variance preserving approach for data representation for labeled data sets. We will focus on 2-class sets and look for a separating hyperplane: f (x) = w x + b, such that x belongs to the first class if f (x) > 0 and x belongs to the second class if f (x) < 0. In the statistical literature this type of function is called a linear discriminant function. The decision boundary is given by the set of points satisfying f (x) = 0 which is a hyperplane. Fisher's (1936) Linear Discriminant Analysis (LDA) is a variance preserving approach for finding a linear discriminant function. Seeking a projection which maximizes the distance between the projected centers will prefer the horizontal axis over the vertical, yet the two classes overlap on the horizontal axis. The projected distance along the vertical axis is smaller yet the classes are better separated. The conclusion is that the sample variance of the two classes must be taken into consideration as well. We will then introduce another popular statistical technique called Canonical Correlation Analysis (CCA) for learning the mapping between input and output vectors using the notion \"angle\" between subspaces. What is common in the three techniques PCA, LDA and CCA is the use of spectral matrix analysis -i.e., what can you do with eigenvalues and eigenvectors of matrices representing subspaces of the data? These techniques produce optimal results for normally distributed data and are very easy to implement. There is a large variety of uses of spectral analysis in statistical and learning literature including spectral clustering, Multi Dimensional Scaling (MDS) and data modeling in general. To appreciate the general idea behind Fisher's LDA consider Fig. 5 .1. Let the centers of classes one and two be denoted by µ 1 and µ 2 respectively. A linear discriminant function is a projection onto a 1D subspace such that the classes would be separated the most in the 1D subspace. The obvious first step in this kind of analysis is to make sure that the projected centers μ1 , μ2 would be separated as much as possible. We can easily see that the direction of the 1D subspace should be proportional to µ 1 -µ 2 as follows: (μ 1 -μ2 ) 2 = w µ 1 w - w µ 2 w 2 = w w (µ 1 -µ 2 ) 2 . The right-hand term is maximized when w ≈ µ 1 -µ 2 . As illustrated in Fig. 5 .1, this type of consideration is not sufficient to capture separability in the projected subspace because the spread (variance) of the data points around their centers also play an important role. For example, the horizontal axis in the figure separates the centers better than the vertical axis but on the other hand does a worse job in separating the classes themselves because of the way the data points are spread around their centers. The argument in favor of separating the centers would work if the data points were living in a hyper-sphere around the centers, but will not be sufficient otherwise. The basic idea behind Fisher's LDA is to consider the sample covariance matrix of the individual classes as well as their centers, in the following way. The optimal 1D projection would that which maximizes the variance of the projected centers while minimizes the variance of the projected data points of each class separately. Mathematically, this idea can be implemented by maximizes the following ratio: max w (μ 1 -μ2 ) 2 s 2 1 + s 2 2 , where s 2 1 is the scaled variance of the projected points of the first class: s 2 1 = x i ∈C 1 ( xi -μ1 ) 2 , and likewise, s 2 2 = x i ∈C 2 ( xi -μ2 ) 2 , where x = w w x i + b. We will now formalize this approach and derive its solution. We will begin with a general description of a multiclass problem where the sample data points belong to q different classes, and later focus on the case of q = 2. Fisher's LDA: General Derivation Let the sample data points S be members of q classes C 1 , ..., C q where the number of points belonging to class C i is denoted by l i and the total number of the training set is l = i l i . Let µ j denote the center of class C i and µ denote the center of the complete training set S: µ j = 1 l j bf x i ∈C j x i µ = 1 l x i ∈S x i Let A j be the matrix associated with class C j whose columns consists of the mean shifted data points: A j = [x 1 -µ j , ..., x l j -µ j ] x i ∈ C j . Then, 1 l j A j A j is the covariance matrix associated with class C j . Let S w (where \"w\" stands for \"within\") be the sum of the class covariance matrices: S w = q i 1 l j A j A j . From the discussion in the previous section, it is 1 w 2 w S w w which we wish to minimize. To see why this is so, note x i ∈C j ( xi -μj ) 2 = x i ∈C j w (x i -µ j ) 2 w 2 = 1 w 2 w A j A j w. Let B be the matrix holding the class centers: B = [µ 1 -µ, ..., µ q -µ], and let S b = 1 q BB (where \"b\" stands for \"between\"). From the discussion above it is 1 w 2 w S b w = i (μ i -μ) 2 which we wish to maximize. Taken together, we wish to maximize the ratio (called \"Rayleigh's quotient\"): max w J(w) = w S b w w S w w . The necessary condition for optimality is: ∂J ∂w = S b w(w S w w) -S w w(w S b w) (w S w w) 2 = 0, From which we obtain the generalized eigensystem: S b w = J(w)S w w. (5.2) That is, w is the leading eigenvector of S -1 w S b (assuming S w is invertible). The general case of finding q such axes involves finding the leading generalized eigenvectors of (S b , S w ) -the derivation is out of scope of this lecture. Note that since S -1 w S b is not symmetric there may be no real-value solution, which is a complication will not pursue further in this course. Instead we will focus now on the 2-class (q = 2) setting below. Fisher's LDA: 2-class The general derivation is simplified when there are only two classes. The covariance matrix BB becomes a rank-1 matrix: BB = (µ 1 -µ)(µ 1 -µ) + (µ 2 -µ)(µ 2 -µ) = (µ 1 -µ 2 )(µ 1 -µ 2 ) . As a result, BB w is a vector in direction µ 1 -µ 2 . Therefore, the solution for w from eqn. 5.2 is: w ∼ = S -1 w (µ 1 -µ 2 ). The decision boundary w (x -µ) = 0 becomes: x S -1 w (µ 1 -µ 2 ) - 1 2 (µ 1 + µ 2 ) S -1 w (µ 1 -µ 2 ) = 0. (5.3) This decision boundary will surface again in the course when we consider Bayseian inference. It will be shown that this decision boundary is the Maximum Likelihood solution in the case where the two classes are normally distributed with means µ 1 , µ 2 and with the same covariance matrix S w . LDA versus SVM Both LDA and SVM search for a so called \"optimal\" linear discriminant function, what is the difference? The heart of the matter lies in the definition of what constitutes a sufficient compact representation of the data. In LDA the assumption is that each class can be represented by its mean vector and its spread (i.e., covariance matrix). This is true for normally distributed data -but not true in general. This means that we should expect that LDA will produce the optimal discriminant linear function when each of the classes are normally distributed. With SVM, on the other hand, there is no assumption on how the data is distributed. Instead, the emerging result is that the data is represented by the subset of data points which lie on the boundary between the two classes (the so called support vectors). Rather than making a parametric assumption on how the data can be captured (i.e., mean and covariance) the theory shows that the data can be captured by a special subset of points. The tools, as a result, are naturally more complex (quadratic linear programming versus spectral matrix analysis) -but the advantage is that optimality is guaranteed without making assumptions on the distribution of the data (i.e., distribution free). It can be shown that SVM and LDA would produce the same result if the class data is normally distributed. Canonical Correlation Analysis CCA is a technique for learning a mapping f (x) = y where x ∈ R k and y ∈ R s using the notion of subspace similarity (an extension of the inner product between two vectors) from a training set of (x i , y i ), i = 1, ..., n. Such a mapping, where y can be any point in R k as opposed to a discrete set of labels, is often referred to as a \"regression\" (as opposed to \"classification\"). Like in PCA and LDA, the approach would be to look for projection axes such that the projection of the input and output vectors on those axes satisfy certain requirements -and like PCA and LDA the tools we would be using is matrix spectral analysis. It will be convenient to stack our vectors as rows of an input matrix A and output matrix B. Let A be an n × k matrix whose rows are x 1 , ..., x n and B is the n × s matrix whose rows are y 1 , ..., y n . Consider vectors u ∈ R k and v ∈ R s and project the input and output data onto them producing Au = (x 1 u, ..., x n u) and Bv. The requirement we would like to place on the projection axes is that Au ≈ Bv, or in other words that (Au) (Bv) is maximal. The requirement therefore is that the projection of the input points onto the u axis is similar to the projection of the output points onto the v axis. If we extend this notion to multiple axes u 1 , ..., u q (not necessarily orthogonal) and v 1 , ..., v q where q ≤ min(k, s) our requirement becomes that the new coordinates of the input points projected onto the subspace spanned by the u vectors are similar to the new coordinates of the output points projected onto the subspace spanned by the v vectors. In other words, we wish to find two q-dimensional subspaces one of R k and the other of R s such that the two sets of projected points are as aligned as possible. CCA goes a step further and makes the assumption that the input/output relationship is solely determined by the relation (angles) between the column spaces of A, B. In other words, the particular columns of A are not really important, what is important is the space U A spanned by the columns. Since g = Au is a point in U A (a linear combination of the columns of A) and h = Bv is a point in U B , then g h is the cosine angle, cos(φ) between the two axes provided that we normalize the vectors g and h. If we continue this line of reasoning recursively, we obtain a set of angles 0 ≤ θ 1 ≤ ... ≤ θ q ≤ (π/2), called \"principal angles\", between the two subspaces uniquely defined as: cos(θ j ) = max g∈U A max h∈U B g h (5.4) subject to: g g = h h = 1, h h i = 0, g g i = 0, i = 1, ..., j -1 As a result, we obtain the following optimization function over axes u, v: max u,v u A Bv s.t. Au 2 = 1, Bv 2 = 1. To solve this problem we first perform a \"QR\" factorization of A and B. A \"QR\" factorization of a matrix A is a Grahm-Schmidt process resulting in an orthonormal set of vectors arranged as the columns of a matrix Q A whose column space is equal to the column space of A, and a matrix R A which contains the coefficients of the linear combination of the columns of Q A such that A = Q A R A . Since orthoganilzation is not unique, the Grahm-Schmidt process perfroms the orthogonalization such that R A is an upper-diagonal matrix. Likewise let B = Q B R B . Because the column spaces of A and Q A are the same, then for every u there exists a û such that Au = Q A û. Our optimization problem now becomes: max û, v û Q A Q B v s.t. û 2 = 1, v 2 = 1. The solution of this problem is when û and v are the leading singular vectors of Q A Q B . The singular value decomposition (SVD) of any matrix E is a decomposition E = U DV where the columns of U are the leading eigenvectors of EE , the rows of V are the leading eigenvectors of E E and D is a diagonal matrix whose entries are the corresponding square eigenvalues (note that the eigenvalues of EE and E E are the same). The SVD decomposition has the property that if we keep only the first q leading eigenvectors then U DV is the closest (in least squares sense) rank q matrix to E. Therefore, let Û D V be the SVD of Q A Q B using the first q eigenvectors. Then, our sought after axes U = [u 1 , ..., u q ] is simply R -1 A Û and likewise and the axes V = [v 1 , ..., v q ] is equal to R -1 B V . The axes are called \"canonical vectors\", and the vectors g i = Au i (mutually orthogonal) are called \"variates\". The concept of principal angles is due to Jordan in 1875, where Hotelling in 1936 is the first to introduce the recursive definition above. Given a new vector x ∈ R k the resulting vector y can be found by solving the linear system U x = V y (since our assumption is that in the new basis the coordinates of x and y are similar). To conclude, the relationship between A and B is captured by creating similar variates, i.e., creating subspaces of dimension q such that the projections of the input vectors and the output vectors have similar coordinates. The process for obtaining the two q-dimensional subspaces is by performing a QR factorization of A and B followed by an SVD. Here again the spectral analysis of the input and output data matrices plays a pivoting role in the input/output association. Spectral Analysis II: Clustering In the previous lecture we ended up with the formulation: max G m×k trace(G KG) s.t. G G = I (6.1) and showed the solution G is the leading eigenvectors of the symmetric positive semi definite matrix K. When K = AA (sample covariance matrix) with A = [x 1 , ..., x m ], x i ∈ R n , those eigenvectors form a basis to a kdimensional subspace of R n which is the closest (in L 2 norm sense) to the sample points x i . The axes (called principal axes) g 1 , ..., g k preserve the variance of the original data in the sense that the projection of the data points on the g 1 has maximum variance, projection on g 2 has the maximum variance over all vectors orthogonal to g 1 , etc. The spectral decomposition of the sample covariance matrix is a way to \"compress\" the data by means of linear super-position of the original coordinates y = G x. We also ended with a ratio formulation: max w w S 1 w w S 2 w where S 1 , S 2 where scatter matrices defined such that w S 1 w is the variance of class centers (which we wish to maximize) and w S 2 w is the sum of within class variance (which we want to minimize). The solution w is the generalized eigenvector S 1 w = λS 2 w with maximal λ. In this lecture we will show additional applications where the search for leading eigenvectors plays a pivotal part of the solution. So far we have seen how spectral analysis relates to PCA and LDA and today we will focus on the classic Data Clustering problem of partitioning a set of points x 1 , ..., x m into k ≥ 2 classes, i.e., generating as output indicator variables y 1 , ..., y m where y i ∈ {1, ..., k}. We will begin with \"K-means\" algorithm for clustering and then move on to show how the optimization criteria relates to grapth-theoretic approaches (like Min-Cut, Ratio-Cut, Normalized Cuts) and spectral decomposition. K-means Algorithm for Clustering The K-means formulation (originally introduced by [4]) assumes that the clusters are defined by the distance of the points to their class centers only. In other words, the goal of clustering is to find those k mean vectors c 1 , ..., c k and provide the cluster assignment y i ∈ {1, ..., k} of each point x i in the set. The K-means algorithm is based on an interleaving approach where the cluster assignments y i are established given the centers and the centers are computed given the assignments. The optimization criterion is as follows: min y 1 ,...,ym,c 1 ,...,c k k j=1 y i =j x i -c j 2 (6.2) Assume that c 1 , ..., c k are given from the previous iteration, then y i = argmin j x i -c j 2 , and next assume that y 1 , .., y m (cluster assignments) are given, then for any set S ⊆ {1, ..., m} we have that 1 |S| j∈S x j = argmin c j∈S x j -c 2 . In other words, given the estimated centers in the current round, the new assignments are computed by the closest center to each point x i , and then given the updated assignments the new centers are estimated by taking the mean of each cluster. Since each step is guaranteed to reduce the optimization energy the process must converge -to some local optimum. The drawback of the K-means algorithm is that the quality of the local optimum strongly depends on the initial guess (either the centers or the assignments). If we start with a wild guess for the centers it would be fairly unlikely that the process would converge to a good local minimum (i.e. one that is close to the global optimum). An alternative approach would be to define an approximate but simpler problem which has a closed form solution (such as obtained by computing eigenvectors of some matrix). The global optimum of the K-means is an NP-Complete problem (mentioned briefly in the next section). Next, we will rewrite the K-means optimization criterion in matrix form and see that it relates to the spectral formulation (eqn. 6.1). Matrix Formulation of K-means We rewrite eqn. 6.2 as follows [7] . Instead of carrying the class variables y i we define class sets ψ 1 , ..., ψ k where ψ i ⊂ {1, ..., n} with ψ j = {1, ..., n} and ψ i ψ j = ∅. The K-means optimization criterion seeks for the centers and the class sets: min ψ 1 ,...,ψ k ,c 1 ,...,c k k j=1 i∈ψ j x i -c j 2 . Let l j = |ψ j | and following the expansion of the squared norm and dropping x i x i we end up with an equivalent problem: min ψ 1 ,...,ψ k ,c 1 ,...,c k k j=1 l j c j c j -2 k j=1 i∈ψ j x i c j . Next we substitute c j with its definition: (1/l j ) i∈ψ j x j and obtain a new equivalent formulation where the centers c j are eliminated form consideration: min ψ 1 ,...,ψ k - k j=1 1 l j r,s∈ψ j x r x s which is more conveniently written as a maximization problem: max ψ 1 ,...,ψ k k j=1 1 l j r,s∈ψ j x r x s . (6.3) Since the resulting formulation involves only inner-products we could have replaced x i with φ(x i ) in eqn. 6.2 where the mapping φ(•) is chosen such that φ(x i ) φ(x j ) can be replaced by some non-linear function κ(x i , x j )known as the \"kernel trick\" (discussed in previous lectures). Having the ability to map the input vectors onto some high-dimensional space before K-means is applied provides more flexibility and increases our chances of getting out a \"good\" clustering from the global K-means solution (again, the local optimum depends on the initial conditions so it could be \"bad\"). The RBF kernel is quite popular in this context κ(x i , x j ) = e -x i -x j 2 /σ 2 with σ some pre-determined parameter. Note that κ(x i , x j ) ∈ (0, 1] which can be interpreted loosely as the probability of x i and x j to be clustered together. Let K ij = κ(x i , x j ) making K a m × m symmetric positive-semi-definite matrix often referred to as the \"affinity\" matrix. Let F be an n × n matrix whose entries are F ij = 1/l r if (i, j) ∈ ψ r for some class ψ r and F ij = 0 otherwise. In other words, if we sort the points x i according to cluster membership, then F is a block diagonal matrix with blocks F 1 , ..., F k where F r = (1/l r )11 is an l r × l r block of 1's scaled by 1/l r . Then, Eqn. 6.3 can be written in terms of K as follows: max F n i,j=1 K ij F ij = trace(KF ) (6.4) In order to form this as an optimization problem we need to represent the structure of F in terms of constraints. Let G be an n × k column-scaled indicator matrix: G ij = (1/ l j ) if i ∈ ψ j (i. e., x i belongs to the j'th class) and G ij = 0 otherwise. Let g 1 , ..., g k be the columns of G and it can be easily verified that g r g r = diag(0, .., F r , 0, .., 0) therefore F = j g j g j = GG . Since trace(AB) = trace(BA) we can now write eqn. 6.4 in terms of G: max G trace(G KG) under conditions on G which we need to further spell out. We will start with the necessary conditions. Clearly G ≥ 0 (has nonnegative entries). Because each point belongs to exactly one cluster we must have G G ij = 0 when i = j and G G ii = (1/l i )1 1 = 1, thus G G = I. Furthermore we have that the rows and columns of F = GG sum up to 1, i.e., F 1 = 1, F 1 = 1 which means that F is doubly stochastic which translates to the constraint GG 1 = 1 on G. We have therefore three necessary conditions on G: (i) G ≥ 0, (ii) G G = I, and (iii) GG 1 = 1. The claim below asserts that these are also sufficient conditions: Claim 4 The feasibility set of matrices G which satisfy the three conditions G ≥ 0, GG 1 = 1 and G G = I are of the form: G ij = 1 √ l j x i ∈ ψ j 0 otherwise Proof: From G ≥ 0 and g r g s = 0 we have that G ir G is = 0, i.e., G has a single non-vanishing element in each row. It will be convenient to assume that the points are sorted according to the class membership, thus the columns of G have the non-vanishing entries in consecutive order and let l j be the number of non-vanishing entries in column g j . Let u j the vector of l j entries holding only the non-vanishing entries of g j . Then, the doubly stochastic constraint GG 1 = 1 results that (1 u j )u j = 1 for j = 1, ..., k. Multiplying 1 from both sides yields (1 u j ) 2 = 1 1 = l j , therefore u j = (1/ l j )1. This completes the equivalence between the matrix formulation: max G∈R m×k trace(G KG) s.t. G ≥ 0, G G = I, GG 1 = 1 (6.5) and the original K-means formulation of eqn. 6.2. We have obtained the same optimization criteria as eqn. 6.1 with additional two constraints: G should be non-negative and GG should be doubly stochastic. The constraint G G = I comes from the requirement that each point is assigned to one class only. The doubly stochastic constraint comes from a \"class balancing\" requirement which we will expand on below. Min-Cut We will arrive to eqn. 6.5 from a graph-theoretic perspective. We start with representing the graph Min-Cut problem in matrix form, as follows. A convenient way to represent the data to be clustered is by an undirected graph with edge-weights where V = {1, ..., m} is the vertex set, E ⊂ V × V is the edge set and κ : E → R + is the positive weight function. Vertices of the graph correspond to data points x i , edges represent neighborhood relationships, and edge-weights represent the similarity (affinity) between pairs of linked vertices. The weight adjacency matrix K holds the weights where K ij = κ(i, j) for (i, j) ∈ E and K ij = 0 otherwise. A cut in the graph is defined between two disjoint sets A, B ⊂ V , A ∪ B = V , is the sum of edge-weights connecting the two sets: cut(A, B) = i∈A,j∈B K ij which is a measure of dissimilarity between the two sets. The Min-Cut problem is to find a minimal weight cut in the graph (can be solved in polynomial time through Max Network Flow solution). The following claim associates algebraic conditions on G with an indicator matrix: Claim 5 The feasibility set of matrices G which satisfy the three conditions G ≥ 0, G1 = 1 and G G = D for some diagonal matrix D are of the form: G ij = 1 x i ∈ ψ j 0 otherwise Proof: Let G = [g 1 , ..., g k ]. From G ≥ 0 and g r g s = 0 we have that G ir G is = 0, i.e., G has a single non-vanishing element in each row. From G1 = 1 the single non-vanishing entry of each row must have the value of 1. In the case of two classes (k = 2), the function tr(G KG) is equal to (i,j)∈ψ 1 K ij + (i,j)∈ψ 2 K ij . Therefore max G tr(G KG) is equivalent to minimizing the cut: i∈ψ 1 ,j∈ψ 2 K ij . As a result, the Min-Cut problem is equivalent to solving the optimization problem: max G∈R m×2 tr(G KG) s.t G ≥ 0, G1 = 1, G G = diag (6.6) We seem to be close to eqn. 6.5 with the difference that G is orthogonal (instead of orthonormal) and the doubly-stochasitc constraint is replaced by G1 = 1. The difference can be bridged by considering a \"balancing\" requirement. Min-Cut can produce an unbalanced partition where one set of vertices is very large and the other contains a spurious set of vertices having a small number of edges to the larger set. This is an undesirable outcome in the context of clustering. Consider a \"balancing\" constraint G 1 = (m/k)1 which makes a strict requirement that all the k clusters have an equal number of points. We can relax the balancing constraint slightly by combining the balancing constraint with G1 = 1 into one single constraint GG 1 = (m/k)1, i.e., GG is scaled doubly stochastic. Note that the two conditions GG 1 = (m/k)1 and G G = D result in D = (m/k)I. Thus we propose the relaxed-balanced hard clustering scheme: max G tr(G KG) s.t G ≥ 0, GG 1 = m k 1, G G = m k I The scale m/k is a global scale that can be dropped without affecting the resulting solution, thus the Min-Cut with a relaxed balancing requirement becomes eqn. 6.5 which we saw is equivalent to K-means: max G tr(G KG) s.t G ≥ 0, GG 1 = 1, G G = I. Spectral Clustering: Ratio-Cuts and Normalized-Cuts We saw above that the doubly-stochastic constraint has to do with a \"balancing\" desire. A further relaxation of the balancing desire is to perform the optimization in two steps: (i) replace the affinity matrix K with the closest (under some chosen error measure) doubly-stochastic matrix K , (ii) find a solution to the problem: max G∈R m×k tr(G K G) s.t G ≥ 0, G G = I (6.7) because GG should come out close to K (tr(G K G) = tr(K GG )) and K is doubly-stochastic, then GG should come out close to satisfying a doubly-stochastic constraint -this is the motivation behind the 2-step approach. Moreover, we drop the non-negativity constraint G ≥ 0. Note that the non-negativity constraint is crucial for the physical interpretation of Ratio-Cuts, the second smallest eigenvector of the Laplacian D -K, is an approximation due to Hall in the 70s [2] to the Min-Cut formulation. Let z ∈ R m determine the class membership such that x i and x j would be clustered together if z i and z j have similar values. This leads to the following optimization problem: min z 1 2 i,j (z i -z j ) 2 K ij s.t. z z = 1 The criterion function is equal to (1/2)z (D -K)z and the derivative of the Lagrangian (1/2)z (D -K)z -λ(z z -1) with respect to z gives rise to the necessary condition (D -K)z = λz and the Ratio-Cut scheme follows. Normalized-Cuts Normalized-Cuts looks for the closest doubly-stochastic matrix K in relative entropy error measure defined as: RE(x || y) = i x i ln x i y i + i y i - i x i . We will encounter the relative entropy measure in more detail later in the course. We can show that K must have the form ΛKΛ for some diagonal matrix Λ: Claim 7 The closest doubly-stochastic matrix F under the relative-entropy error measure to a given non-negative symmetric matrix K, i.e., which minimizes: min F RE(F ||K) s.t. F ≥ 0, F = F , F 1 = 1, F 1 = 1 has the form F = ΛKΛ for some (unique) diagonal matrix Λ. Proof: The Lagrangian of the problem is: L() = ij f ij ln f ij k ij + ij k ij - ij f ij - i λ i ( j f ij -1) - j µ j ( i f ij -1) The derivative with respect to f ij is: ∂L ∂f ij = ln f ij + 1 -ln k ij -1 -λ i -µ j = 0 from which we obtain: f ij = e λ i e µ j k ij Let D 1 = diag(e λ 1 , ..., e λn ) and D 2 = diag(e µ 1 , ..., e µn ), then we have: F = D 1 KD 2 Since F = F and K is symmetric we must have D 1 = D 2 . Next, we can show that the diagonal matrix Λ can found by an iterative process where K is replaced by D -1/2 KD -1/2 where D was defined above as diag(K1): Claim 8 For any non-negative symmetric matrix K (0) , iterating the process K (t+1) ← D -1/2 K (t) D -1/2 with D = diag(K (t) 1) converges to a doubly stochastic matrix. The proof is based on showing that the permanent increases monotonically, i.e. perm(K (t+1) ) ≥ perm(K (t) ). Because the permanent is bounded the process must converge and if the permanent does not change (at the convergence point) the resulting matrix must be doubly stochastic. The resulting doubly stochastic matrix is the closest to K in relative-entropy. Normalized-Cuts takes the result of the first iteration by replacing K with K = D -1/2 KD -1/2 followed by the spectral decomposition (in case of k = 2 classes the partitioning information is found in the second leading eigenvector of K -just like Ratio-Cuts but with a different K ). Thus, K in this manner is not the closest doubly-stochastic matrix to K but is fairly close (the first iteration is the dominant one in the process). Normalized-Cuts, as the second leading eigenvector of K = D -1/2 KD -1/2 , is an approximation to a \"balanced\" Min-Cut described first in [6] . Deriving it from first principles proceeds as follows: Let sum(V 1 , V 2 ) = sum i∈V 1 ,j∈V 2 K ij be defined for any two subsets (not necessarily disjoint) of vertices. The normalized-cuts measures the cut cost as a fraction of the total edge connections to all the nodes in the graph: N cuts(A, B) = cut(A, B) sum(A, V ) + cut(A, B) sum(B, V ) . A minimal Ncut partition will no longer favor small isolated points since the cut value would most likely be a large percentage of the total connections from that small set to all the other vertices. A related measure N assoc(A, B) defined as: N assoc(A, B) = sum(A, A) sum(A, V ) + sum(B, B) sum(B, V ) , reflects how tightly on average nodes within the group are connected to each other. Given that cut(A, B) = sum(A, V ) -sum(A, A) one can easily verify that: N cuts(A, B) = 2 -N assoc(A, B), therefore the optimal bi-partition can be represented as maximizing N assoc(A, V -A). The N assoc naturally extends to k > 2 classes (partitions) as follows: Let ψ 1 , ..., ψ k be disjoint sets ∪ j ψ j = V , then: N assoc(ψ 1 , ..., ψ k ) = k j=1 sum(ψ j , ψ j ) sum(ψ j , V ) . We will now rewrite N assoc in matrix form and establish equivalence to eqn. 6.7. Let Ḡ = [g 1 , ..., g k ] with g j = 1/ sum(ψ j , V )(0, ..., 0, 1, ...1, 0., , , 0) with the 1s indicating membership to the j'th class. Note that g j Kg j = sum(ψ j , ψ j ) sum(ψ j , V ) , therefore trace( Ḡ K Ḡ) = N assoc(ψ 1 , ..., ψ k ). Note also that g i Dg i = (1/sum(ψ i , V )) r∈ψ i d r = 1, therefore Ḡ D Ḡ = I. Let G = D 1/2 Ḡ so we have that G G = I and trace(G D -1/2 KD -1/2 G) = N assoc(ψ 1 , ..., ψ k ). Taken together we have that maximizing N assoc is equivalent to: max G∈R m×k trace(G K G) s.t. G ≥ 0, G G = I, (6.8) where K = D -1/2 KD -1/2 . Note that this is exactly the K-means matrix setup of eqn. 6.5 where the doubly-stochastic constraint is relaxed into the replacement of K by K . The constraint G ≥ 0 is then dropped and the resulting solution for G is the k leading eigenvectors of K . We have arrived via seemingly different paths to eqn. 6.8 which after we drop the constraint G ≥ 0 we end up with a closed form solution consisting of the k leading eigenvectors of K . When k = 2 (two classes) one can easily verify that the partitioning information is fully contained in the second eigenvector. Let v 1 , v 2 be the first leading eigenvectors of K . Clearly v = D 1/2 1 is an eigenvector with eigenvalue λ = 1: D -1/2 KD -1/2 (D 1/2 1) = D -1/2 K1 = D 1/2 1. In fact λ = 1 is the largest eigenvalue (left as an exercise) thus v 1 = D 1/2 1 > 0. Since K is symmetric the v 2 v 1 = 0 thus v 2 contains positive and negative entries -those are interpreted as indicating class membership (positive to one class and negative to the other). The case k > 2 is treated as an embedding (also known as Multi-Dimensional Scaling) by re-coordinating the points x i using the rows of G. In other words, the i'th row of G is a representation of x i in R k . Under ideal conditions where K is block diagonal (the distance between clusters is infinity) the rows associated with points clustered together are identical (i.e., the n original points are mapped to k points in R k ) [5] . In practice, one performs the iterative K-means in the embedded space. The Formal (PAC) Learning Model We have see so far algorithms that explicitly estimate the underlying distribution of the data (Bayesian methods and EM) and algorithms that are in some sense optimal when the underlying distribution is Gaussian (PCA, LDA). We have also encountered an algorithm (SVM) that made no assumptions on the underlying distribution and instead tied the accuracy to the margin of the training data. In this lecture and in the remainder of the course we will address the issue of \"accuracy\" and \"generalization\" in a more formal manner. Because the learner receives only a finite training sample, the learning function can do very well on the training set yet perform badly on new input instances. What we would like to establish are certain guarantees on the accuracy of the learner measured over all the instance space and not only on the training set. We will then use those guarantees to better understand what the largemargin principle of SVM is doing in the context of generalization. In the remainder of this lecture we will refer to the following notations: the class of learning functions is denoted by C. A learning functions is often referred to as a \"concept\" or \"hypothesis\". A target function c t ∈ C is a function that has zero error on all input instances (such a function may not always exist). The Formal Model In many learning situations of interest, we would like to assume that the learner receives m examples sampled by some fixed (yet unknown) distribution D and the learner must do its best with the training set in order to achieve the accuracy and confidence objectives. The Probably Approximate Correct (PAC) model, also known as the \"formal model\", first introduced by Valient in 1984, provides a probabilistic setting which formalizes the notions of accuracy and confidence. The PAC model makes the following statistical assumption. We assume the learner receives a set S of m instances x 1 , ..., x m ∈ X which are sampled randomly and independently according to a distribution D over X. In other words, a random training set S of length m is distributed according to the product probability distribution D m . The distribution D is unknown, but we will see that one can obtain useful results by simply assuming that D is fixed -there is no need to attempt to recover D during the learning process. To recap, we make the following three assumptions: (i) D is unkown, (ii) D is fixed throughout the learning process, and (iii) the example instances are sampled independently of each other (are Identically and Independently Distributed -i.i.d.) . We distinguish between the \"realizable\" case where a target concept c t (x) is known to exist, and the unrealizable case, where there is no such guarantee. In the realizable case our training examples are Z = {(x i , c t (x i )}, i = 1, ..., m and D is defined over X (since y i ∈ Y are given by c t (x i )). In the unrealizable case, Z = {(x i , y i )} and D is the distribution over X × Y (each element is a pair, one from X and the other from Y ). We next define what is meant by the error induced by a concept function h(x). In the realizable case, given a function h ∈ C, the error of h is defined with respect to the distribution D: err(h) = prob D [x : c t (x) = h(x)] = x∈X ind(c t (x) = h(x))D(x)dx where ind(F ) is an indication function which returns '1' if the proposition F is true and '0' otherwise. The function err(h) is the probability that an instance x sampled according to D will be labeled incorrectly by h(x). Let > 0 be a parameter given to the learner specifying the \"accuracy\" of the learning process, i.e. we would like to achieve err(h) ≤ . Note that err(c t ) = 0. In addition, we define a \"confidence\" parameter δ > 0, also given to the learner, which defines the probability that err(h) > , namely, prob[err(h) > ] < δ, or equivalently: prob[err(h) ≤ ] ≥ 1 -δ. In other words, the learner is supposed to meet some accuracy criteria but is allowed to deviate from it by some small probability. Finally, the learning algorithm is supposed to be \"efficient\" if the running time is polynomial in 1/ , ln(1/δ), n and the size of the concept target function c t () (measured by the number of bits necessary for describing it, for example). We will say that an algorithm L learns a concept family C in the formal sense (PAC learnable) if for any c t ∈ C and for every distribution D on the instance space X, the algorithm L generates efficiently a concept function h ∈ C such that the probability that err(h) ≤ is at least 1 -δ. The inclusion of the confidence value δ could seem at first unnatural. What we desire from the learner is to demonstrate a consistent performance regardless of the training sample Z. In other words, it is not enough that the learner produces a hypothesis h whose accuracy is above threshold, i.e., err(h) ≤ , for some training sample Z. We would like the accuracy performance to hold under all training samples (sampled from the distribution D m ) -since this requirement could be too difficult to satisfy, the formal model allows for some \"failures\", i.e, situations where err(h) > , for some training samples Z, as long as those failures are rare and the frequency of their occurrence is controlled (the parameter δ) and can be as small as we like. In the unrealizable case, there may be no function h ∈ C for which err(h) = 0, thus we need to define what we mean by the best a learning algorithm can achieve: Opt(C) = min h∈C err(h), which is the best that can be done on the concept class C using functions that map between X and Y . Given the desired accuracy and confidence δ values the learner seeks a hypothesis h ∈ C such that: prob[err(h) ≤ Opt(C) + ] ≥ 1 -δ. We are ready now to formalize the discussion above and introduce the definition of the formal learning model (Anthony & Bartlett [1] , pp. 16): Definition 1 (Formal Model) Let C be the concept class of functions that map from a set X to Y . A learning algorithm L is a function: L : ∞ m=1 {(x i , y i )} m i=1 → C from the set of all training examples to C with the following property: given any , δ ∈ (0, 1) there is an integer m 0 ( , δ) such that if m ≥ m 0 then, for any probability distribution D on X × Y , if Z is a training set of length m drawn randomly according to the product probability distribution D m , then with probability of at least 1 -δ the hypothesis h = L(Z) ∈ C output by L is such that err(h) ≤ Opt(C) + . We say that C is learnable (or PAC learnable) if there is a learning algorithm for C. There are few points to emphasize. The sample size m 0 ( , δ) is a sufficient sample size for PAC learning C by L and is allowed to vary with , δ. Decreasing the value of either or δ makes the learning problem more difficult and in turn a larger sample size is required. Note however that m 0 ( , δ) does not depend on the distribution D! that is, a sufficient sample size can be given that will work for any distribution D -provided that D is fixed throughout the learning experience (both training and later for testing). This point is a crucial property of the formal model because if the sufficient sample size is allowed to vary with the distribution D then not only we would need to have some information about the distribution in order to set the sample complexity bounds, but also an adversary (supplying the training set) could control the rate of convergence of L to a solution (even if that solution can be proven to be optimal) and make it arbitrarily slow by suitable choice of D. What makes the formal model work in a distribution-invariant manner is that it critically depends on the fact that in many interesting learning scenarios the concept class C is not too complex. For example, we will show later in the lecture that any finite concept class |C| < ∞ is learnable, and the sample complexity (in the realizable case) is m ≥ 1 ln |C| δ . In the next lecture we will consider concept classes of infinite size and show that despite the fact that the class is infinite it still can be of low complexity! Before we illustrate the concepts above with an example, there is another useful measure which is the empirical error (also known as the sample error) ê rr(h) which is defined as the proportion of examples from Z on which h made a mistake: ê rr(h) = 1 m |{i : h(x i ) = c t (x i )}| (replace c t (x i ) with y i for the unrealizable case). The situation of bounding the true error err(h) by minimizing the sample error ê rr(h) is very convenient -we will get to that later. The Rectangle Learning Problem As an illustration of learnability we will consider the problem (introduced in Kearns & Vazirani [3] ) of learning an axes-aligned rectangle from positive and negative examples. We will show that the problem is PAC-learnable and find out m 0 ( , δ). In the rectangle learning game we are given a training set consisting of points in the 2D plane with a positive '+' or negative '-' label. The positive examples are sampled inside the target rectangle (parallel to the main axes) R and the negative examples are sampled outside of R. Given m examples sampled i.i.d according to some distribution D the learner is supposed to generate an approximate rectangle R which is consistent with the training set (we are assuming that R exists) and which satisfies the accuracy and confidence constraints. We first need to decide on a learning strategy. Since the solution R is not uniquely defined given any training set Z, we need to add further constraints to guarantee a unique solution. We will choose R as the axesaligned concept which gives the tightest fit to the positive examples, i.e., the smallest area axes-aligned rectangle which contains the positive examples. If no positive examples are given then R = ∅. We can also assume that Z contains at least three non-collinear positive examples in order to avoid complications associated with infinitesimal area rectangles. Note that we could have chosen other strategies, such as the middle ground between the tightest fit to the positive examples and the tightest fit (from below) to the negative examples, and so forth. Defining a strategy is necessary for the analysis below -the type of strategy is not critical though. We next define the error err(R ) on the concept R generated by our learning strategy. We first note that with the strategy defined above we always have R ⊂ R since R is the tightest fit solution which is consistent with the sample data (there could be a positive example outside of R which is not in the training set). We will define the \"weight\" w(E) of a region E in the plane as w(E) = x∈E D(x)dx, i.e., the probability that a random point sampled according to the distribution D will fall into the region. Therefore, the error associated with the concept R is and we wish to bound the error w(R -R ) ≤ with probability of at least 1 -δ after seeing m examples. We will divide the region R -R into four strips T 1 , ..., T 4 (see Fig. 7 .1) which overlap at the corners. We will estimate prob(w(T i ) ≥ 4 ) noting that the overlaps between the regions makes our estimates more pessimistic than they truly are (since we are counting the overlapping regions twice) thus making us lean towards the conservative side in our estimations. err(R ) = w(R -R ) Consider the upper strip T 1 . If w(T 1 ≤ 4 ) then we are done. We are however interested in quantifying the probability that this is not the case. Assume w(T 1 ) > 4 and define a strip T 1 which starts from the upper axis of R and stretches to the extent such that w(T 1 ) = 4 . Clearly T 1 ⊂ T 1 . We have that w(T 1 ) > 4 iff T 1 ⊂ T 1 . Furthermore: Claim 9 T 1 ⊂ T 1 iff x 1 , ..., x m ∈ T 1 . Proof: If x i ∈ T 1 the the label must be positive since T 1 ⊂ R. But if the label is positive then given our learning strategy of fitting the tightest rectangle over the positive examples, then x i ∈ R . Since T 1 ⊂ R it follows that x i ∈ T 1 . We have therefore that w(T 1 > 4 ) iff no point in T 1 appears in the sample S = {x 1 , ..., x m } (otherwise T 1 intersects with R and thus T 1 ⊂ T 1 ). The probability that a point sampled according to the distribution D will fall outside of T 1 is 1 -4 . Given the independence assumption (examples are drawn i.i.d.), we have: prob(x 1 , ..., x m ∈ T 1 ) = prob(w(T 1 > 4 )) = (1 - 4 ) m . Repeating the same analysis to regions T 2 , T 3 , T 4 and using the union bound P (A ∪ B) ≤ P (A) + P (B) we come to the conclusion that the probability that any of the four strips of R -R has weight greater that /4 is at most 4(1 -4 ) m . In other words, prob(err(L ) ≥ ) ≤ 4((1 - 4 ) m ≤ δ. We can make the expression more convenient for manipulation by using the inequality e -x ≥ 1 -x (recall that 1 + (1/n)) n < e from which it follows that (1 + z) 1/z < e and by taking the power of rz where r ≥ 0 we obtain (1 + z) r < e rz then set r = 1, z = -x): 4(1 - 4 ) m ≤ 4e -m 4 ≤ δ, from which we obtain the bound: m ≥ 4 ln 4 δ . To conclude, assuming that the learner adopts the tightest-fit to positive examples strategy and is given at least m 0 = 4 ln 4 δ training examples in order to find the axes-aligned rectangle R , we can assert that with probability 1 -δ the error associated with R (i.e., the probability that an (m + 1)'th point will be classified incorrectly) is at most . We can see form the analysis above that indeed it applies to any distribution D where the only assumption we had to make is the independence of the draw. Also, the sample size m behaves well in the sense that if one desires a higher level of accuracy (smaller ) or a higher level of confidence (smaller δ) then the sample size grows accordingly. The growth of m is linear in 1/ and linear in ln(1/δ). Learnability of Finite Concept Classes In the previous section we illustrated the concept of learnability with a particular simple example. We will now focus on applying the learnability model to a more general family of learning examples. We will consider the family of all learning problems over finite concept classes |C| < ∞. For example, the conjunction learning problem (over boolean formulas) with n literals contains only 3 n hypotheses because each variable can appear in the conjunction or not and if appears it could be negated or not. We have shown that n is the lower bound on the number of mistakes on the worst case analysis any on-line algorithm can achieve. With the definitions we have above on the formal model of learnability we can perform accuracy and sample complexity analysis that will apply to any learning problem over finite concept classes. This was first introduced by Valiant in 1984. In the realizable case over |C| < ∞, we will show that any algorithm L which returns a hypothesis h ∈ C which is consistent with the training set Z is a learning algorithm for C. In other words, any finite concept class is learnable and the learning algorithms simply need to generate consistent hypotheses. The sample complexity m 0 associated with the choice of and δ can be shown as equal to: 1 ln |C| δ . In the unrealizable case, any algorithm L that generates a hypothesis h ∈ C that minimizes the empirical error (the error obtained on Z) is a learning algorithm for C. The sample complexity can be shown as equal to: 2 2 ln 2|C| δ . We will derive these two cases below. The Realizable Case Let h ∈ C be some consistent hypothesis with the training set Z (we know that such a hypothesis exists, in particular h = c t the target concept used for generating Z) and suppose that err(h) = prob[x ∼ D : h(x) = c t (x)] > . Then, the probability (with respect to the product distribution D m ) that h agrees with c t on a random sample of length m is at most (1 -) m . Using the inequality we saw before e -x ≥ 1 -x we have: prob[err(h) > && h(x i ) = c t (x i ), i = 1, ..., m] ≤ (1 -) m < e -m . We wish to bound the error uniformly, i.e., that err(h) ≤ for all concepts h ∈ C. This requires the evaluation of: prob[max h∈C {err(h) > } && h(x i ) = c t (x i ), i = 1, ..., m]. There at most |C| such functions h, therefore using the Union-Bound the probability that some function in C has error larger than and is consistent with c t on a random sample of length m is at most |C|e -m : prob[∃h : err(h) > && h(x i ) = c t (x i ), i = 1, ..., m] ≤ h:err(h)> prob[h(x i ) = c t (x i ), i = 1, ..., m] ≤ |h : err(h) > |e -m ≤ |C|e -m For any positive δ, this probability is less than δ provided: m ≥ 1 ln |C| δ . This derivation can be summarized in the following theorem (Anthony & Bartlett [1] , pp. 25): Theorem 5 Let C be a finite set of functions from X to Y . Let L be an algorithm such that for any m and for any c t ∈ C, if Z is a training sample {(x i , c t (x i ))}, i = 1, ..., m, then the hypothesis h = L(Z) satisfies h(x i ) = c t (x i ). Then L is a learning algorithm for C in the realizable case with sample complexity m 0 = 1 ln |C| δ . The Unrealizable Case In the realizable case an algorithm simply needs to generate a consistent hypothesize to be considered a learning algorithm in the formal sense. In the unrealizable situation (a target function c t might not exist) an algorithm which minimizes the empirical error, i.e., an algorithm L generates h = L(Z) having minimal sample error: ê rr(L(Z)) = min h∈C ê rr(h) is a learning algorithm for C (assuming finite |C|). This is a particularly useful property given that the true errors of the functions in C are unknown. It seems natural to use the sample errors ê rr(h) as estimates to the performance of L. The fact that given a large enough sample (training set Z) then the sample error ê rr(h) becomes close to the true error err(h) is somewhat of a restatement of the \"law of large numbers\" of probability theory. For example, if we toss a coin many times then the relative frequency of 'heads' approaches the true probability of 'head' at a rate determined by the law of large numbers. We can bound the probability that the difference between the empirical error and the true error of some h exceeds using Hoeffding's inequality: Claim 10 Let h be some function from X to Y = {0, 1}. Then prob[| ê rr(h) -err(h)| ≥ ] ≤ 2e (-2 2 m) , for any probability distribution D, any > 0 and any positive integer m. Proof: This is a straightforward application of Hoeffding's inequality to Bernoulli variables. Hoeffding's inequality says: Let X be a set, D a probability distribution on X, and f 1 , ..., f m real-valued functions f i : X → [a i , b i ] from X to an interval on the real line (a i < b i ). Then, prob | 1 m m i=1 f i (x i ) -E x∼D [f (x)]| ≥ ≤ 2e -2 2 m 2 P i (b i -a i ) 2 (7.1) where E x∼D [f (x)] = 1 m m i=1 f i (x)D(x)dx. In our case f i (x i ) = 1 iff h(x i ) = y i and a i = 0, b i = 1. Therefore (1/m) i f i (x i ) = ê rr(h) and err(h) = E x∼D [f (x)]. The Hoeffding bound almost does what we need, but not quite so. What we have is that for any given hypothesis h ∈ C, the empirical error is close to the true error with high probability. Recall that our goal is to minimize err(h) over all possible h ∈ C but we can access only ê rr(h). If we can guarantee that the two are close to each other for every h ∈ C, then minimizing ê rr(h) over all h ∈ C will approximately minimize err(h). Put formally, in order to ensure that L learns the class C, we must show that prob max h∈C | ê rr(h) -err(h)| < > 1 -δ In other words, we need to show that the empirical errors converge (at high probability) to the true errors uniformly over C as m → ∞. If that can be guaranteed, then with (high) probability 1 -δ, for every h ∈ C, err(h) -< ê rr(h) < err(h) + . So, since the algorithm L running on training set Z returns h = L(Z) which minimizes the empirical error, we have: err(L(Z)) ≤ ê rr(L(Z)) + = min h ê rr(h) + ≤ Opt(C) + 2 , which is what is needed in order that L learns C. Thus, what is left is to prove the following claim: Claim 11 prob max h∈C | ê rr(h) -err(h)| ≥ ≤ 2|C|e -2 2 m Proof: We will use the union bound. Finding the maximum over C is equivalent to taking the union of all the events: prob max h∈C | ê rr(h) -err(h)| ≥ = prob h∈C {Z : | ê rr(h) -err(h)| ≥ } , using the union-bound and Claim 2, we have: ≤ h∈C prob [| ê rr(h) -err(h)| ≥ ] ≤ |C|2e (-2 2 m) . Finally, given that 2|C|e -2 2 m ≤ δ we obtain the sample complexity: m 0 = 2 2 ln 2|C| δ . This discussion is summarized with the following theorem (Anthony & Bartlett [1], pp. 21): Theorem 6 Let C be a finite set of functions from X to Y = {0, 1}. Let L be an algorithm such that for any m and for any training set Z = {(x i , y i )}, i = 1, ..., m, then the hypothesis L(Z) satisfies: ê rr(L(Z)) = min h∈C ê rr(h). Then L is a learning algorithm for C with sample complexity m 0 = 2 2 ln 2|C| δ . Note that the main difference with the realizable case (Theorem 1) is the larger 1/ 2 rather than 1/ . The realizable case requires a smaller training set since we are estimating a random quantity so the smaller the variance the less data we need. dinality -note that the bound above is not meaningful when |C| = ∞. Can we learn in the formal sense any non-trivial infinite concept class? (we already saw an example of a PAC-learnable infinite concept class which is the class of axes aligned rectangles). In order to answer this question we will need to a general measure of concept class complexity which will replace the cardinality term |C| in the sample complexity bound m o ( , δ). It is tempting to assume that the number of parameters which fully describe the concepts of C can serve as such a measure, but we will show that in fact one needs a more powerful measure called the Vapnik-Chervonenkis (VC) dimension. Our second goal is to pave the way and provide the theoretical foundation for the large margin principle algorithm (SVM) we derived in Lecture 4. The VC Dimension The basic principle behind the VC dimension measure is that although C may have infinite cardinality, the restriction of the application of concepts in C to a finite sample S has a finite outcome. This outcome is typically governed by an exponential growth with the size m of the sample S -but not always. The point at which the growth stops being exponential is when the \"complexity\" of the concept class C has exhausted itself, in a manner of speaking. We will assume C is a concept class over the instance space X -both of which can be infinite. We also assume that the concept class maps instances in X to {0, 1}, i.e., the input instances are mapped to \"positive\" or \"negative\" labels. A training sample S is drawn i.i.d according to some fixed but unknown distribution D and S consists of m instances x 1 , ..., x m . In our notations we will try to reserve c ∈ C to denote the target concept and h ∈ C to denote some concept. We begin with the following definition: Consider as an example a finite concept class C = {c 1 , ..., c 4 } applied to three instance vectors with the results: Definition 2 Π C (S) = {(h(x 1 ), ..., h(x m ) : h ∈ C} which is a set of vectors in {0, 1} m . Π C (S) x 1 x 2 x 3 c 1 1 1 1 c 2 0 1 1 c 3 1 0 0 c 4 0 0 0 Then, Π C ({x 1 }) = {(0), (1)} shattered Π C ({x 1 , x 3 }) = {(0, 0), (0, 1), (1, 0), (1, 1)} shattered Π C ({x 2 , x 3 }) = {(0, 0), (1, 1)} not shattered With these definitions we are ready to describe the measure of concept class complexity. The VC dimension of a class of functions C is the point d at which all samples S with cardinality |S| > d are no longer shattered by C. As long as C shatters S it manifests its full \"richness\" in the sense that one can obtain from S all possible results (dichotomies). Once that ceases to hold, i.e., when |S| > d, it means that C has \"exhausted\" its richness (complexity). An infinite VC dimension means that C maintains full richness for all sample sizes. Therefore, the VC dimension is a combinatorial measure of a function class complexity. Before we consider a number of examples of geometric concept classes and their VC dimension, it is important clarify the lower and upper bounds (existential and universal quantifiers) in the definition of VC dimension. The VC dimension is at least d if there exists some sample |S| = d which is shattered by C -this does not mean that all samples of size d are shattered by C. Conversely, in order to show that the VC dimension is at most d, one must show that no sample of size d + 1 is shattered. Naturally, proving an upper bound is more difficult than proving the lower bound on the VC dimension. The following examples are shown in a \"hand waiving\" style and are not meant to form rigorous proofs of the stated bounds -they are shown for illustrative purposes only. Intervals of the real line: The concept class C is governed by two parameters α 1 , α 2 in the closed interval [0, 1]. A concept from this class will tag an input instance 0 < x < 1 as positive if α 1 ≤ x ≤ α 2 and negative otherwise. The VC dimension is at least 2: select a sample of 2 points x 1 , x 2 positioned in the open interval (0, 1). We need to show that there are values of α 1 , α 2 which realize all the possible four dichotomies (+, +), (-, -), (+, -), (-, +). This is clearly possible as one can place the interval [α 1 , α 2 ] such the intersection with the interval [x 1 , x 2 ] is null, (thus producing (-, -)), or to fully include [x 1 , x 2 ] (thus producing (+, +)) or to partially intersect [x 1 , x 2 ] such that x 1 or x 2 are excluded (thus producing the remaining two dichotomies). To show that the VC dimension is at most 2, we need to show that any sample of three points x 1 , x 2 , x 3 on the line (0, 1) cannot be shattered. It is sufficient to show that one of the dichotomies is not realizable: the labeling (+, -, +) cannot be realizable by any interval [α 1 , α 2 ] -this is because if x 1 , x 3 are labeled positive then by definition the interval [α 1 , α 2 ] must fully include the interval [x 1 , x 3 ] and since x 1 < x 2 < x 3 then x 2 must be labeled positive as well. Thus V Cdim(C) = 2. Axes-aligned rectangles in the plane: We have seen this concept class in the previous lecture -a point in the plane is labeled positive if it lies in an axes-aligned rectangle. The concept class C is thus governed by 4 parameters. The VC dimension is at least 4: consider a configuration of 4 input points arranged in a cross pattern (recall that we need only to show some sample S that can be shattered). We can place the rectangles (concepts of the class C) such that all 16 dichotomies can be realized (for example, placing the rectangle to include the vertical pair of points and exclude the horizontal pair of points would induce the labeling (+, -, +, -)). It is important to note that in this case, not all configurations of 4 points can be shattered -but to prove a lower bound it is sufficient to show the existence of a single shattered set of 4 points. To show that the VC dimension is at most 4, we need to prove that any set of 5 points cannot be shattered. For any set of 5 points there must be some point that is \"internal\", i.e., is neither the extreme left, right, top or bottom point of the five. If we label this internal point as negative and the remaining 4 points as positive then there is no axes-aligned rectangle (concept) which cold realize this labeling (because if the external 4 points are labeled positive then they must be fully within the concept rectangle, but then the internal point must also be included in the rectangle and thus labeled positive as well). Separating hyperplanes: Consider first linear half spaces in the plane. The lower bound on the VC dimension is 3 since any three (non-collinear) points in R 2 can be shattered, i.e., all 8 possible labelings of the three points can be realized by placing a separating line appropriately. By having one of the points on one side of the line and the other two on the other side we can realize 3 dichotomies and by placing the line such that all three points are on the same side will realize the 4th. The remaining 4 dichotomies are realized by a sign flip of the four previous cases. To show that the upper bound is also 3, we need to show that no set of 4 points can be shattered. We consider two cases: (i) the four points form a convex region, i.e., lie on the convex hull defined by the 4 points, (ii) three of the 4 points define the convex hull and the 4th point is internal. In the first case, the labeling which is positive for one diagonal pair and negative to the other pair cannot be realized by a separating line. In the second case, a labeling which is positive for the three hull points and negative for the interior point cannot be realize. Thus, the VC dimension is 3 and in general the VC dimension for separating hyperplanes in R n is n + 1. Union of a finite number of intervals on the line: This is an example of a concept class with an infinite VC dimension. For any sample of points on the line, one can place a sufficient number of intervals to realize any labeling. The examples so far were simple enough that one might get the wrong impression that there is a correlation between the number of parameters required to describe concepts of the class and the VC dimension. As a counter example, consider the two parameter concept class: C = {sign(sin(ωx + θ) : ω} which has an infinite VC dimension as one can show that for every set of m points on the line one can realize all possible labelings by choosing D means that the S ⊂ S and outputs a consistent hypothesis h ∈ C. The probability of error for each x i ∈ S is: prob(c t (x i ) = h(x i )) = 1 2 . The reason for that is because S is shattered by C, i.e., we can select any target concept for any labeling of S (the 2m examples) therefore we could select the labels of the m points not seen by the learner arbitrarily (by flipping a coin). Regardless of h, the probability of mistake is 0.5. The expectation on the error of h is: E[err(h)] = m • 0 • 1 2m + m • 1 2 • 1 2m = 1 4 . This is because we have 2m points to sample (according to D as all other points have zero probability) from which the error on half of them is zero (as h is consistent on the training set S) and the error on the remaining half is 0.5. Thus, the average error is 0.25. Note that E[err(h)] = 0.25 for any choice of , δ as it is based on the sample size m. For any sample size m we can follow the construction above and generate the learning problem such that if the learner produces a consistent hypothesis the expectation of the error will be 0.25. The result that E[err(h)] = 0.25 is not possible for the accuracy and confidence values we have set: with probability of at least 0.9 we have that err(h) ≤ 0.1 and with probability 0.1 then err(h) = β where 0.1 < β ≤ 1. Taking the worst case of β = 1 we come up with the average error: E[err(h)] ≤ 0.9 • 0.1 + 0.1 • 1 = 0.19 < 0.25. We have therefore arrived to a contradiction that C is PAC learnable. We next obtain a bound on the growth of |Π S (C)| when the sample size |S| = m is much larger than the VC dimension V Cdim(C) = d of the concept class. We will need few more definitions: As a direct result of this observation, when m >> d is much larger than d the entropy becomes much smaller than m. Recall than from an information theoretic perspective, the entropy of a random variable Z with discrete values z 1 , ..., z n with probabilities p i , i = 1, ..., n is defined as: H(Z) = n i=0 p i log 2 1 p i , where I(p i ) = log 2 1 p i is a measure of \"information\", i.e., is large when p i is small (meaning that there is much information in the occurrence of an unlikely event) and vanishes when the event is certain p i = 1. The entropy is therefore the expectation of information. Entropy is maximal for a uniform distribution H(Z) = log 2 n. The entropy in information theory context can be viewed as the number of bits required for coding z 1 , ..., z n . In coding theory it can be shown that the entropy of a distribution provides the lower bound on the average length of any possible encoding of a uniquely decodable code fro which one symbol goes into one symbol. When the distribution is uniform we will need the maximal number of bits, i.e., one cannot compress the data. In the case of concept class C with VC dimension d, we see that one when m ≤ d all possible dichotomies are realized and thus one will need m bits (as there are 2 m dichotomies) for representing all the outcomes of the sample. However, when m >> d only a small fraction of the 2 m dichotomies can be realized, therefore the distribution of outcomes is highly non-uniform and thus one would need much less bits for coding the outcomes of the sample. The technical results which follow are therefore a formal way of expressing in a rigorous manner this simple truth -If it is possible to compress, then it is possible to learn. The crucial point is that learnability is a direct consequence of the \"phase transition\" (from exponential to polynomial) in the growth of the number of dichotomies realized by the concept class. In the next lecture we will continue to prove the \"double sampling\" theorem which derives the sample size complexity as a function of the VC dimension. c ∩ S be the subset of S induced by the target concept c. The set s (a subset of S) is realized by some concept h (those points in S which were labeled positive by h). Therefore, the set s ∩ (c ∩ S) is the subset of S containing the points that hit the region h∆c which is an element of Π ∆(c) (S). Since this is a one-to-one mapping we have that |Π contains sample points from 0 to 1 with increments of /2. Therefore, every interval larger than must be hit by at least one point from S and by definition S is an -net. It is important to note that if S forms an -net then we are guaranteed that err(h) ≤ . Let h ∈ C be the consistent hypothesis with S (returned by the learning algorithm L). Becuase h is consistent, h∆c ∈ ∆(c) has not been hit by S (recall that h∆c is the error region with respect to the target concept c, thus if h is consistent then it agrees with c over S and therefore S does not hit h∆c). Since S forms an -net for ∆(c) we must have h∆c ∈ ∆ (c) (recall that by definition S hits all error regions with weight larger than ). As a result, the error region h∆c must have a weight smaller than which means that err(h) ≤ . The conclusion is that if we can bound the probability that a random sample S does not form an -net for ∆(c), then we have bounded the probability that a concept h consistent with S has err(h) > . This is the goal of the proof of the double-sampling theorem which we are about to prove below: Proof (following Kearns & Vazirani [3] pp. 59-61): Let S 1 be a random sample of size m (sampled i.i.d. according to the unknown distribution D) and let A be the event that S 1 does not form an -net for ∆(c). From the preceding discussion our goal is to upper bound the probability for A to occur, i.e., prob(A) ≤ δ. If A occurs, i.e., S 1 is not an -net, then by definition there must be some region r ∈ ∆ (c) which is not hit by S 1 , that is S 1 ∩ r = ∅. Note that r = h∆(c) for some concept h which is consistent with S 1 . At this point the space of possibilities is infinite, because the probability that we fail to hit h∆(c) in m random examples is at most (1 -) m . Thus the probability that we fail to hit some h∆c ∈ ∆ (c) is bounded from above by |∆(c)|(1 -) m -which does not help us due to the fact that |∆(c)| is infinite. The idea of the proof is to turn this into a finite space by using another sample, as follows. Let S 2 be another random sample of size m. We will select m (for both S 1 and S 2 ) to guarantee a high probability that S 2 will hit r many times. In fact we wish that S 2 will hit r at least m 2 with probability of at least 0.5: prob(|S 2 ∩ r| > m 2 ) = 1 -prob(|S 2 ∩ r| ≤ m 2 ). We will use the Chernoff bound (lower tail) to obtain a bound on the righthand side term. Recall that if we have m Bernoulli trials (coin tosses) Z 1 , ..., Z m with expectation E(Z i ) = p and we consider the random variable Z = Z 1 + ... + Z m with expectation E(Z) = µ (note that µ = pm) then for all 0 < ψ < 1 we have: prob(Z < (1 -ψ)µ) ≤ e -µψ 2 2 . Considering the sampling of m examples that form S 2 as Bernoulli trials, we have that µ ≥ m (since the probability that an example will hit r is at least ) and ψ = 0.5. We obtain therefore: prob(|S 2 ∩ r| ≤ (1 - 1 2 ) m) ≤ e -m 8 = 1 2 which happens when m = 8 ln 2 = O( 1 ). To summarize what we have obtained so far, we have calculated the probability that S 2 will hit r many times given that r was fixed using the previous sampling, i.e., given that S 1 does not form an -net. To formalize this, let B denote the combined event that S 1 does not form an -event and S 2 hits r at least m/2 times. Then, we have shown that for m = O(1/ ) we have: prob(B/A) ≥ 1 2 . From this we can calculate prob(B): This is because the occurrence of the event B is equivalent to saying that there is some r ∈ Π ∆ (c) (S 1 ∪ S 2 ) such that |r| ≥ m/2 (i.e., the region r is hit at least m/2 times) and S 1 ∩ r = ∅. This is because Π ∆ (c) (S 1 ∪ S 2 ) contains all the subsets of S 1 ∪ S 2 realized as intersections over all regions in ∆ (c). Thus even though we have an infinite number of regions we still have a finite number of subsets. We wish therefore to analyze the following probability: prob r ∈ Π ∆ (c) (S 1 ∪ S 2 ) : |r| ≥ m/2 and S 1 ∩ r = ∅ . Let S = S 1 ∪S 2 a random sample of 2m (note that since the sampling is i.i.d. it is equivalent to sampling S 1 and S 2 separately) and r satisfying |r| ≥ m/2 being fixed. Consider some random partitioning of S into S 1 and S 2 and consider then the problem of estimating the probability that S 1 ∩ r = ∅. This problem is equivalent to the following combinatorial question: we have 2m balls, each colored Red or Blue, with exaclty l ≥ m/2 Red balls. We divide the 2m balls into groups of equal size S 1 and S 2 and we are interested in bounding the probability that all of the l balls fall in S 2 (that is, the probability that S 1 ∩ r = ∅). This in turn is equivalent to first dividing the 2m uncolored balls into S 1 and S 2 groups and then randomly choose l of the balls to be colored Red and analyze the probability that all of the Red balls fall into S 2 . This probability is exactly m l 2m l = l-1 i=0 m -i 2m -i ≤ l-1 i=0 1 2 = 1 2 l = 2 -m/2 . This probability was evaluated for a fixed S and r. Thus, the probability that this occurs for some r ∈ Π ∆ (c) (S) satisfying |r| ≥ m/2 (which is prob(B)) can be calculated by summing over all possible fixed r and applying the union bound prob( i Z i ) ≤ i prob(Z i ): Taken together, we have arrived to a fairly remarkable result. Despite the fact that the distribution D from which the training sample S is drawn from is unknown (but is known to be fixed), the learner simply needs to minimize the empirical error. If the sample size m is large enough the learner is guaranteed to have minimized the true errors for some accuracy and confidence parameters which define the sample size complexity. Equivalently, |Opt(C) -ê rr(h)| -→ m→∞ 0. Not only is the convergence is independent of D but also the rate of convergence is independent (namely, it does not matter where the optimal h * is located). The latter is very important because without it one could arbitrarily slow down the convergence rate by maliciously choosing D. The beauty of the results above is that D does not have an effect at all -one simply needs to choose the sample size to be large enough for the accuracy, confidence and VC dimension of the concept class to be learned over. Optimality of SVM Revisited In Lecture 4 we discussed the large margin principle for finding an optimal separating hyperplane. It is natural to ask how does the PAC theory presented so far explains why a maximal margin hyperplane is optimal with regard to the formal sense of learning (i.e. to generalization from empirical errors to true errors)? We saw in the previous section that the sample complexity m( , δ, d) depends also on the VC dimension of the concept classwhich is n + 1 for hyperplanes in R n . Thus, another natural question that may certainly arise is what is the gain in employing the \"kernel trick\"? For a fixed m, mapping the input instance space X of dimension n to some higher (exponentially higher) feature space might simply mean that we are compromising the accuracy and confidence of the learner (since the VC dimension is equal to the instance space dimension plus 1). Given a fixed sample size m, the best the learner can do is to minimize the empirical error and at the same time to try to minimize the VC dimension d of the concept class. The smaller d is, for a fixed m, the higher the accuracy and confidence of the learning algorithm. Likewise, the smaller d is, for a fixed accuracy and confidence values, the smaller sample size is required. There are two possible ways to decrease d. First is to decrease the dimension n of the instance space X. This amounts to \"feature selection\", namely find a subset of coordinates that are the most \"relevant\" to the learning task r perform a dimensionality reduction via PCA, for example. A second approach is to maximize the margin. Let the margin associated with the separating hyperplane h (i.e. consistent with the sample S) be γ. Let the input vectors x ∈ X have a bounded norm, |x| ≤ R. It can be shown that the VC dimension of the concept class C γ of hyperplanes with margin γ is: C γ = min R 2 γ 2 , n + 1. Thus, if the margin is very small then the VC dimension remains n + 1. As the margin gets larger, there comes a point where R 2 /γ 2 < n and as a result the VC dimension decreases. Moreover, mapping the instance space X to some higher dimension feature space will not change the VC dimension as A0.2 Derivatives of Matrix Operations: Scalar Functions of a Vector The two most important examples of a scalar function of a vector x are the linear form a x and the quadratic form x Ax for some square matrix A. where f : R n → R and h : R n → R k where h is a vector function (h 1 , ..., h k ) each from R n to R. We want to derive a necessary and sufficient constraint for a point x o to be a local minimum subject to the k equality constraints h(x) = 0. Assume that x o is a regular point, meaning that the gradient vectors ∇h j (x) are linearly independent. Note that ∇h(x o ) is a k ×n matrix and the null space of this matrix: e., P (C | +). Using Bayes rule: P (C | +) = P (+ | C)P (C) P (+) = P (+ | C)P (C) P (+ | C)P (C) + P (+ | H)P (H) = 0.266 P (y | D, θ (t) ) log P (D, y | θ). Fig. 4 4 Fig. 4.1. Separating hyperplane w, b with maximal margin. The boundary points are associated with non-vanishing Lagrange multipliers µ i > 0 and margin errors are associated with i > 0 where the criteria function encourages a small number of margin errors. Fig. 5 5 Fig. 5.1. Linear discriminant analysis based on class centers alone is not sufficient.Seeking a projection which maximizes the distance between the projected centers will prefer the horizontal axis over the vertical, yet the two classes overlap on the horizontal axis. The projected distance along the vertical axis is smaller yet the classes are better separated. The conclusion is that the sample variance of the two classes must be taken into consideration as well. Fig. 7 7 Fig. 7.1. Given the tightest-fit to positive examples strategy we have that R ⊂ R.The strip T 1 has weight /4 and the strip T 1 is defined as the upper strip covering the area between R and R . is set whose members are m-dimensional Boolean vectors induced by functions of C. These members are often called dichotomies or behaviors on S induced or realized by C. If C makes a full realization then Π C (S) will have 2 m members. An equivalent description is a collection of subsets of S:Π C (S) = {h ∩ S : h ∈ C}where each h ∈ C makes a partition of S into two sets -the positive and negative points. The set Π C (S) contains therefore subsets of S (the positive points of S under h). A full realization will provide m i=0 m i = 2 m . We will use both descriptions of Π C (S) as a collection of subsets of S and as a set of vectors interchangeably. Definition 3 If |Π C (S)| = 2 m then S is considered shattered by C. In other words, S is shattered by C if C realizes all possible dichotomies of S. Definition 4 ( 4 VC dimension) The VC dimension of C, noted as V Cdim(C), is the cardinality d of the largest set S shattered by C. If all sets S (arbitrarily large) can be shattered by C, then V Cdim(C) = ∞. V Cdim(C) = max{d | ∃|S| = d, and |Π C (S)| = 2 d } Definition 5 ( 5 Growth function) Π C (m) = max{|Π S (C)| : |S| = m} The measure Π C (m) is the maximum number of dichotomies induced by C for samples of size m. As long as m ≤ d then Π C (m) = 2 m . The question is what happens to the growth pattern of Π C (m) when m > d. We will see that the growth becomes polynomial -a fact which is crucial for the learnability of C. Definition 6 For any natural numbers m, d we have the following definition:Φ d (m) = Φ d (m -1) + Φ d-1 (m -1) Φ d (0) = Φ 0 (m) = 1By induction on m, d it is possible to prove the following:Proof: by induction on m, d. For details see[[3], pp. 56].For m ≤ d we have that Φ d (m) = 2 m . For m > d we can derive a polynomial upper bound as follows. C (S)| = |Π ∆(c) (S)|.Definition 9 ( -net) For every > 0, a sample set S is an -net for ∆(c) if every region in ∆ (c) is hit by at least one point of S:∀r ∈ ∆ (c), S ∩ r = ∅.In other words, if S hits all the error regions in ∆(c) whose weight exceeds , then S is an -net. Consider as an example the concept class of intervals on the line [0, 1]. A concept is defined by an interval [α 1 , α 2 ] such that all points inside the interval are positive and all those outside are negative. Given c ∈ C is the target concept and h ∈ C is some concept, then the error region h∆c is the union of two intervals: I 1 consists of all points x ∈ h which are not in c, and I 2 the interval of all points x ∈ c but which are not in h. Assume that the distribution D is uniform (just for the sake of this example) then, prob(x ∈ I) = |I| which is the length of the interval I. As a result, err(h) > if either |I 1 | > /2 or |I 2 | > /2. The sample set S = {x = k 2 : k = 0, 1, ..., 2/ } our original goal of bounding prob(A) is equivalent to finding a bound prob(B) ≤ δ/2 because prob(A) ≤ 2 • prob(B) ≤ δ. The crucial point with the new goal is that to analyze the probability of the event B, we need only to consider a finite number of possibilities, namely to consider the regions ofΠ ∆ (c) (S 1 ∪ S 2 ) = {r ∩ {S 1 ∪ S 2 } : r ∈ ∆ (c)} . prob(B) ≤ |Π ∆ (c) (S)|2 -m/2 ≤ |Π ∆(c) (S)|2 -m/2 = |Π C (S)|2 -mFew comments are worthwhile at this point: (i) It is possible to show that the upper bound on the sample complexity m is tight by showing that the lower bound on m is Ω(d/ ) (see [[3], pp. 62]). (ii) The treatment above holds also for the unrealizable case (target concept c ∈ C) with slight modifications to the bound. In this context, the learning algorithm L must simply minimize the sample (empirical) error ê rr(h) defined:ê rr(h) = 1 m |{i : h(x i ) = y i }| x i ∈ S.The generalization of the double-sampling theorem (Derroye'82) states that the empirical errors converge uniformly to the true errors: prob max h∈C | êrr(h) -err(h)| ≥ ≤ 4e (4 +4 2 ) d(a x) = a dx d(x Ax) = (dx) Ax + x A(dx) = (dx) Ax + x A(dx) = x (A + A )dxwhere the derivative d(x Ax) using the rule of products d(f• g) = (df ) • g + f • (dg)where g = Ax and f = x and noting that d(Ax) = Adx. Thus,d dx (a x) = a and d dx (x Ax)) = x (A + A ). If A is symmetric then d dx (x Ax)) = (2Ax) .A0.3 Primer on Constrained OptimizationA0.3.1 Equality Constraints and Lagrange MultipliersConsider first the general optimization with equality constraints which gives rise to the notion of Lagrange multipliers. null(∇h(x o )) = {y : ∇h(x o )y = 0} defines the tangent plane at the point x o . We have the following fundamental theorem:∇f (x o ) ⊥ null(∇h(x o ))in other words, all vectors y spanning the tangent plane at the point x o are also perpendicular to the gradient of f at x o . † This example is adopted from Yishai Mansour's class notes on Machine Learning. † adopted from Ron Rivest's 1994 class notes. † The fact that non-negativity \"comes for free\" does not apply for all class (distribution) models.This point would be refined in the next lecture. † this manner of deriving EM was adapted from Jordan and Bishop's book notes, 2001."
}