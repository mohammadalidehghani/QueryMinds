{
  "title": "An Introduction to MM Algorithms for Machine Learning and Statistical Estimation",
  "abstract": "MM (majorization-minimization) algorithms are an increasingly popular tool for solving optimization problems in machine learning and statistical estimation. This article introduces the MM algorithm framework in general and via three popular example applications: Gaussian mixture regressions, multinomial logistic regressions, and support vector machines. Specific algorithms for the three examples are derived and numerical demonstrations are presented. Theoretical and practical aspects of MM algorithm design are discussed.",
  "introduction": "Introduction Let X ∈ X ⊂ R p and Y ∈ Y ⊂ R q be random variables, which we shall refer to as the input and target variables, respectively. We shall denote a sample of n independent and identically distributed (IID) pairs of variables D = {(X i , Y i )} n i=1 1 arXiv:1611.03969v1 [stat.CO] 12 Nov 2016 as the data, and D = {(x i , y i )} n i=1 as an observed realization of the data. Under the empirical risk minimization (ERM) framework of Vapnik (1998, Ch. 1) or the extremum estimation (EE) framework of Amemiya (1985, Ch. 4 ), a large number of machine learning and statistical estimation problems can be phrased as the computation of min θ∈Θ R θ; D or θ = arg min θ∈Θ R θ; D , (1) where R θ; D is a risk function defined over the observed data D and is dependent on some parameter θ ∈ Θ. Common risk functions that are used in practice are the negative log-likelihood functions, which can be expressed as When Y = {-1, 1}, a common problem in machine learning is to construct a classification function f (x i ; θ) that minimizes the classification (0-1) risk R θ; D = - 1 n n i=1 log f (x i , y i ; θ) , R θ; D = 1 n n i=1 I {y i = f (x i ; θ)} , where f : X → Y and I {A} = 1 if proposition A is true and 0 otherwise. Unfortunately, the form of the classification risk is combinatorial and thus necessitates the use of surrogate classification risks of the form R θ; D = 1 n n i=1 ψ (x i , y i , f (x i ; θ)) , where ψ : R p ×{-1, 1} 2 → [0, ∞) and ψ (x, y, y) = 0 for all x and y [cf. Scholkopf & Smola (2002, Def. 3.1) ]. An example of a machine learning algorithm that minimizes a surrogate classification risk is the support vector machine (SVM) of Cortes & Vapnik (1995) . The linear-basis SVM utilizes a surrogate risk function, where ψ (x, y, f (x; θ)) = max {0, 1yf (x; θ)}is the hinge loss function, f (x; θ) = α + β x, and θ = α, β ∈ Θ ⊂ R p+1 . The task of computing (1) may be complicated by various factors that fall outside the scope of the traditional calculus formulation for optimization [cf. Khuri (2003, Ch. 7) ]. Such factors include the lack of differentiability of R or difficulty in obtaining closed-form solutions to the first-order condition (FOC) equation ∇ θ R = 0, where ∇ θ is the gradient operator with respect to θ, and 0 is a zero vector. The MM (majorization-minimization) algorithm framework is a unifying paradigm for simplifying the computation of (1) when difficulties arise, via iterative minimization of surrogate functions. MM algorithms are particularly attractive due to the monotonicity and thus stability of their objective sequences as well as global convergence of their limits, in general settings. A comprehensive treatment on the theory and implementation of MM algorithms can be found in Lange (2016) . Summaries and tutorials on MM algorithms for various problems can be found in Becker et al. (1997) , Hunter & Lange (2004) , Lange (2013, Ch. 8) , Lange et al. (2000) , Lange et al. (2014) , McLachlan & Krishnan (2008, Sec. 7 .7), Wu & Lange (2010), and Zhou et al. (2010) . Some theoretical analyses of MM algorithms can be found in de Leeuw & Lange (2009) , Lange (2013, Sec. 12.4) , Mairal (2015), and Vaida (2005) . It is known that MM algorithms are generalizations of the EM (expectationmaximization) algorithms of Dempster et al. (1977) [cf. Lange (2013, Ch. 9) ]. The recently established connection between MM algorithms and the successive upper-bound maximization (SUM) algorithms of Razaviyayn et al. (2013) further shows that the MM algorithm framework also covers the concave-convex procedures [Yuille & Rangarajan (2003) ; CCCP], proximal algorithms (Parikh & Boyd, 2013) , forward-backward splitting algorithms [Combettes & Pesquet (2011) ; FBS], as well as various incarnations of iteratively-reweighed leastsquares algorithms (IRLS) such as those of Becker et al. (1997) and Lange et al. (2000) ; see Hong et al. (2016) for details. It is not possible to provide a complete list of applications of MM algorithms to machine learning, statistical estimation, and signal processing problems. We present a comprehensive albeit incomplete summary of applications of MM algorithms in Table 1 . Further examples and references can be found in Hong et al. (2016) and Lange (2016) . In this article, we will present the MM algorithm framework via applications to three examples that span the scope of statistical estimation and machine learning problems: Gaussian mixtures of regressions (GMR), multinomiallogistic regressions (MLR), and SVM estimations. The three estimation prob-Table 1 : MM algorithm applications and references.",
  "body": "Introduction Let X ∈ X ⊂ R p and Y ∈ Y ⊂ R q be random variables, which we shall refer to as the input and target variables, respectively. We shall denote a sample of n independent and identically distributed (IID) pairs of variables D = {(X i , Y i )} n i=1 1 arXiv:1611.03969v1 [stat.CO] 12 Nov 2016 as the data, and D = {(x i , y i )} n i=1 as an observed realization of the data. Under the empirical risk minimization (ERM) framework of Vapnik (1998, Ch. 1) or the extremum estimation (EE) framework of Amemiya (1985, Ch. 4 ), a large number of machine learning and statistical estimation problems can be phrased as the computation of min θ∈Θ R θ; D or θ = arg min θ∈Θ R θ; D , (1) where R θ; D is a risk function defined over the observed data D and is dependent on some parameter θ ∈ Θ. Common risk functions that are used in practice are the negative log-likelihood functions, which can be expressed as When Y = {-1, 1}, a common problem in machine learning is to construct a classification function f (x i ; θ) that minimizes the classification (0-1) risk R θ; D = - 1 n n i=1 log f (x i , y i ; θ) , R θ; D = 1 n n i=1 I {y i = f (x i ; θ)} , where f : X → Y and I {A} = 1 if proposition A is true and 0 otherwise. Unfortunately, the form of the classification risk is combinatorial and thus necessitates the use of surrogate classification risks of the form R θ; D = 1 n n i=1 ψ (x i , y i , f (x i ; θ)) , where ψ : R p ×{-1, 1} 2 → [0, ∞) and ψ (x, y, y) = 0 for all x and y [cf. Scholkopf & Smola (2002, Def. 3.1) ]. An example of a machine learning algorithm that minimizes a surrogate classification risk is the support vector machine (SVM) of Cortes & Vapnik (1995) . The linear-basis SVM utilizes a surrogate risk function, where ψ (x, y, f (x; θ)) = max {0, 1yf (x; θ)}is the hinge loss function, f (x; θ) = α + β x, and θ = α, β ∈ Θ ⊂ R p+1 . The task of computing (1) may be complicated by various factors that fall outside the scope of the traditional calculus formulation for optimization [cf. Khuri (2003, Ch. 7) ]. Such factors include the lack of differentiability of R or difficulty in obtaining closed-form solutions to the first-order condition (FOC) equation ∇ θ R = 0, where ∇ θ is the gradient operator with respect to θ, and 0 is a zero vector. The MM (majorization-minimization) algorithm framework is a unifying paradigm for simplifying the computation of (1) when difficulties arise, via iterative minimization of surrogate functions. MM algorithms are particularly attractive due to the monotonicity and thus stability of their objective sequences as well as global convergence of their limits, in general settings. A comprehensive treatment on the theory and implementation of MM algorithms can be found in Lange (2016) . Summaries and tutorials on MM algorithms for various problems can be found in Becker et al. (1997) , Hunter & Lange (2004) , Lange (2013, Ch. 8) , Lange et al. (2000) , Lange et al. (2014) , McLachlan & Krishnan (2008, Sec. 7 .7), Wu & Lange (2010), and Zhou et al. (2010) . Some theoretical analyses of MM algorithms can be found in de Leeuw & Lange (2009) , Lange (2013, Sec. 12.4) , Mairal (2015), and Vaida (2005) . It is known that MM algorithms are generalizations of the EM (expectationmaximization) algorithms of Dempster et al. (1977) [cf. Lange (2013, Ch. 9) ]. The recently established connection between MM algorithms and the successive upper-bound maximization (SUM) algorithms of Razaviyayn et al. (2013) further shows that the MM algorithm framework also covers the concave-convex procedures [Yuille & Rangarajan (2003) ; CCCP], proximal algorithms (Parikh & Boyd, 2013) , forward-backward splitting algorithms [Combettes & Pesquet (2011) ; FBS], as well as various incarnations of iteratively-reweighed leastsquares algorithms (IRLS) such as those of Becker et al. (1997) and Lange et al. (2000) ; see Hong et al. (2016) for details. It is not possible to provide a complete list of applications of MM algorithms to machine learning, statistical estimation, and signal processing problems. We present a comprehensive albeit incomplete summary of applications of MM algorithms in Table 1 . Further examples and references can be found in Hong et al. (2016) and Lange (2016) . In this article, we will present the MM algorithm framework via applications to three examples that span the scope of statistical estimation and machine learning problems: Gaussian mixtures of regressions (GMR), multinomiallogistic regressions (MLR), and SVM estimations. The three estimation prob-Table 1 : MM algorithm applications and references. Application References Bradley-Terry models estimation (Hunter, 2004; Lange et al., 2000) Convex and shape-restricted regressions (Chi et al., 2014) Dirichlet-multinomial distributions estimation (Zhou & Lange, 2010; Zhou & Zhang, 2012) Elliptical symmetric distributions estimation (Becker et al., 1997) Fully-visible Boltzmann machines estimation (Nguyen & Wood, 2016) Gaussian mixtures estimation (Nguyen & McLachlan, 2015) Geometric and sigmoidal programming (Lange & Zhou, 2014) Heteroscedastic regressions (Daye et al., 2012; Nguyen et al., 2016a) Laplace regression models estimation (Nguyen & McLachlan, 2016a; Nguyen et al., 2016b) Least (Becker et al., 1997; Lange et al., 2000) Linear mixed models estimation (Lange et al., 2014) Logistic and multinomial regressions (Bohning & Lindsay, 1988; Bohning, 1992) Markov random field estimation (Nguyen et al., 2016c) Matrix completion and imputation (Mazumder et al., 2010; Lange et al., 2014) Mixture of experts models estimation (Nguyen & McLachlan, 2014 , 2016a) Multidimensional scaling (Lange et al., 2000) Multivariate t distributions estimation (Wu & Lange, 2010) Non-negative matrix factorization (Lee & Seung, 1999) Poisson regression estimation (Lange et al., 2000) Point to set minimization problems (Chi & Lange, 2014; Chi et al., 2014) Polygonal distributions estimation (Nguyen & McLachlan, 2016b) Quantile regression estimation (Hunter & Lange, 2000) SVM estimation (de Leeuw & Lange, 2009; Wu & Lange, 2010) Transmission tomography image reconstruction (De Pierro, 1993; Becker et al., 1997) Variable selection in regression via regularization (Hunter & Li, 2005; Lange et al., 2014) lems will firstly be presented in Section 2. The MM algorithm framework will be presented in Section 3 along with some theoretical results. MM algorithms for the three estimation problems are presented in Section 4. Numerical demonstrations of the MM algorithms are presented in Section 5. Conclusions are then drawn in Section 6. |•| d -norm regressions 2 Example problems Gaussian mixture of regressions Let X arise from a distribution with unknown density function f X (x), which does not depend on the parameter θ (X can be non-stochastic). Conditioned f Y |X,c (y|x; B c , Σ c ) = φ (y; B c x, Σ c ) , (2) where B c ∈ R q×p , Σ c is a positive-definite q × q matrix covariance matrix, and φ (y; µ, Σ) = (2π) -d/2 |Σ| -1/2 exp - 1 2 (y -µ) Σ (y -µ) (3) is the multivariate Gaussian distribution with mean vector µ and covariance matrix Σ. The conditional (in Z) characterization (2) leads to the marginal characterization f Y |X (y|x; θ) = g c=1 π c φ (y; B c x, Σ c ) , (4) where θ contains the parameter elements π c , B c , and Σ c , for c ∈ [g]. We refer to the characterization (4) as the GMR model. The GMR model was first proposed by Quandt (1972) for the q = 1 case and an EM algorithm for the same case was proposed in DeSarbo & Cron (1988) . To the best of our knowledge, the general multivariate case (q > 1) of characterization 4 was first considered in Jones & McLachlan (1992) . See McLachlan & Peel (2000) regarding mixture models in general. Given data D, the estimation of a GMR model requires the minimization of the negative log-likelihood risk R θ; D = - 1 n n i=1 log f Y |X (y i |x i ; θ) = - 1 n n i=1 log g c=1 π c φ (y i ; B c x i , Σ c ) . (5) The difficulty with computing (1) for ( 5 ) arises due to the lack of a closedform solution to the FOC equation ∇ θ R = 0. This is due to the log-sum-exp functional form that is embedded in each log-likelihood element. Multinomial-logistic regressions Let X arise from a distribution with unknown density function f X (x), which does not depend on the parameter θ (X can be non-stochastic). Suppose that Y = [g] for g ∈ N and let the conditional relationship between Y and X be characterized by P (Y = c|X = x; θ) = exp β c x g d=1 exp β d x , ( 6 ) where θ contains the parameter elements β c ∈ R p for c ∈ [g -1] , and β g = 0. We refer to the characterization (2.2) as the MLR model. The MLR model is a well-studied and widely applied formulation for categorical variable regression in practice. See for example Amemiya (1985, Sec. 9 .3) and Greene (2003, Sec. 21.7 .1) for a statistical and econometric perspective, and Bishop (2006, Sec. 4.3.4 ) for a McLachlan (1992, Ch. 8) for some machine learning and pattern recognition points of view. Given data D, the estimation of a MLR model requires the minimization of the negative log-likelihood risk R θ; D = - 1 n n i=1 g c=1 [P (Y = c|X = x; θ)] I{y=c} = - 1 n g c=1 n i=1 I {y i = c} β c x i + 1 n n i=1 log g c=1 exp β c x i . (7) The difficulty with computing (1) for ( 7 ), like (5), arises from the lack of a closed form solution to the FOC equation ∇ θ R = 0. Due to the general convexity of MLR risk [cf. Albert & Anderson (1984) ], the usual strategy for computing (1) is via a Newton-Raphson algorithm. Let H θ = ∇ θ ∇ θ be the Hessian operator. It is noted in Bishop (2006, Sec. 4.3.4 ) that the Hessian H θ R consists of (g -1) g/2 blocks of p × p matrices with forms ∇ βc ∇ β d R = n i=1 I {y i = c} I [c,d] -I {y i = c} x i x i , for c, d ∈ [g -1] and c ≤ d, where I is the identity matrix and I [c,d] is the element in its cth row and dth column. Since H θ R is therefore [(g -1) p] × [(g -1) p], inversion may be difficult for large values of either g or p. Thus, a method that avoids the full computation or inversion of the Hessian is desirable. Support vector machines Let X arise from a distribution with unknown density function f X (x), which does not depend on the parameter θ (X can be non-stochastic). Suppose that Y = {-1, 1} and the relationship between X and Y is unknown. For a linearbasis SVM, we wish to construct an optimal hyperplane (i.e. α + β X = 0; α ∈ R and β ∈ R p ) such that the signs of Y and α + β X are the same, with high probability. From data D, an optimal hyperplane can be estimated by computing (1) for the risk R θ; D = 1 n n i=1 I y i = sign α + β x i , (8) where sign (x) = 1 if x > 0, sign (x) = -1 if x < 0, and sign (0) = 0. Here, 8 ) is combinatorial in nature, it is difficult to manipulate. As such, a surrogate risk function can be constructed from the hinge loss function ψ (x, y, f (x; θ)) = max 0, 1y α + β x to obtain the form θ = α, β ∈ Θ ⊂ R p+1 . Since ( R θ; D = 1 n n i=1 ψ (x i , y i , f (x i ; θ)) = 1 n n i=1 max 0, 1 -y i α + β x i . Finally, it is common practice to add a quadratic penalization term to avoid overfitting to the data and improve the generalizability of the estimated hyperplane. Under penalization, the linear-basis SVM can be estimated by computing (1) for the surrogate risk R θ; D = 1 n n i=1 max 0, 1 -y i α + β x i + λβ β, (9) where λ ≥ 0 is a penalty term. The difficulty in computing (1) for ( 9 ) arises due to the lack of differentiability of (9) in θ, due to the hinge loss function. Traditionally, (1) has been computed via a constrained quadratic programming formulation of (9) using Karush-Kuhn-Tucker (KKT) conditions; see Burges (1998) for example. We will demonstrate that it is possible to compute (1) without a constrained formulation via an MM algorithm. Since the introduction of SVMs by Cortes & Vapnik (1995) , there have been numerous articles and volumes written on the topic. Some high-quality texts in the area include Herbrich (2002) , Scholkopf & Smola (2002) , and Steinwart & Christmann (2008) . MM algorithms Suppose that we wish to obtain min θ∈Θ O (θ) or θ = arg min θ∈Θ O (θ) , (10) for some difficult to manipulate objective function O, where Θ is a subset of some Euclidean space. Instead of operating on O, we can sconsider an easier to manipulate majorizer of O at some point υ ∈ Θ instead. Definition 1. We say that M (θ; υ) is a majorizer of objective O (θ) if: (i) for every θ ∈ Θ, O (θ) = M (θ; θ) holds. (ii) for every θ, υ ∈ Θ such that θ = υ, O (θ) ≤ M (θ; υ) holds. Let θ (0) be some initial value and θ (r) be a sequence of iterates (in r) for computing (10). Definition 1 suggests the following scheme that we will refer to as an MM algorithm. Definition 2. Let θ (0) be some initial value and θ (r) be the rth iterate. We say that θ (r+1) is the (r + 1) th iterate of an MM algorithm if it satisfies r) . θ (r+1) = arg min θ∈Θ M θ; θ ( From Definitions 1 and 2, we can deduce the monotonicity property of all MM algorithms. That is, if θ (r) is an sequence of MM algorithm iterates, the objective sequence O θ (r) is monotonically decreasing in r. Proposition 1. If M (θ; υ) be a majorizer of the objective O (θ) and θ (r) is a sequence of MM algorithm iterates, then O θ (r+1) ≤ M θ (r+1) ; θ (r) ≤ M θ (r) ; θ (r) = O θ (r) . (11) Remark 1. It is notable that an algorithm need not be an MM algorithm in the strict sense of Definition 2 in order for (11) to hold. In fact, any algorithm where the (r + 1) th iterate satisfies θ (r+1) ∈ θ ∈ Θ : M θ; θ (r) ≤ M θ (r) ; θ (r) will generate a monotonically decreasing sequence of objective evaluates. Such an algorithm can be thought of as a generalized MM algorithm, analogous to the generalized EM algorithms of Dempster et al. (1977) ; see also McLachlan & Krishnan (2008, Sec. 3.3) . Starting from some initial value θ (0) , let θ (∞) = lim r→∞ θ (r) be the limit point of a sequence of algorithm iterates, if it exists. The following result from Razaviyayn et al. (2013) provides a strong statement regarding the global convergence of MM algorithm iterate sequences. Proposition 2. Starting from some initial value θ (0) , if θ (∞) is the limit point of an MM algorithm sequence of iterates θ (r) (i.e. satisfying Definition 2), then θ (∞) is a stationary point of the problem (10). Remark 2. Proposition 2 only guarantees the convergence of MM algorithm iterates to a stationary point and not a global, or even a local minimum. As such, for problems over difficult objective functions, multiple or good initial values are required in order to ensure that the obtained solution is of a high quality. Furthermore, Proposition 2 only guarantees convergence to a stationary point of (10) if a limit point exists for the chosen starting value. If a limit point does not exist then the MM algorithm objective sequence may diverge. This is a common problem in ML estimation of Gaussian mixture models [cf. McLachlan & Peel (2000, Sec. 3.9.1)]. Useful majorizers There is an abundant literature on functions that can be used as majorizers and applications of such functions. Some early and fundamental works such as Becker et al. (1997) , Bohning (1992) , Bohning & Lindsay (1988) , De Pierro (1993), and Heiser (1995) established many of the basic techniques for majorization. More modern majorizers for statistical and generic optimization problems can be found in Lange (2013) , Lange (2016), and McLachlan & Krishnan (2008) . We now present three majorizers that will be useful in constructing MM algorithms for the problems from Section 2. Fact 1. Let O (θ) = ψ a θ where ψ : [0, ∞) → R is a convex function. If a, θ, υ ∈ [0, ∞) d for some d ∈ N, then O (θ) is majorized by M (θ; υ) = d c=1 a c υ c a υ ψ a υ υ c θ c , where a c , θ c , ν c are the cth elements of a, θ, υ, respectively, for c ∈ [d]. Fact 2. Let O (θ) be twice differentiable in θ. If θ, υ ∈ Θ ⊂ R d and H -H θ O is positive semidefinite for all θ, then O (θ) is majorized by M (θ; υ) = O (υ) + ∇O (υ) (θ -υ) + 1 2 (θ -υ) H (θ -υ) . Fact 3. Let d ∈ [1, 2] and let O (θ) = |θ| d . If θ, υ = 0, then O (θ) is majorized by M (θ; υ) = d 2 |υ| d-2 θ 2 + 1 - d 2 |υ| d . As an example, using Fact 3, the functions O 1 (θ) = |θ| and O 1.5 (θ) = |θ| 1.5 can be majorized at υ = 1/2 by M 1 (θ; 1/2) = θ 2 + 1/4 and M 1.5 (θ; 1/2) = 12θ 2 + 1 / 8 √ 2 , respectively. Plots of the example objectives and respective majorizers appear in Figure 1 . Examples of MM algorithms Gaussian mixture of regressions We use the notation from Section 2.1. Given the rth iterate of an MM algorithm, for each i ∈ [n], set ψ =log, and let a = (1, ..., 1), θ = (π 1 φ (y i ; B 1 x i , Σ 1 ) , ..., π g φ (y i ; B g x i , Σ g )) , and Fact 1 suggests a majorizer for (5) of the form υ = π 1 φ y i ; B (r) 1 x i , Σ (r) 1 , ..., π g φ y i ; B (r) g x i , Σ (r) M θ; θ (r) = - g c=1 n i=1 τ (r) ci [log π c + log φ (y i ; B c x i , Σ c )] + g c=1 n i=1 τ (r) ci log τ (r) ci , ( 12 ) where τ (r) ci = π c φ y i ; B (r) c x i , Σ (r) c / g d=1 π d φ y i ; B (r) d x i , Σ (r) d , for each c ∈ [g] and i ∈ [n]. Simplifying the first term of ( 12 ) via (3) yields M θ; θ (r) = - g c=1 n i=1 τ (r) ci log π c + 1 2 g c=1 n i=1 τ (r) i log |Σ c | + 1 2 g c=1 n i=1 τ (r) ci (y i -B c x i ) Σ -1 (y i -B c x i ) (13) +C (r) , where C (r) is a constant that does not depend on the parameter θ. Under the restrictions on π c , we must minimize (13) over the constrained parameter space Θ = θ : π c > 0, g c=1 π c = 1, B c ∈ R q×p , Σ c is positive definite, c ∈ [g] . This can be achieved by computing the roots of ∇ θ Λ = 0, where Λ θ; θ (r) = M θ; θ (r) + λ g c=1 π c -1 is the Lagrangian with multiplier λ ∈ R. The resulting (r + 1) th iterate of the MM algorithm for the ML estimation of the GMR model can be defined as θ (r) , which contains the elements π (r+1) c = n -1 n i=1 τ (r) ci , ( 14 ) B (r+1) c = n i=1 τ (r) ci y i x i n i=1 τ (r) ci x i x i -1 , ( 15 ) and Σ c = n i=1 τ (r) ci y i -B (r+1) c x i y i -B (r+1) c x i n i=1 τ (r) ci . ( 16 ) Remark 3. The MM algorithm defined by updates ( 14 )-( 16 ) is exactly the same as the EM algorithm for ML estimation that is derived in Jones & McLachlan (1992) . There are numerous cases where MM and EM algorithms coincide and some conditions under which such coincidences occur are explored in Meng (2000) . Remark 4. Note that updates ( 15 ) and ( 16 ) require matrix additions, multiplications, and inversions that may be computationally prohibitive if n, p, and q are large. It is possible to modify the MM algorithm via the techniques from Nguyen & McLachlan (2015) to avoid such matrix computations. Such modifications come at a cost of slower convergence of the algorithm, but can make GMR feasible for data sets that were prohibitively large without such changes. Multinomial-logistic regressions We use the notation from Section 2.2. Consider only the cth set of parameter elements β c . The gradient and second-order derivatives of R with respect to β c can be written as ∇ βc R = - 1 n n i=1 I {y i = c} - exp β c x i g d=1 exp β d x i x i and ∇ βc ∇ β c R = 1 n n i=1 exp β c x i g d=1 exp β d x i 1 - exp β c x i g d=1 exp β d x i x i x i . Define Π = exp β c x / g d=1 exp β d x ; it can be shown that Π (1 -Π) ≤ 1/4 via calculus. Thus, we have the fact that ∆/4 -∇ βc ∇ β c R is positive definite, since ∆ = n -1 n i=1 x i x i is positive definite except for in pathological cases. Let θ (r) be the rth iterate of the MM algorithm, Fact 1 yields the majorizers M c β c ; θ (r) = R θ (r) ; D + ∇ βc R θ (r) β c -β (r) c + 1 8 β c -β (r) c ∆ β c -β (r) c , (17) for each c ∈ [g -1], by setting H = ∆/4. Here, ∇ βc R θ (r) is the gradient with respect to β c , with θ evaluated at θ (r) . Given θ (r) , M c β c ; θ (r) can be globally minimized by solving the FOC equation ∇ βc M c = 0, which yields the solution β * c = β (r) c + 4∆ -1 ∇ βc R θ (r) . (18) Since only the cth parameter element is majorized by ( 17 ), the solution (18) suggests the following algorithm: let θ (r) be the rth iterate of the algorithm, on the (r + 1) th iteration, set θ (r+1) = β (r+1) 1 , ..., β (r+1) g-1 according to the update rule β (r+1) c =        β * c if c = 1 + (r mod g -1) , β (r) c otherwise. ( ) 19 Remark 5. The algorithm as defined by update rule (18) is an example of a generalized MM algorithm as discussed in Remark 1 and thus satisfies inequality (11) but does not satisfy the conditions for Proposition 2. To show the global convergence of rule (18), we can note that it is an example of a block SUM algorithm and demonstrate the satisfaction of the assumptions for Razaviyayn et al. (2013, Thm. 2 ). Remark 6. The update rule (18) allows for blockwise update of the parameter elements β c rather than all at once, as is required via a Newton-Raphson approach. Furthermore, the only large matrix computation that is required is the matrix inversion of ∆, which is only required to be conducted once as it does not depend on the iterates θ (r) . Support vector machines We use the notation from Section 2.3. Consider the identity max {a, b} = 1 2 |a -b| + a + b 2 (20) for a, b ∈ R. Using (20) and Fact 3, we can derive the majorizer M (θ; υ) = 1 4 |υ| (θ + |υ|) 2 , for the objective O (θ) = max {0, θ}, at υ = 0. To avoid the singularity at υ = 0, de Leeuw & Lange (2009) suggests the approximate majorizer M (θ; υ) = 1 4 |υ| + (θ + |υ|) 2 , (21) where = 10 -5 is sufficiently small for double-precision computing. Using (21), we can majorize (9) at the rth algorithm iterate by making the substitutions θ = 1 -y i α + β x i and υ = 1 -y i α (r) + β (r) x i , for each i ∈ [n]. The resulting majorizer of n times the risk (9) at θ (r) has the form M θ; θ (r) = n i=1 1 4w (r) i + w (r) i + 1 -y i α + β x i 2 + nλβ β, (22) where w (r) i = 1 -y i α (r) + β (r) x i , for each i. Write x i = y i , y i x i and w(r) i = w (r) i + 1 for each i, and let Ĩ = diag (0, 1, ..., 1) and Ω (r) = diag 1 4w (r) 1 + , ..., 1 4w (r) n + . Put xi in the ith row of the matrix X ∈ R n×(p+1) , and set w (r) = w(r) 1 , ..., w(r) n . We can write ( 22 ) in matrix form as M θ; θ (r) = w (r) -Xθ Ω (r) w (r) -Xθ + nλθ Ĩθ. (23) Majorizer ( 23 ) is in quadratic form and thus has the global minimum solution θ (r+1) = X Ω (r) X + nλ Ĩ -1 X Ω (r) w (r) . ( 24 ) The MM algorithm for the linear-basis SVM can thus be defined via the IRLS rule (24). Remark 7. The MM algorithm defined via ( 24 ) is similar to the IRLS algorithm of Navia-Vasquez et al. (2001) . However, whereas our weightings are obtained via simple majorization, the weightings used by Navia-Vasquez et al. (2001) are obtained via careful manipulation of the KKT conditions. 5 Numerical demonstrations Gaussian mixture of regressions There are numerous packages in the R (R Core Team, 2016) programming language that implement the EM/MM algorithm for estimating GMR models; see Remark 3. These packages include EMMIXcontrasts (Ng et al., 2014) , flexmix (Grun & Leisch, 2008) , and mixtools (Benaglia et al., 2009) . Using R, we simulate data according to Case 2 of the sampling experiments of Quandt (1972) . That is, we simulate n = 120 observations, where X i = (1, U i ) with U i uniformly distributed between 10 and 20, for i ∈ [n]. Conditioned on X i = x i , we simulate Y i according to the two-component GMR model f Y |X (y i |x i ; θ) = 1 2 φ (y i ; (1, 1) x i , 2) + 1 2 φ (y i ; (0.5, 1.5) x i , 2.5) . In Table 2 , we present the negative log-likelihood risk (5) values for 20 iterations of the EM/MM algorithm to estimate a g = 2 component GMR using the regmixEM function from mixtools, for a single instance of the experimental setup. We see that the risk values are monotonically decreasing in accordance with Proposition 1. Figure 2 display the simulated data, the generative mean model, and the fitted conditional mean functions ŷc (x) = bc1 , bc2 x, for each of the fitted GMR components c = 1, 2. Here the estimate of the parameter elements bc1 , bc2 are contained within θ. Multinomial-logistic regressions With R, we utilize algorithm (19) to compute (1) for the problem of estimating an MLR for the Fisher's Iris data set (Fisher, 1936) . The data is a part of the core datasets package of R and contains n = 150 observations, 50 each, from  0.0 0.5 1.0 1.5 2.0 2.5 3.0 0 50 100 150 log10 iterations Risk Figure 3: Negative log-likelihood risk versus log 10 iterations for the MLR model fitted to the iris data set. The solid line indicates the MM algorithm-obtained sequence, and the dashed line indicates the sequence obtained from the multinom function. g = 3 species of irises. Each observation consists of a feature vector u i = (Sepal Length i , Sepal Width i , Petal Length i , Petal Width i ) , along with a species name y i ∈ {Setosa, Versicolor, Virginica}, for i ∈ [n]. We map the species names to the set [g] for convenience and set x i = 1, u i . A plot of the negative log-likelihood risk versus the logarithm of the number of iterations is presented in Figure 3 , along with the risk sequence obtained from the multinom function of the nnet package (Venables & Ripley, 2002) , which solves the same problem. The difference in convergence speed between the two algorithms is not surprising as multinom utilizes a Newton-Raphson algorithm, which exhibits quadratic-rate convergence to stationary points within a close enough radius to the limit point, whereas MM algorithms only exhibit linear-rate convergence [cf. Lange (2013, Ch. 12) ]. Remark 8. Some practical suggestions for acceleration of convergence speed for MM algorithms are provided in Lange (2016, Ch. 7) . The simplest of such suggestions is to simply double each MM iterate. That is, if at the (r + 1) th step, we make the update θ (r+1) = U θ (r) , then we instead make the update θ (r+1) = θ (r) + 2 U θ (r) -θ (r) . At most, the new updates can halve the number of iterations required. However, fulfillment of inequality ( 11 ) is no longer guaranteed. Support vector machines For ease of visualization, we now concentrate on the first n = 100 observations from the iris data, at the two input variables x i = (Sepal Length i , Sepal Width i ) for i ∈ [n]. The species names, Setosa and Versicolor, are mapped to -1 and 1, respectively, and thus y i ∈ {-1, 1} depending on the species of observation i. A linear-basis SVM is fitted using algorithm (24) with λ = 0.1 for 30 iterations. Table 3 presents the risk (9) at each IRLS/MM iteration, and Figure 4 displays the resulting seperating hyperplane. From Table 3 , we note that the IRLS/MM algorithm convergences quickly in the SVM problem and that the risk is monotonically decreasing as expected. Further, we note that for this subset of the iris data, the separating hyperplane can perfectly separate the two classes; this is not always possible in general. Conclusions The MM algorithm framework is a popular tool for deriving useful algorithms for problems in machine learning and statistical estimation. We have introduced and demonstrated its usage in three example applications: Gaussian mixture regressions, multinomial logistic regressions, and support vector machines; which are commonly applied by practitioners for solving real-world problems. We note that there are aspects of the MM algorithm framework that we have omitted for brevity. For example, we have not discussed the manner in which to choose to terminate an MM algorithm, as this is often a contentious point. A good discussion on the relative merits of different methods can be found in Lange (2013, Sec. 11.5) . Additionally, we have not discussed the many computational benefits of MM algorithms, such as parallelizability and distributability. A case study of parallelizability for heteroscedastic regression is provided in Nguyen et al. (2016a) . General discussions regarding the implementation of MM algorithms on graphical processing units, in parallel, are provided in Zhou et al. (2010) . It is hoped that this article demonstrates the usefulness and ubiquity of the MM algorithm framework to the reader. For enthusiastic and interested readers, we highly recommend the outstanding treatment of the topic in Lange (2016). where f (x, y; θ) is a density function over the support of X and Y , which takes parameter θ. The minimization of the risk in this case yields the maximum likelihood (ML) estimate for the data D, given the parametric family f . Another common risk function is the |•| d -norm difference between the target variable and some function f of the input:f (x i ; θ)| d , where d ∈ [1, 2], y i ∈ R,and f (x; θ) is some predictive function of y i with parameter θ that takes x as an input. Setting d = 1 and d = 2 yield the common least-absolute deviation and least-squares criteria, respectively. Furthermore, taking f (x; θ) = θ x and d = 2 simultaneously yields the classical ordinary least-squares criterion. Here Θ ⊂ R p and the superscript indicates matrix transposition. on X = x, suppose that Y can arise from one of g ∈ N possible component regression regimes. Let Z be a random variable that indicates the component from which Y arises, such that P (Z = c) = π c , where c ∈ [g] ([g] = {1, 2, ..., g}), π c > 0, and g c=1 π c = 1. Write the conditional probability density of Y given X = x and Z = c as Figure 1 : 1 Figure 1: Examples of majorizers for objectives of the form O (θ) = |θ| d at the point υ = 1/2, for d = 1, 1.5. The solid lines indicate the objectives and the dashed lines indicate the majorizers. Figure 2 :Figure 3 : 23 Figure 2: Example of an instance of the Case 2 of the sampling experiments of Quandt (1972). Solid lines indicate generative mean functions according to the g = 2 different components of the mixture, and dashed lines indicate fitted mean functions ŷc (x) for c = 1, 2. Figure 4 : 4 Figure 4: Separating hyperplane between for the classification problem of separating the Setosa and Versicolor irises by their sepal length and width. The dashed line indicates the SVM-obtained separating hyperplane. The Circles and Triangles indicate Setosa and Versicolor irises, respectively. Although example-based, the techniques that are introduced in this article are by no means restricted to the specific examples, nor even to machine learning and statistical estimation; see Chi et al. (2014) and Lange & Zhou (2014) for example. Table 2 : 2 Negative log-likelihood risk for the estimation of a g = 2 component GMR model via an EM/MM algorithm. Iteration Risk 1 325.8761 11 Iteration Risk 294.5583 2 317.1869 12 294.5501 3 314.0193 13 294.5477 4 311.5091 14 294.5470 5 308.0247 15 294.5468 6 302.8068 16 294.5467 7 297.5655 17 294.5467 8 295.1926 18 294.5467 9 294.6909 19 294.5467 10 294.5865 20 294.5467 Table 3 : 3 SVM risk for the iris data with λ = 0.1, obtained via the IRLS/MM algorithm. Iteration Risk 1 47.36808 16 Iteration Risk 47.20901 2 47.29061 17 47.20895 3 47.26262 18 47.20891 4 47.25164 19 47.20888 5 47.24096 20 47.20886 6 47.23068 21 47.20885 7 47.22281 22 47.20884 8 47.21746 23 47.20884 9 47.21405 24 47.20883 10 47.21193 25 47.20883 11 47.21064 26 47.20883 12 47.20988 27 47.20883 13 47.20946 28 47.20882 14 47.20923 29 47.20882 15 47.20910 30 47.20882"
}